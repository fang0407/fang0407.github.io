<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fang0407.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="NOTE">
<meta property="og:url" content="https://fang0407.github.io/page/5/index.html">
<meta property="og:site_name" content="NOTE">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Fang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fang0407.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NOTE</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">NOTE</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/22/RTSP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/22/RTSP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">RTSP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-22 18:30:32" itemprop="dateCreated datePublished" datetime="2023-09-22T18:30:32+08:00">2023-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-09 16:21:18" itemprop="dateModified" datetime="2024-01-09T16:21:18+08:00">2024-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RTSP（Real-Time Stream Protocol）是一种基于文本的应用层协议，在语法及一些消息参数等方面，RTSP 协议与 HTTP 协议类似。其他的关于 RTSP 的介绍后面补充吧，直接通过抓包会更加直观了解到 RTSP 协议的一个交互流程。</p>
<h1 id="推流过程"><a href="#推流过程" class="headerlink" title="推流过程"></a>推流过程</h1><h2 id="OPTION"><a href="#OPTION" class="headerlink" title="OPTION"></a>OPTION</h2><p>client-&gt;server：option 查询服务器端可用方法。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应信息的 public 头字段中包括提供的所有可用方法。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 10:07:06 GMT</span><br><span class="line"><span class="attribute">Public</span><span class="punctuation">: </span>OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, ANNOUNCE, RECORD, SET_PARAMETER, GET_PARAMETER</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br></pre></td></tr></table></figure>

<h2 id="ANNOUNCE"><a href="#ANNOUNCE" class="headerlink" title="ANNOUNCE"></a>ANNOUNCE</h2><p>client-&gt;server：客户端发送媒体描述信息给服务器。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ANNOUNCE rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/sdp</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>2</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>492</span><br><span class="line"></span><br><span class="line">v=0</span><br><span class="line">o=- 0 0 IN IP4 127.0.0.1</span><br><span class="line">s=No Name</span><br><span class="line">c=IN IP4 192.168.2.101</span><br><span class="line">t=0 0</span><br><span class="line">a=tool:libavformat 59.30.100</span><br><span class="line">m=video 0 RTP/AVP 96</span><br><span class="line">b=AS:200</span><br><span class="line">a=rtpmap:96 H264/90000</span><br><span class="line">a=fmtp:96 packetization-mode=1; sprop-parameter-sets=J2QAH6xWgNg95+agICAgQA==,KO48sA==; profile-level-id=64001F</span><br><span class="line">a=control:streamid=0</span><br><span class="line">m=audio 0 RTP/AVP 97</span><br><span class="line">b=AS:128</span><br><span class="line">a=rtpmap:97 MPEG4-GENERIC/44100/2</span><br><span class="line">a=fmtp:97 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=121056E500</span><br><span class="line">a=control:streamid=1</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应媒体描述信息，并返回了 Session ID。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>2</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 10:07:06 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<h2 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h2><p>client-&gt;server：通过 Transport 头字段列出可接受的传输选项，请求建立会话。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETUP rtsp://192.168.2.101:554/live/test/streamid=0 RTSP/1.0</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=31196-31197;mode=record</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>3</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：建立会话，通过 Transport 头字段返回选择的具体转输选项，并返回建立的 Session ID。并且看到对于 RTP 端口通信 31196-&gt;33150；对于 RTCP 端口通信 31197-&gt;33151。 </p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>3</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 10:07:06 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=31196-31197;mode=record;server_port=33150-33151;ssrc=00000000</span><br></pre></td></tr></table></figure>

<p>对于另一个 streamid&#x3D;1 也是一样的：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETUP rtsp://192.168.2.101:554/live/test/streamid=1 RTSP/1.0</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=31198-31199;mode=record</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>4</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>4</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 10:07:06 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=31198-31199;mode=record;server_port=31888-31889;ssrc=00000000</span><br></pre></td></tr></table></figure>

<h2 id="RECORD"><a href="#RECORD" class="headerlink" title="RECORD"></a>RECORD</h2><p>client-&gt;server：请求发送数据。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RECORD rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>npt=0.000-</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>5</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<p>client-&gt;server：回应该允许的信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>5</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 10:07:06 GMT</span><br><span class="line"><span class="attribute">RTP-Info</span><span class="punctuation">: </span>url=rtsp://192.168.2.101:554/live/test/streamid=0,url=rtsp://192.168.2.101:554/live/test/streamid=1</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<h2 id="RTP-数据推送"><a href="#RTP-数据推送" class="headerlink" title="RTP 数据推送"></a>RTP 数据推送</h2><img src="/2023/09/22/RTSP%E5%8D%8F%E8%AE%AE/RTP报文.png" alt="RTP报文" style="zoom:50%;">

<h2 id="TERDOWN"><a href="#TERDOWN" class="headerlink" title="TERDOWN"></a>TERDOWN</h2><p>client-&gt;server：请求关闭会话。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEARDOWN rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>6</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应该请求，200 正常关闭。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>6</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 10:07:10 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>viBkiUQCL9ES</span><br></pre></td></tr></table></figure>

<h1 id="拉流过程"><a href="#拉流过程" class="headerlink" title="拉流过程"></a>拉流过程</h1><h2 id="OPTION-1"><a href="#OPTION-1" class="headerlink" title="OPTION"></a>OPTION</h2><p>client-&gt;server：查询哪些方法可用。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应信息的 public 头字段中包括提供的所有可用方法。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 11:19:53 GMT</span><br><span class="line"><span class="attribute">Public</span><span class="punctuation">: </span>OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, ANNOUNCE, RECORD, SET_PARAMETER, GET_PARAMETER</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br></pre></td></tr></table></figure>

<h2 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h2><p>client-&gt;server：要求得到服务提供的媒体描述信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/sdp</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>2</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应媒体描述信息，一般是 sdp 信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">Content-Base</span><span class="punctuation">: </span>rtsp://192.168.2.101:554/live/test/</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>589</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/sdp</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>2</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 11:19:53 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br><span class="line"><span class="attribute">x-Accept-Dynamic-Rate</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">x-Accept-Retransmit</span><span class="punctuation">: </span>our-retransmit</span><br><span class="line"></span><br><span class="line">v=0</span><br><span class="line">o=- 0 0 IN IP4 0.0.0.0</span><br><span class="line">s=Streamed by ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">t=0 0</span><br><span class="line">a=range:npt=now-</span><br><span class="line">a=control:*</span><br><span class="line">m=video 0 RTP/AVP 96</span><br><span class="line">b=AS:200</span><br><span class="line">a=fmtp:96 packetization-mode=1; sprop-parameter-sets=J2QAH6xWgNg95+agICAgQA==,KO48sA==; profile-level-id=64001F</span><br><span class="line">a=rtpmap:96 H264/90000</span><br><span class="line">a=control:streamid=0</span><br><span class="line">m=audio 0 RTP/AVP 97</span><br><span class="line">b=AS:128</span><br><span class="line">a=fmtp:97 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=121056E500</span><br><span class="line">a=rtpmap:97 MPEG4-GENERIC/44100/2</span><br><span class="line">a=control:streamid=1</span><br></pre></td></tr></table></figure>

<h2 id="SETUP-1"><a href="#SETUP-1" class="headerlink" title="SETUP"></a>SETUP</h2><p>client-&gt;server：通过 Transport 头字段列出可接受的传输选项，请求建立会话。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETUP rtsp://192.168.2.101:554/live/test/streamid=0 RTSP/1.0</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=32316-32317</span><br><span class="line"><span class="attribute">x-Dynamic-Rate</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>3</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：建立会话，通过 Transport 头字段返回选择的具体转输选项。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>3</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 11:19:53 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=32316-32317;server_port=30580-30581;ssrc=A336E81F</span><br></pre></td></tr></table></figure>

<p>对于另一个 streamid&#x3D;1 如下，注意 ssrc 源是不同 ID。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETUP rtsp://192.168.2.101:554/live/test/streamid=1 RTSP/1.0</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=32318-32319</span><br><span class="line"><span class="attribute">x-Dynamic-Rate</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>4</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>4</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 11:19:53 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br><span class="line"><span class="attribute">Transport</span><span class="punctuation">: </span>RTP/AVP/UDP;unicast;client_port=32318-32319;server_port=34870-34871;ssrc=DDA40D88</span><br></pre></td></tr></table></figure>

<h2 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h2><p>client-&gt;server：请求开始发送数据。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAY rtsp://192.168.2.101:554/live/test/ RTSP/1.0</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>npt=0.000-</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>5</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应该请求的信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>5</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 11:19:53 GMT</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>npt=0.000-</span><br><span class="line"><span class="attribute">RTP-Info</span><span class="punctuation">: </span>url=rtsp://192.168.2.101:554/live/test/streamid=0;seq=6937;rtptime=1382371650,url=rtsp://192.168.2.101:554/live/test/streamid=1;seq=2132;rtptime=-2108239456</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br></pre></td></tr></table></figure>

<h2 id="RTP-数据拉取"><a href="#RTP-数据拉取" class="headerlink" title="RTP 数据拉取"></a>RTP 数据拉取</h2><img src="/2023/09/22/RTSP%E5%8D%8F%E8%AE%AE/RTP拉流报文.png" alt="RTP拉流报文" style="zoom:50%;">

<p>SSRC 推流是客户端自己定义的，拉流的时候是服务器发送过来的。</p>
<h2 id="TERDOWN-1"><a href="#TERDOWN-1" class="headerlink" title="TERDOWN"></a>TERDOWN</h2><p>client-&gt;server：请求关闭会话。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEARDOWN rtsp://192.168.2.101:554/live/test RTSP/1.0</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>6</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Lavf59.30.100</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br></pre></td></tr></table></figure>

<p>server-&gt;client：回应该请求，200 正常关闭。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line"><span class="attribute">CSeq</span><span class="punctuation">: </span>6</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, Sep 22 2023 11:22:10 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ZLMediaKit(git hash:f69f3b3/2023-09-09T10:59:27+08:00,branch:master,build time:2023-09-19T18:24:32)</span><br><span class="line"><span class="attribute">Session</span><span class="punctuation">: </span>CdplhrJIUmWx</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/21/RTP%E4%B9%8BAAC%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/21/RTP%E4%B9%8BAAC%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/" class="post-title-link" itemprop="url">RTP之AAC封包和解包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-21 20:57:45" itemprop="dateCreated datePublished" datetime="2023-09-21T20:57:45+08:00">2023-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-10 09:35:35" itemprop="dateModified" datetime="2024-01-10T09:35:35+08:00">2024-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RTP-的-AAC-打包"><a href="#RTP-的-AAC-打包" class="headerlink" title="RTP 的 AAC 打包"></a>RTP 的 AAC 打包</h1><h2 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h2><ul>
<li>需要将 AAC 的前 7 个（或 9 个）字节的 ADTS 去掉，即是跳过 ADTS Header。</li>
<li>添加 RTP Header（一般 12 字节）。</li>
<li>添加 2 字节的 AU_HEADER_LENGTH。</li>
<li>添加 2 字节的 AU_HEADER。</li>
<li>从第 17 字节开始就是 payload（去掉 ADTS 的 AAC 数据）数据了。</li>
</ul>
<h2 id="音频-AAC-打包格式"><a href="#音频-AAC-打包格式" class="headerlink" title="音频 AAC 打包格式"></a>音频 AAC 打包格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       AU-headers-length       |         AU-header(1)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         AU-header(2)          |         AU-header(n)          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>RTP 承载 AAC 的格式由两部分组成：</p>
<ul>
<li>2 个字节的 AU-headers-length。</li>
<li>n 个 AU-header，每个 2 字节。</li>
<li>n 个 AU，是 AAC 去掉 ADTS 的载荷。</li>
</ul>
<p>注意：一个 RTP 包中可以有一个 AU-headers-length 和 n 个 AU-header 和 n 个 AU（AU 每包实际音频数据流）。</p>
<h3 id="AU-headers-length"><a href="#AU-headers-length" class="headerlink" title="AU-headers-length"></a>AU-headers-length</h3><p>头两个字节表示 AU-header  的长度，单位是 bit。 一个 AU-header 长度是两个字节（16 bit）因为可以有多个 AU-header 所以 AU-headers-length 的值是 16 的倍数，<strong>一般音频都是单个音频数据流的发送</strong>，所以 AU-headers-length 的值是 16。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AU_HEADER_LENGTH</span></span><br><span class="line">bytes[<span class="number">12</span>] = <span class="number">0x00</span>; <span class="comment">//高位</span></span><br><span class="line">bytes[<span class="number">13</span>] = <span class="number">0x10</span>; <span class="comment">//低位 只有一个AU_HEADER</span></span><br></pre></td></tr></table></figure>

<p>因为单位是 bit，除以 8 就是 AU-header 的字节长度；又因为单个 AU-header 字节长度 2 字节，所以再除以 2 就是 AU-header 的个数。</p>
<h3 id="AU-header"><a href="#AU-header" class="headerlink" title="AU-header"></a>AU-header</h3><p>一个 AU-header 长度是两个字节，<strong>AU-header 的高 13 个 bits 是 AU-size，就是一个 AU 的字节长度</strong>；<strong>低 3 bits 是 AU-Index（或者AU-Index-delta），就是 AU 的索引（或者索引增量）</strong>。如下获取 AU 的字节长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AU_HEADER</span></span><br><span class="line">bytes[<span class="number">14</span>] = (byte)(len &gt;&gt; <span class="number">5</span>); <span class="comment">//高位</span></span><br><span class="line">bytes[<span class="number">15</span>] = (byte)((len &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">3</span>); <span class="comment">//低位</span></span><br></pre></td></tr></table></figure>

<h3 id="RTSP-SDP-中的-AAC-配置"><a href="#RTSP-SDP-中的-AAC-配置" class="headerlink" title="RTSP&#x2F;SDP 中的 AAC 配置"></a>RTSP&#x2F;SDP 中的 AAC 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=fmtp:96 streamtype=5; profile-level-id=1; mode=AAC-hbr; config=138856e500; sizeLength=13; indexLength=3; indexDeltaLength=3; Profile=1;</span><br></pre></td></tr></table></figure>

<p>如下将简述 config，SizeLength，IndexLength，IndexDeltaLength 的作用。</p>
<h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>config 是 16 进制的，前两个字节 1388，前两个字节的为 ios-14996-3 中定义的 AudioSpecificConfig，前 13 个 bits 的格式为：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>比特数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>audioObjectType</td>
<td>5</td>
<td>aac 的 profile, 通常情况是 1, 或者 2</td>
</tr>
<tr>
<td>samplingFrequencyIndex</td>
<td>4</td>
<td>aac 的采样频率的索引, 见下表</td>
</tr>
<tr>
<td>channelConfiguration</td>
<td>4</td>
<td>aac 的通道数，1~6 表示为相应的通道数量，7 表示 8 通道</td>
</tr>
</tbody></table>
<p>samplingFrequencyIndex 的取值如下表：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>采样频率</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>96000</td>
</tr>
<tr>
<td>1</td>
<td>88200</td>
</tr>
<tr>
<td>2</td>
<td>64000</td>
</tr>
<tr>
<td>3</td>
<td>48000</td>
</tr>
<tr>
<td>4</td>
<td>44100</td>
</tr>
<tr>
<td>5</td>
<td>32000</td>
</tr>
<tr>
<td>6</td>
<td>24000</td>
</tr>
<tr>
<td>7</td>
<td>22050</td>
</tr>
<tr>
<td>8</td>
<td>16000</td>
</tr>
<tr>
<td>9</td>
<td>12000</td>
</tr>
<tr>
<td>10</td>
<td>11025</td>
</tr>
<tr>
<td>11</td>
<td>8000</td>
</tr>
<tr>
<td>12</td>
<td>7350</td>
</tr>
<tr>
<td>15</td>
<td>表示自定义的采样频率, 一般不会出现</td>
</tr>
</tbody></table>
<p>根据上述表格比对：1388 转换成二进制为 0001 0011 1000 1000。</p>
<p>audioObjectType 为 00010，即 2。</p>
<p>samplingFrequencyIndex 为 0111，即 7，对应的采样频率为 22050。</p>
<p>channelConfiguration 为 0001，表示 channel 数量为 1。</p>
<p>所以 config 前两个字节 1388 ，表示采样率为 22050，1 个 channel。</p>
<h4 id="sizeLength、indexLength-和-indexDeltaLength"><a href="#sizeLength、indexLength-和-indexDeltaLength" class="headerlink" title="sizeLength、indexLength 和 indexDeltaLength"></a>sizeLength、indexLength 和 indexDeltaLength</h4><p>sizeLength 表示 AU-size 占用的比特数量。</p>
<p>indexLength 表示 AU-Index 占用的比特数量。</p>
<p>indexDeltaLength 表示 AU-Index-delta 占用的比特数量。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>比特数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AU-headers-length</td>
<td>0 或 16</td>
<td>如果没有 AU-Header, 即 fmtp 中不出现 SizeLength 等参数时, 此字段不存在。<br>否则, 使用两个字节来存储所有 AU-Header 所占用的比特数(不包含自己, 不包含 padding 字段), ⽹络字节序。</td>
</tr>
<tr>
<td>AU-size</td>
<td>sizeLength 决定</td>
<td>表示本段音频数据占用的字节数</td>
</tr>
<tr>
<td>AU-Index</td>
<td>indexLength 决定</td>
<td>表示本段的序号, 通常 0 开始</td>
</tr>
<tr>
<td>AU-Index-delta</td>
<td>indexDeltaLength 决定</td>
<td>表示本段序号与上一段序号的差值</td>
</tr>
</tbody></table>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d2e2a9dc5697">https://www.jianshu.com/p/d2e2a9dc5697</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/" class="post-title-link" itemprop="url">RTP之H264封包和解包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-19 21:37:41" itemprop="dateCreated datePublished" datetime="2023-09-19T21:37:41+08:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-10 09:30:41" itemprop="dateModified" datetime="2024-01-10T09:30:41+08:00">2024-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="NALU-格式"><a href="#NALU-格式" class="headerlink" title="NALU 格式"></a>NALU 格式</h1><p>H.264 标准协议定义了两种不同的类型：一种是 VCL 即 Video Coding Layer ， 一种是 NAL 即 Network Abstraction Layer。其中前者就是编码器吐出来的原始编码数据，没有考虑传输和存储问题。后面这种就是为了展现 H.264 的网络亲和性，对 VCL 输出的 slice 片数据进行了封装为 NALUs(NAL Units)，然后再封装为 RTP 包进行传输，这些都是 H.264 的基础。</p>
<p>NALU 的基本格式是：NALU Header + NALU Data，其中 NALU 的头由一个字节组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|0|1|2|3|4|5|6|7|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|F|NRI|  Type   |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>F(1 bit)</td>
<td>如果是坏帧，则置 1，其余 H.264 固定为 0。</td>
</tr>
<tr>
<td>NRI(2 bit)</td>
<td>用来指示该 NALU 的重要性等级。值越大，表示当前 NALU 越重要。具体大于 0 时取何值，没有具体规定。<br>例如：如果是 00，则表示此帧即使丢失了，也不影响解码；其他值则表示此帧如果丢失了，会影响解码，这个字段指明了该 NALU 的重要性，但是实际我们不太关心这个字段。</td>
</tr>
<tr>
<td>Nalu_Type(5 bit)</td>
<td>NAL Unit 的类型，这个值指明了 NALU 的类型，其中 NALU 的类型见下表。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Nalu_Type</th>
<th>NALU内容</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未指定</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>非 IDR 图像编码的 slice</td>
<td>比如普通 I、P、B 帧</td>
</tr>
<tr>
<td>2</td>
<td>编码 slice 数据划分 A</td>
<td>2 类型时，只传递片中最重要的信息，如片头，片中宏块的预测模式等；一般不会用到</td>
</tr>
<tr>
<td>3</td>
<td>编码 slice 数据划分 B</td>
<td>3 类型是只传输残差；一般不会用到</td>
</tr>
<tr>
<td>4</td>
<td>编码 slice 数据划分 C</td>
<td>4 时则只可以传输残差中的 AC 系数；一般不会用到</td>
</tr>
<tr>
<td>5</td>
<td>IDR 图像中的编码 slice</td>
<td>IDR 帧，IDR 一定是 I 帧但是 I 帧不一定是 IDR 帧</td>
</tr>
<tr>
<td>6</td>
<td>SEI 补充增强信息单元</td>
<td>可以存一些私有数据等</td>
</tr>
<tr>
<td>7</td>
<td>SPS 序列参数集</td>
<td>编码的参数配置</td>
</tr>
<tr>
<td>8</td>
<td>PPS 图像参数集</td>
<td>编码的参数配置</td>
</tr>
<tr>
<td>9</td>
<td>接入单元定界符</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>序列结束</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>码流结束</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>填充数据</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>STAP-A</td>
<td>单一时间聚合包模式，意味着一个RTP包可以传输多个 NALU，但是这些 NALU 的编码时间要一样才能聚合到一个 RTP。</td>
</tr>
<tr>
<td>25</td>
<td>STAP-B</td>
<td>单一时间聚合包模式，比 STAP-B 多一个 DON。</td>
</tr>
<tr>
<td>26</td>
<td>MTAP 16</td>
<td>多个时间聚合包模式：意味着一个RTP包可以传输多个 NALU，但是这些 NALU 的编码时间有可能不一样。</td>
</tr>
<tr>
<td>27</td>
<td>MTAP 24</td>
<td>多个时间的聚合包模式。</td>
</tr>
<tr>
<td>28</td>
<td>FU-A</td>
<td>分包模式：当一个 RTP 容纳不下一个 NALU 时，就需要 FUs 这种格式。</td>
</tr>
<tr>
<td>29</td>
<td>FU-B</td>
<td>分包模式。</td>
</tr>
<tr>
<td>30-31</td>
<td>未指定，保留</td>
<td></td>
</tr>
</tbody></table>
<p>我们看到 1-11 就是 NALU 的单个包类型，但是一个 NALU 的大小是不一样的，如果是非视频数据的 SPS PPS 才十几个字节，对于 IDR 帧，则有可能几十 KB。 </p>
<h1 id="RTP-的-H264-打包"><a href="#RTP-的-H264-打包" class="headerlink" title="RTP 的 H264 打包"></a>RTP 的 H264 打包</h1><p>把 NALU 打包到 RTP 方式就很多，分为： </p>
<ul>
<li>一个 RTP 包承载一个 NALU</li>
<li>多个 NALU 合并到一个 RTP</li>
<li>一个大的 NALU 切分成多个 RTP</li>
</ul>
<p>同时由于时间戳的问题，就有了 24-29 几种类型。 </p>
<p>但是对于发送端组 RTP 包的一方来说，尽可能找简单的打包方式。对于接受端则需要适配各种发送端的打包方式，因为无法决定输入源的打包方式。比较简单的打包方式：</p>
<ul>
<li>我们对于 <strong>NALU 的长度&lt;&#x3D;1400</strong>（rtp payload size）的则采用的是<strong>单一 NALU 打包到单一的 RTP 包中</strong>。</li>
<li>我们对于 <strong>NALU的长度&gt;1400</strong>的则采用了 <strong>FU-A 的方式</strong>进行了打包，这种就是把一个大的 NALU 进行了切分，最后接收方则进行了合并，把多个 RTP 包合并成一个完整的NALU即可。</li>
</ul>
<p><strong>为什么 NALU 的长度大于 1400 字节就要进行 FU-A 切片</strong>，是因为底层 MTU 大小值固定为 1500，从传输效率讲，这里用 1400 作为切分条件。</p>
<p>如下图所示： </p>
<img src="/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/RTP协议.png" alt="RTP协议" style="zoom:50%;">

<ul>
<li>28、29、30 三个 RTP 分别传输的 SPS、PPS、SEI 这三种 NALU，其中一个 NALU 分到一个 RTP 包，这是单一打包方式。</li>
<li>31、32 三个RTP包分别传输了 IDR 帧的 NALU 单元，由于比较大，发送方采用了 FU-A 的打包方式。</li>
<li>上图还显示了 SPS、PPS、SEI 的 RTP 包固定头，Seq 初始值不为 0，为随机值，并且一个 RTP 包就顺序+1，这跟上面分析的一致。</li>
<li>上面 SPS、PPS、SEI 本身不涉及时间戳，但是这里头填充为和自己后面的第一个 RTP 保持一致，同样 IDR 的 NALU 切分的不同 RTP 包时间戳也是一样的。</li>
</ul>
<h2 id="单一-NALU-打包"><a href="#单一-NALU-打包" class="headerlink" title="单一 NALU 打包"></a>单一 NALU 打包</h2><p>就是一个 RTP 包打包一个单独的 NALU 方式，其实最好理解，就是在RTP固定头后面<strong>直接填充 NALU 单元数据</strong>即可，即： </p>
<p>RTP Header + NALU Header + NALU Data; （<strong>不包括startcode</strong>） </p>
<img src="/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/单一NALU打包.png" alt="单一NALU打包" style="zoom:50%;">

<p>抓包可以看到第一个字节为 67 即 SPS，后面开始就是 NALU Data 部分。</p>
<h2 id="FU-A-打包"><a href="#FU-A-打包" class="headerlink" title="FU-A 打包"></a>FU-A 打包</h2><p>FU-A（Fragmentation Unit - Type A）的荷载格式用于传输 H.264 视频编码的分片数据。在 RTP FU-A 中，NALU（Network Abstraction Layer Unit）帧被分成小片段并封装成 RTP 包。以下是 RTP FU-A 的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| FU indicator  |   FU header   |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|                                                               |</span><br><span class="line">|                         FU payload                            |</span><br><span class="line">|                                                               |</span><br><span class="line">|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               :...OPTIONAL RTP padding        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>这种打包方式也不复杂，为了解释清楚，需要了解下面两个数据包头即 FU indicator 和 Fu header。</p>
<h3 id="FU-indication"><a href="#FU-indication" class="headerlink" title="FU indication"></a>FU indication</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|0|1|2|3|4|5|6|7|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|F|NRI|  Type   |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<p>这里面的的 F 和 NRI 已经在 NALU 的 Header 解释清楚了，就是 NALU 头的前面三个 bit 位，<strong>后面的 TYPE 就是 NALU 的 FU-A 类型 28</strong>，这样在 RTP 固定头后面第一字节的后面 5 bit 提取出来就确认了该 RTP 包承载的不是一个完整的 NALU，是其一部分。</p>
<p>那么问题来了，一个 NALU 切分成多个 RTP 包传输，那么到底从哪儿开始哪儿结束呢？可能有人说 RTP 包固定头不是有 mark 标记么，注意区分那个是以<strong>帧图像的结束标记</strong>，这里要确定是 NALU 结束的标记，其次 NALU 的类型呢？那么就需要 <strong>RTP 固定 12 字节后面的 Fu Header 来进行区分</strong>。</p>
<h3 id="FU-header"><a href="#FU-header" class="headerlink" title="FU header"></a>FU header</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|0|1|2|3|4|5|6|7|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|S|E|R|  Type   |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li><p>S: 1 bit，当设置成 1，开始位指示分片 NAL 单元的开始。当跟随的 FU 荷载不是分片 NAL 单元荷载的开始，开始位设为 0。</p>
</li>
<li><p>E: 1 bit，当设置成 1，结束位指示分片 NAL 单元的结束，即, 荷载的最后字节也是分片 NAL 单元的最后一个字节，当跟随的 FU 荷载不是分片 NAL 单元的最后分片，结束位设置为 0。也就是说一个 NALU 切片时，<strong>第一个切片的 SE 是 10，然后中间的切片是 00，最后一个切片时 01</strong>。 </p>
</li>
<li><p>R: 1 bit，保留位必须设置为 0，接收者必须忽略该位。</p>
</li>
<li><p>Type: 5 bits，此处的 Type 就是 NALU 头中的 Type，取 1-23 的那个值，表示 NAL 单元荷载类型定义。</p>
</li>
</ul>
<p>为了验证这种打包方式，我们同样进行了写文件和抓包，对第一个 IDR 帧的 NLAU 采取的这种分片进行了研究。 </p>
<h4 id="IDR-帧的-NALU-第一个切片"><a href="#IDR-帧的-NALU-第一个切片" class="headerlink" title="IDR 帧的 NALU 第一个切片"></a>IDR 帧的 NALU 第一个切片</h4><img src="/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/FU-A打包第一个切片.png" alt="FU-A打包第一个切片" style="zoom:50%;">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FU indication</span><br><span class="line">十六机制：0x7C </span><br><span class="line">二进制：0111 1100</span><br><span class="line"></span><br><span class="line">FU header</span><br><span class="line">十六进制：0x85</span><br><span class="line">二进制：1000 0101</span><br></pre></td></tr></table></figure>

<p>这里的 SE 是 10，则说明该 RTP 包承载的 NALU 的第一个切片。</p>
<p>FU indication 字节的前 3 bit 位和 Fu header 字节后 5 bit 位则为 0110 0101 即 0x65 这刚好符合 IDR 帧的 NALU Header 定义，后面的 b8 00 00 03 等二进制就是 NALU 的 DATA 字段。 </p>
<h4 id="IDR-帧的-NALU-第二个切片"><a href="#IDR-帧的-NALU-第二个切片" class="headerlink" title="IDR 帧的 NALU 第二个切片"></a>IDR 帧的 NALU 第二个切片</h4><img src="/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/FU-A打包中间切片.png" alt="FU-A打包中间切片" style="zoom:50%;">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FU indication</span><br><span class="line">十六机制：0x7C</span><br><span class="line">二进制：0111 1100</span><br><span class="line"></span><br><span class="line">FU header</span><br><span class="line">十六进制：0x05</span><br><span class="line">二进制：0000 0101</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 SE 是 00，则说明该 RTP 包承载的 NALU 的中间切片。</li>
<li>按照同样方法提取，则 NALU Header 的二进制为 0110 0101 即 0x65，同样说明是 IDR 帧类型，类似这种的中间切片有很多，从 31-56 RTP 包都是中间切片，直到最后一个 NALU 的切片。</li>
</ul>
<h4 id="IDR-帧的-NALU-最后一个切片"><a href="#IDR-帧的-NALU-最后一个切片" class="headerlink" title="IDR 帧的 NALU 最后一个切片"></a>IDR 帧的 NALU 最后一个切片</h4><img src="/2023/09/19/RTP%E4%B9%8BH264%E5%B0%81%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/FU-A打包最后切片.png" alt="FU-A打包最后切片" style="zoom:50%;">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FU indication</span><br><span class="line">十六机制：0x7C</span><br><span class="line">二进制：0111 1100</span><br><span class="line"></span><br><span class="line">FU header</span><br><span class="line">十六进制：0x45</span><br><span class="line">二进制：0100 0101</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 SE 是 01，则说明该 RTP 包承载的 NALU 的最后一个切片。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rtp_h264_pack_fu_a</span><span class="params">(<span class="keyword">struct</span> <span class="type">rtp_encode_h264_t</span> *packer, <span class="type">const</span> <span class="type">uint8_t</span>* nalu, <span class="type">int</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r, n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *rtp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RFC6184 5.3. NAL Unit Header Usage: Table 2 (p15)</span></span><br><span class="line">    <span class="comment">// RFC6184 5.8. Fragmentation Units (FUs) (p29)</span></span><br><span class="line">    <span class="type">uint8_t</span> fu_indicator = (*nalu &amp; <span class="number">0xE0</span>) | <span class="number">28</span>; <span class="comment">// FU-A 固定的逻辑</span></span><br><span class="line">    <span class="type">uint8_t</span> fu_header = *nalu &amp; <span class="number">0x1F</span>;           </span><br><span class="line"></span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    nalu += <span class="number">1</span>; <span class="comment">// skip NAL Unit Type byte</span></span><br><span class="line">    bytes -= <span class="number">1</span>;</span><br><span class="line">    assert(bytes &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FU-A start, 设置为s置位1</span></span><br><span class="line">    <span class="keyword">for</span> (fu_header |= FU_START; <span class="number">0</span> == r &amp;&amp; bytes &gt; <span class="number">0</span>; ++packer-&gt;pkt.rtp.seq) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes + RTP_FIXED_HEADER &lt;= packer-&gt;size - N_FU_HEADER) &#123;</span><br><span class="line">            assert(<span class="number">0</span> == (fu_header &amp; FU_START));</span><br><span class="line">            fu_header = FU_END | (fu_header &amp; <span class="number">0x1F</span>); <span class="comment">// FU-A end  整个nalu结束了</span></span><br><span class="line">            packer-&gt;pkt.payloadlen = bytes;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            packer-&gt;pkt.payloadlen = packer-&gt;size - RTP_FIXED_HEADER - N_FU_HEADER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        packer-&gt;pkt.payload = nalu;</span><br><span class="line">        n = RTP_FIXED_HEADER + N_FU_HEADER + packer-&gt;pkt.payloadlen;</span><br><span class="line">        <span class="comment">//分配内存</span></span><br><span class="line">        rtp = (<span class="type">uint8_t</span>*)packer-&gt;handler.alloc(packer-&gt;cbparam, n);</span><br><span class="line">        <span class="keyword">if</span> (!rtp) <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        packer-&gt;pkt.rtp.m = (FU_END &amp; fu_header) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// set marker flag</span></span><br><span class="line">        n = rtp_packet_serialize_header(&amp;packer-&gt;pkt, rtp, n);</span><br><span class="line">        <span class="keyword">if</span> (n != RTP_FIXED_HEADER) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*fu_indicator + fu_header*/</span></span><br><span class="line">        rtp[n + <span class="number">0</span>] = fu_indicator;</span><br><span class="line">        rtp[n + <span class="number">1</span>] = fu_header;</span><br><span class="line">        <span class="built_in">memcpy</span>(rtp + n + N_FU_HEADER, packer-&gt;pkt.payload, packer-&gt;pkt.payloadlen);</span><br><span class="line">        </span><br><span class="line">        r = packer-&gt;handler.packet(packer-&gt;cbparam, </span><br><span class="line">                                   rtp, n + N_FU_HEADER + packer-&gt;pkt.payloadlen, </span><br><span class="line">                                   packer-&gt;pkt.rtp.timestamp, <span class="number">0</span>);</span><br><span class="line">        packer-&gt;handler.<span class="built_in">free</span>(packer-&gt;cbparam, rtp);</span><br><span class="line">        </span><br><span class="line">        bytes -= packer-&gt;pkt.payloadlen;</span><br><span class="line">        nalu += packer-&gt;pkt.payloadlen;</span><br><span class="line">        fu_header &amp;= <span class="number">0x1F</span>; <span class="comment">// clear flags</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Wireshark-解析-RTP-包中-H264"><a href="#Wireshark-解析-RTP-包中-H264" class="headerlink" title="Wireshark 解析 RTP 包中 H264"></a>Wireshark 解析 RTP 包中 H264</h1><ul>
<li>选择 RTP 包</li>
<li>鼠标右击选择解码为（Decode As）…</li>
<li>在当前（currnet）属性列表中选择 RTP，并保存</li>
<li>可以看到选中的包协议类型为 RTP，PT 为 96</li>
<li>选择编辑（Edit）中的首选项（Preferences）</li>
<li>左侧菜单列表选择 Protocols 中的 H264</li>
<li>根据上面 PT 为 96，填写 H264 dynamic payload types 为 96，并保存</li>
<li>可以看到协议类型变为 H264</li>
</ul>
<p>Wireshark H264 导出工具：<a target="_blank" rel="noopener" href="https://github.com/volvet/h264extractor">https://github.com/volvet/h264extractor</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/19/RTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/19/RTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">RTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-19 20:31:33" itemprop="dateCreated datePublished" datetime="2023-09-19T20:31:33+08:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-09 14:57:18" itemprop="dateModified" datetime="2024-01-09T14:57:18+08:00">2024-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RTP-简介"><a href="#RTP-简介" class="headerlink" title="RTP 简介"></a>RTP 简介</h1><p>RTP（real-time transport protocol），实时传输协议，用于在计算机网络中传输实时数据，特别是音频和视频数据。RTP 通常与其伴随的协议 RTCP（RTP Control Protocol）一起使用，用于监视和管理多媒体会话。</p>
<h1 id="RTP-包格式"><a href="#RTP-包格式" class="headerlink" title="RTP 包格式"></a>RTP 包格式</h1><p>RTP 报文由两部分组成：<strong>报头和有效载荷</strong>。RTP 报文格式如下图所示：</p>
<img src="/2023/09/19/RTP%E5%8D%8F%E8%AE%AE/RTP报文格式.png" alt="RTP报文格式" style="zoom:100%;">

<ul>
<li><p>V：RTP 协议的版本号，占 2 位，当前协议版本号为 2。</p>
</li>
<li><p>P：填充标志，占 1 位，如果 P&#x3D;1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。</p>
</li>
<li><p>X：扩展标志，占 1 位，如果 X&#x3D;1，则在 RTP 报头后跟有一个扩展报头。 </p>
</li>
<li><p>CC：CSRC 计数器，占 4 位，指示 CSRC 标识符的个数。 </p>
</li>
<li><p>M：标记，占 1 位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记帧的开始。</p>
</li>
<li><p>Payload：有效载荷类型，占 7 位，用于说明 RTP 报文中有效载荷的类型，如 GSM 音频、JPEM 图像等。 </p>
</li>
<li><p>Sequence number：序列号，占 16 位，用于标识发送者所发送的 RTP 报文的序列号，<strong>每发送一个报文，序列号增 1</strong>。<strong>接收者通过序列号来检测报文丢失情况</strong>，重新排序报文，恢复数据。</p>
</li>
<li><p>Time stamp：时间戳，占 32 位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 </p>
</li>
<li><p>SSRC Identifier：同步信源（SSRC），占 32 位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的 SSRC。</p>
</li>
<li><p>Contributing Sources：特约信源（CSRC），每个 CSRC 标识符占 32 位，可以有 0～15 个。每个 CSRC 标识了包含在该 RTP 报文有效载荷中的所有特约信源。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rtp_header_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> v:<span class="number">2</span>;        <span class="comment">/* protocol version */</span></span><br><span class="line">    <span class="type">uint32_t</span> p:<span class="number">1</span>;        <span class="comment">/* padding flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> x:<span class="number">1</span>;        <span class="comment">/* header extension flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> cc:<span class="number">4</span>;       <span class="comment">/* CSRC count */</span></span><br><span class="line">    <span class="type">uint32_t</span> m:<span class="number">1</span>;        <span class="comment">/* marker bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> pt:<span class="number">7</span>;       <span class="comment">/* payload type */</span></span><br><span class="line">    <span class="type">uint32_t</span> seq:<span class="number">16</span>;     <span class="comment">/* sequence number */</span></span><br><span class="line">    <span class="type">uint32_t</span> timestamp;  <span class="comment">/* timestamp */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssrc;       <span class="comment">/* synchronization source */</span></span><br><span class="line">&#125; <span class="type">rtp_header_t</span>;</span><br></pre></td></tr></table></figure>

<h1 id="RTP-扩展头"><a href="#RTP-扩展头" class="headerlink" title="RTP 扩展头"></a>RTP 扩展头</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       defined by profile       |           length              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        extension data                          |</span><br><span class="line">|                             ....                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>defined by profile：16 位，用于指示扩展的类型。<strong>不同的 RTP 应用可以定义不同类型的扩展</strong>。这个字段用于指示是哪种类型的扩展。</p>
<ul>
<li>profile 值为 0xBE、0xDE，说明 extension data 的 ID 和 len 占 1 个字节；即 ID 占 4 位，length 占 4 位。</li>
<li>profile 值为 0x10、0x0X（“X”表示任意数, 一般为“0”, 即 0x00）, 说明 extension data 的 ID 和 len 占 2 个字节；即 ID 占 8 位  length 占 8 位。</li>
</ul>
</li>
<li><p>length：16 位，指定扩展的总长度（<strong>以 32 位单位</strong>）。这是<strong>扩展数据的字节数</strong>。例如: length &#x3D; 3, 说明扩展头长度占 12 字节。</p>
</li>
<li><p>extension data：扩展数据字段包含<strong>实际的扩展信息</strong>。其内容和格式完全由所使用的 RTP 应用协议定义。</p>
</li>
</ul>
<h1 id="同步信源和特约信源"><a href="#同步信源和特约信源" class="headerlink" title="同步信源和特约信源"></a>同步信源和特约信源</h1><ul>
<li><p>同步信源（SSRC）是<strong>指产生媒体流的信源</strong>，例如麦克风、摄像机、RTP 混合器等。它通过 RTP 报头中的一个 32 位数字 SSRC 标识符来标识，<strong>而不依赖于网络地址</strong>，接收者将根据 <strong>SSRC 标识符来区分不同的信源，进行 RTP 报文的分组</strong>。</p>
</li>
<li><p>特约信源（CSRC）是指当混合器接收到一个或多个同步信源的 RTP 报文后，<strong>经过混合处理产生一个新的组合 RTP 报文</strong>，<strong>并把混合器作为组合 RTP 报文的 SSRC</strong>，<strong>而将原来所有的 SSRC 都作为 CSRC 传送给接收者</strong>，使接收者知道组成组合报文的各个 SSRC。</p>
</li>
<li><p>在发送端，上层应用程序以分组形式将编码后的媒体数据传给 RTP 通信模块，作为 RTP 报文的有效载荷，RTP 通信模块将根据上层应用提供的参数在有效载荷前添加 RTP 报头，形成 RTP 报文，通过 Socket 接口选择 UDP 协议发送出去。</p>
</li>
<li><p>在接收端，RTP 通信模块通过 Socket 接口接收到 RTP 报文后，将RTP报头分离出来作相应处理，再将 RTP 报文的有效载荷作为数据分组传递给上层应用。</p>
</li>
<li><p>若一个 RTP 包流的源，对由 RTP 混频器生成的组合流起了作用，则它就是一个作用源。对特定包的生成起作用的源，其 SSRC 标识符组成的列表，被混频器插入到包的 RTP 报头中。这个列表叫做 CSRC 表。用图表示大概是这样：</p>
</li>
</ul>
<pre class="mermaid">graph LR
SSRC1--RTP1-->混合器SSRC4
SSRC2--RTP1-->混合器SSRC4
SSRC3--RTP1-->混合器SSRC4
混合器SSRC4--RTP-->接收端</pre>

<p>例如，有三个信号源各发出一路 RTP 流，RTP1 携带的 SSRC 是 SSRC1，RTP2 携带的 SSRC 是 SSRC2，RTP3 携带 SSRC3，这三路 RTP 流到达混合器时，混合器会将这三路流混合成一路流发出去，它会把这三路流的 SSRC 记录下来，形成一个列表，叫 CSRC 表，在发送的混合 RTP 流中，<strong>SSRC 域填充的字段是混合器本身的 SSRC4</strong>，<strong>而 CSRC 字段则会根据该包的负载的源来填入</strong>。</p>
<p>例如当前的 RTP 包的负载是来自 SSRC1 的，那么在当前 RTP 包的 CSRC 字段填入 SSRC1。这样接收者就可以根据 CSRC 来区分不同的信源；一般的，混合的 RTP 流中，每隔一段时间，就会有一个 RTP 报文包含了完整的 CSRC 表。例如在发送混合流时的第一个 RTP 包，它的 CSRC 域把 CSRC 表都填入，此时该包的负载可能是无意义或者并不是媒体流；此后的 RTP 报文中则根据负载的来源来填入 CSRC 域。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="RTP-固定头"><a href="#RTP-固定头" class="headerlink" title="RTP 固定头"></a>RTP 固定头</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RTP版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_VERSION 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RTP固定 header的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_FIXED_HEADER 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rtp_header_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> v:<span class="number">2</span>;       <span class="comment">/* protocol version */</span></span><br><span class="line">    <span class="type">uint32_t</span> p:<span class="number">1</span>;       <span class="comment">/* padding flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> x:<span class="number">1</span>;       <span class="comment">/* header extension flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> cc:<span class="number">4</span>;      <span class="comment">/* CSRC count */</span></span><br><span class="line">    <span class="type">uint32_t</span> m:<span class="number">1</span>;       <span class="comment">/* marker bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> pt:<span class="number">7</span>;      <span class="comment">/* payload type */</span></span><br><span class="line">    <span class="type">uint32_t</span> seq:<span class="number">16</span>;    <span class="comment">/* sequence number */</span></span><br><span class="line">    <span class="type">uint32_t</span> timestamp; <span class="comment">/* timestamp */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssrc;      <span class="comment">/* synchronization source */</span></span><br><span class="line">&#125; <span class="type">rtp_header_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装这个RTP 包括 header + [csrc/extension] + payload</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtp_packet_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rtp_header_t</span> rtp;</span><br><span class="line">    <span class="type">uint32_t</span> csrc[<span class="number">16</span>];      <span class="comment">// 最多16个csrc</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* extension;  <span class="comment">// extension(valid only if rtp.x = 1)</span></span><br><span class="line">    <span class="type">uint16_t</span> extlen;        <span class="comment">// extension length in bytes</span></span><br><span class="line">    <span class="type">uint16_t</span> reserved;      <span class="comment">// extension reserved</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* payload;    <span class="comment">// rtp payload</span></span><br><span class="line">    <span class="type">int</span> payloadlen;         <span class="comment">// payload length in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_V(v)    ((v &gt;&gt; 30) &amp; 0x03)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_P(v)    ((v &gt;&gt; 29) &amp; 0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_X(v)    ((v &gt;&gt; 28) &amp; 0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_CC(v)   ((v &gt;&gt; 24) &amp;&amp; 0x0F)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_M(v)    ((v &gt;&gt; 23) &amp;&amp; 0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_PT(v)   ((v &gt;&gt; 16) &amp;&amp; 0x7F)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTP_SEQ(v)  ((v &gt;&gt; 00) &amp;&amp; 0xFFFF)</span></span><br></pre></td></tr></table></figure>

<h2 id="RTP-序列化和反序列化"><a href="#RTP-序列化和反序列化" class="headerlink" title="RTP 序列化和反序列化"></a>RTP 序列化和反序列化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> nbo_r16 rtp_read_uint16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nbo_r32 rtp_read_uint32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nbo_w16 rtp_write_uint16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nbo_w32 rtp_write_uint32</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">rtp_read_uint16</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">uint16_t</span>)ptr[<span class="number">0</span>]) &lt;&lt; <span class="number">8</span>) | ptr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">rtp_read_uint32</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">uint32_t</span>)ptr[<span class="number">0</span>]) &lt;&lt; <span class="number">24</span>) | (((<span class="type">uint32_t</span>)ptr[<span class="number">1</span>]) &lt;&lt; <span class="number">16</span>) | (((<span class="type">uint32_t</span>)ptr[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) | ptr[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rtp_write_uint16</span><span class="params">(<span class="type">uint8_t</span>* ptr, <span class="type">uint16_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(val &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    ptr[<span class="number">1</span>] = (<span class="type">uint8_t</span>)val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rtp_write_uint32</span><span class="params">(<span class="type">uint8_t</span>* ptr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(val &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    ptr[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(val &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    ptr[<span class="number">2</span>] = (<span class="type">uint8_t</span>)(val &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    ptr[<span class="number">3</span>] = (<span class="type">uint8_t</span>)val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">nbo_write_rtp_header</span><span class="params">(<span class="type">uint8_t</span> *ptr, <span class="type">const</span> <span class="type">rtp_header_t</span> *header)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr[<span class="number">0</span>] = (<span class="type">uint8_t</span>)((header-&gt;v &lt;&lt; <span class="number">6</span>) | (header-&gt;p &lt;&lt; <span class="number">5</span>) | (header-&gt;x &lt;&lt; <span class="number">4</span>) | header-&gt;cc);</span><br><span class="line">    ptr[<span class="number">1</span>] = (<span class="type">uint8_t</span>)((header-&gt;m &lt;&lt; <span class="number">7</span>) | header-&gt;pt);</span><br><span class="line">    ptr[<span class="number">2</span>] = (<span class="type">uint8_t</span>)(header-&gt;seq &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    ptr[<span class="number">3</span>] = (<span class="type">uint8_t</span>)(header-&gt;seq &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">    nbo_w32(ptr+<span class="number">4</span>, header-&gt;timestamp);</span><br><span class="line">    nbo_w32(ptr+<span class="number">8</span>, header-&gt;ssrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rtp_packet_deserialize</span><span class="params">(<span class="keyword">struct</span> <span class="type">rtp_packet_t</span> *pkt, <span class="type">const</span> <span class="type">void</span>* data, <span class="type">int</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i, v;</span><br><span class="line">    <span class="type">int</span> hdrlen;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes &lt; RTP_FIXED_HEADER) <span class="comment">// RFC3550 5.1 RTP Fixed Header Fields(p12)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ptr = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)data;</span><br><span class="line">    <span class="built_in">memset</span>(pkt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">rtp_packet_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pkt header</span></span><br><span class="line">    v = nbo_r32(ptr);</span><br><span class="line">    pkt-&gt;rtp.v = RTP_V(v);</span><br><span class="line">    pkt-&gt;rtp.p = RTP_P(v);</span><br><span class="line">    pkt-&gt;rtp.x = RTP_X(v);</span><br><span class="line">    pkt-&gt;rtp.cc = RTP_CC(v);</span><br><span class="line">    pkt-&gt;rtp.m = RTP_M(v);</span><br><span class="line">    pkt-&gt;rtp.pt = RTP_PT(v);</span><br><span class="line">    pkt-&gt;rtp.seq = RTP_SEQ(v);</span><br><span class="line">    pkt-&gt;rtp.timestamp = nbo_r32(ptr + <span class="number">4</span>);</span><br><span class="line">    pkt-&gt;rtp.ssrc = nbo_r32(ptr + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    hdrlen = RTP_FIXED_HEADER + pkt-&gt;rtp.cc * <span class="number">4</span>;    <span class="comment">// 解析带csrc时的总长度</span></span><br><span class="line">    <span class="keyword">if</span> (RTP_VERSION != pkt-&gt;rtp.v || bytes &lt; hdrlen + (pkt-&gt;rtp.x ? <span class="number">4</span> : <span class="number">0</span>) + (pkt-&gt;rtp.p ? <span class="number">1</span> : <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pkt contributing source</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pkt-&gt;rtp.cc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pkt-&gt;csrc[i] = nbo_r32(ptr + <span class="number">12</span> + i * <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(bytes &gt;= hdrlen);</span><br><span class="line">    pkt-&gt;payload = (<span class="type">uint8_t</span>*)ptr + hdrlen;      <span class="comment">// 跳过头部 拿到payload</span></span><br><span class="line">    pkt-&gt;payloadlen = bytes - hdrlen;           <span class="comment">// payload长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pkt header extension</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == pkt-&gt;rtp.x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> *rtpext = ptr + hdrlen;</span><br><span class="line">        assert(pkt-&gt;payloadlen &gt;= <span class="number">4</span>);</span><br><span class="line">        pkt-&gt;extension = rtpext + <span class="number">4</span>;</span><br><span class="line">        pkt-&gt;reserved = nbo_r16(rtpext);</span><br><span class="line">        pkt-&gt;extlen = nbo_r16(rtpext + <span class="number">2</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;extlen + <span class="number">4</span> &gt; pkt-&gt;payloadlen)</span><br><span class="line">        &#123;</span><br><span class="line">            assert(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pkt-&gt;payload = rtpext + pkt-&gt;extlen + <span class="number">4</span>;</span><br><span class="line">            pkt-&gt;payloadlen -= pkt-&gt;extlen + <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// padding</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == pkt-&gt;rtp.p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> padding = ptr[bytes - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;payloadlen &lt; padding)</span><br><span class="line">        &#123;</span><br><span class="line">            assert(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pkt-&gt;payloadlen -= padding;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rtp_packet_serialize_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">rtp_packet_t</span> *pkt, <span class="type">void</span>* data, <span class="type">int</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hdrlen;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">    <span class="type">uint8_t</span>* ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RTP_VERSION != pkt-&gt;rtp.v || <span class="number">0</span> != (pkt-&gt;extlen % <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(<span class="number">0</span>); <span class="comment">// RTP version field must equal 2 (p66)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RFC3550 5.1 RTP Fixed Header Fields(p12)</span></span><br><span class="line">    hdrlen = RTP_FIXED_HEADER + pkt-&gt;rtp.cc * <span class="number">4</span> + (pkt-&gt;rtp.x ? <span class="number">4</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes &lt; hdrlen + pkt-&gt;extlen)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">uint8_t</span> *)data;</span><br><span class="line">    nbo_write_rtp_header(ptr, &amp;pkt-&gt;rtp);</span><br><span class="line">    ptr += RTP_FIXED_HEADER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pkt contributing source</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pkt-&gt;rtp.cc; i++, ptr += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nbo_w32(ptr, pkt-&gt;csrc[i]);     <span class="comment">// csrc列表封装到头部</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pkt header extension</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == pkt-&gt;rtp.x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 5.3.1 RTP Header Extension</span></span><br><span class="line">        assert(<span class="number">0</span> == (pkt-&gt;extlen % <span class="number">4</span>));</span><br><span class="line">        nbo_w16(ptr, pkt-&gt;reserved);</span><br><span class="line">        nbo_w16(ptr + <span class="number">2</span>, pkt-&gt;extlen / <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr + <span class="number">4</span>, pkt-&gt;extension, pkt-&gt;extlen);   <span class="comment">// extension封装到头部</span></span><br><span class="line">        ptr += pkt-&gt;extlen + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hdrlen + pkt-&gt;extlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rtp_packet_serialize</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">rtp_packet_t</span> *pkt, <span class="type">void</span>* data, <span class="type">int</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    hdrlen = rtp_packet_serialize_header(pkt, data, bytes);</span><br><span class="line">    <span class="keyword">if</span> (hdrlen &lt; RTP_FIXED_HEADER || hdrlen + pkt-&gt;payloadlen &gt; bytes)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">uint8_t</span>*)data) + hdrlen, pkt-&gt;payload, pkt-&gt;payloadlen);</span><br><span class="line">    <span class="keyword">return</span> hdrlen + pkt-&gt;payloadlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/557859851?utm_id=0">https://zhuanlan.zhihu.com/p/557859851?utm_id=0</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SimpleForest/article/details/129894415">https://blog.csdn.net/SimpleForest/article/details/129894415</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">RTMP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-17 14:59:55" itemprop="dateCreated datePublished" datetime="2023-09-17T14:59:55+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:38:19" itemprop="dateModified" datetime="2023-12-30T22:38:19+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39399492/article/details/128069969">https://blog.csdn.net/weixin_39399492/article/details/128069969</a></p>
<h1 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h1><ul>
<li><p>RTMP官方文档：<a target="_blank" rel="noopener" href="https://rtmp.veriskope.com/pdf/rtmp_specification_1.0.pdf">https://rtmp.veriskope.com/pdf/rtmp_specification_1.0.pdf</a></p>
</li>
<li><p>RTMP协议是Real Time Message Protocol（实时信息传输协议）的缩写。它是由Adobe公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题。</p>
</li>
<li><p>RTMP的三个分支：</p>
<ul>
<li>第一种是工作在<strong>TCP协议上</strong>的明文传输，它使用的<strong>端口是1935</strong>。</li>
<li>第二种是RTMPT，RTMPT被封装在HTTP请求之中，可以穿越防火墙进行传输。</li>
<li>第三种是RTMPS，它也是封装在HTTP之中，不过与RTMPT不同的是，它使用HTTPS安全连接，可以保证传输的安全。</li>
</ul>
</li>
<li><p>RTMP协议是要靠底层可靠的传输层协议（通常是TCP）来保证信息传输的可靠性的，默认使用端口1935。</p>
<ul>
<li>在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接。</li>
<li>RTMP Connection成功后会传输一些控制信息，如CreateStream命令会创建一个Stream链接，用于传输具体的音视频数据和控制这些信息传输的命令信息。</li>
</ul>
</li>
<li><p>RTMP协议中<strong>基本的数据单元称为消息</strong>（Message），即封装、解封装都是以Message为单位进行操作。</p>
</li>
<li><p>当RTMP协议在互联网中传输数据的时候，为了更好地实现多路复用、分包和信息的公平性，<strong>发送端会把Message划分为带有Message ID的Chunk</strong>，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据chunk中包含的data的长度，message id和message的长度把chunk<strong>还原成完整的Message</strong>，从而实现信息的收发。</p>
</li>
<li><p>多路复用，RTMP可以将来自不同视频流的切片（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=chunk&spm=1001.2101.3001.7020">chunk</a>）在单个连接上传输，这种方法被称为“多路复用”。</p>
</li>
</ul>
<h1 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h1><ul>
<li>一个 RTMP 连接以握手（Handshake）开始。先进行TCP握手后再进行RTMP握手。RTMP 握手由三个固定长度的块组成，有<strong>简单握手</strong>和<strong>复杂握手</strong>两种方式，<strong>两种握手方式信息流转的过程是相同的</strong>，<strong>只是消息中携带的信息不同</strong>。</li>
<li><strong>握手实质上起到的是验证的作用</strong>，其中一项是会校验服务器，客户端的rtmp版本，如果版本兼容则可以收发数据，如果版本不兼容则说明不能收发数据，则握手会失败。</li>
<li>rtmp握手成功之后才会有rtmp header、rtmp body出现。握手的过程中不会有这些标识出现，因为此时rtmp还没有建立链接。</li>
<li>无论推流（直播）还是拉流（观看），都是客户端向服务端发起握手请求。第一条握手消息是客户端发送的。</li>
<li>客户端向服务端按序发送C0，C1，C2（按序）3个chunk，服务端向客户端按序发送S0，S1，S2（按序）3个chunk，然后才能进行有效信息的传输。RTMP协议并没有规定这6个Message的具体传输顺序，但需要保证以下几点：（简单握手和复杂握手均是如此）：<ul>
<li>客户端要等收到S1之后才能发送C2</li>
<li>客户端要等收到S2之后才能发送其他信息（控制信息和真实音视频等数据）</li>
<li>服务端要等到收到C0之后发送S1</li>
<li>服务端必须等到收到C1之后才能发送S2</li>
<li>服务端必须等到收到C2之后才能发送其他信息（控制信息和真实音视频等数据）</li>
</ul>
</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP握手.png" alt="RTMP握手" style="zoom:50%;">

<p>理论上来讲只要满足以上条件，如何安排6个Message的顺序都是可以的，但实际实现中为了在保证握手的身份验证功能的基础上尽量减少通信的次数，一般的发送顺序是这样的，这一点可以通过wireshark抓ffmpeg推流包进行验证：（简单握手和复杂握手均是如此）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">｜client｜Server ｜</span><br><span class="line">｜－－－C0 + C1－－－&gt;  |</span><br><span class="line">｜&lt;－－S0 + S1 + S2－－｜</span><br><span class="line">｜－－－－ C2 －－－－&gt;｜</span><br></pre></td></tr></table></figure>

<ul>
<li>简单握手中<strong>S2是C1的复制</strong>，<strong>C2是S1的复制</strong>。</li>
</ul>
<h2 id="简单握手"><a href="#简单握手" class="headerlink" title="简单握手"></a>简单握手</h2><p><strong>C0和S0</strong></p>
<p>C0和S0包都是一个单一的8位字节，以一个单独的8位整型域进行处理：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>version</td>
<td>8 bytes</td>
<td>在 C0中，这一字段指示出客户端要求的 RTMP 版本号。在 S0 中，这一字段指示出服务端选择的 RTMP 版本号。</td>
</tr>
</tbody></table>
<ul>
<li><p>版本号基本都是3。0、1、2 这三个值是由早期其他产品使用的，是废弃值。</p>
</li>
<li><p>4 - 31 被保留为RTMP 协议的未来实现版本使用。</p>
</li>
<li><p>32 - 255 不允许使用（以区分开 RTMP 和其他常以一个可打印字符开始的文本协议）。</p>
</li>
<li><p>无法识别客户端所请求版本号的服务器应该以版本 3 响应，（收到响应的）客户端可以选择降低到版本 3，或者放弃握手。</p>
</li>
</ul>
<p><strong>C1和S1</strong></p>
<p>C1 和 S1 数据包的长度都是 1536 字节。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>这个字段包含一个 timestamp，用于本终端发送的所有后续块的时间起点。这个值可以是 0。</td>
</tr>
<tr>
<td>zero</td>
<td>4 bytes</td>
<td>这个字段必须都是 0。如果不是0，代表要使用复杂握手。</td>
</tr>
<tr>
<td>random</td>
<td>1528 bytes</td>
<td>这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手，这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护，也不需要动态值。</td>
</tr>
</tbody></table>
<p><strong>C2和S2</strong></p>
<p>C2 和 S2 数据包长度都是 1536 个节，基本就是 S1 和 C1 的副本。S2是C1的复制。 C2是S1的复制。分布如下：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的timestamp。</td>
</tr>
<tr>
<td>time2</td>
<td>4 bytes</td>
<td>这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</td>
</tr>
<tr>
<td>random</td>
<td>1528 bytes</td>
<td>这个字段必须包含终端发的 S1 (给 C2) 或者 S2 (给 C1)的随机数。</td>
</tr>
</tbody></table>
<h2 id="复杂握手"><a href="#复杂握手" class="headerlink" title="复杂握手"></a>复杂握手</h2><ul>
<li>相对于简单握手，复杂握手主要是增加了更严格的验证。 主要是<strong>将简单握手中1528Bytes随机数的部分平均分成两部分</strong>， 一部分764Bytes存储public key（公共密钥，32字节），另一部分 764Bytes存储digest（密文，32字节）。</li>
<li>复杂握手还有一个明显的特征就是: C1、S1的version部分（<strong>简单握手的zero字段</strong>）不为0， 服务端可根据这个来判断是否简单握手或复杂握手。</li>
</ul>
<p><strong>C0和S0</strong></p>
<p>C0和S0包都是一个单一的8位字节，以一个单独的8位整型域进行处理：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>version</td>
<td>8 bytes</td>
<td>说明是明文还是密文。如果使用的是明文（0X03），同时代表当前使用的rtmp协议的版本号。如果是密文，该位为0x06</td>
</tr>
</tbody></table>
<p><strong>C1和S1</strong></p>
<p>和简单握手相比，主要是将简单握手中random（1528Bytes）的部分平均分成两部分， 一部分764Bytes存储public key（公共密钥，32字节），另一部分 764Bytes存储digest（密文，32字节）。以此来增加更加严格的验证。在不同的包里，<strong>key和diest顺序可能会颠倒</strong>，比如nginx-rtmp。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>说明是明文还是密文。如果使用的是明文（0X03），同时代表当前使用的rtmp协议的版本号。如果是密文，该位为0x06</td>
</tr>
<tr>
<td>version</td>
<td>4 bytes</td>
<td>非0值，如果是0则表示简单握手。</td>
</tr>
<tr>
<td>key</td>
<td>764 bytes</td>
<td>random-data：长度由这个字段的最后4个byte决定，即761 - 764<br>key-data：128个字节。Key字段对应C1和S1有不同的算法。发送端（C1）中的Key应该是随机的，接收端（S1）的key需要按照发送端的key去计算然后返回给发送端。<br>random-data：（764 - offset - 128 - 4）个字节<br>   key_offset：4字节, 最后4字节定义了key的offset（相对于KeyBlock开头而言，相当于第一个random_data的长度）</td>
</tr>
<tr>
<td>digest</td>
<td>764 bytes</td>
<td>offset：4字节, 开头4字节定义了digest的offset<br>random-data：长度由这个字段起始的4个byte决定<br>digest-data：<strong>32个字节</strong><br>random-data：（764 - 4 - offset - 32）个字节</td>
</tr>
</tbody></table>
<p><strong>C2和S2</strong></p>
<p>C2、S2就是把digest放到最后那32字节上，主要是用来对C1、S1的验证。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的timestamp。</td>
</tr>
<tr>
<td>time2</td>
<td>4 bytes</td>
<td>这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</td>
</tr>
<tr>
<td>random</td>
<td>1504 bytes</td>
<td>random-data：1504字节。</td>
</tr>
<tr>
<td>digest</td>
<td>32 bytes</td>
<td>digest-data：32个字节。</td>
</tr>
</tbody></table>
<h1 id="RTMP消息格式"><a href="#RTMP消息格式" class="headerlink" title="RTMP消息格式"></a>RTMP消息格式</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><ul>
<li>消息（Message）是RTMP协议中<strong>基本的数据单元</strong>。由<strong>Message Header和Message Payload</strong>（可以理解成message body）组成。</li>
<li>对于<strong>音视频数据而言每一个message就是一帧数据</strong>。对于flv的tag而言，就是对应rtmp每个message，<strong>一个tag就是一个message</strong>，是一一对应的关系；相当于每一个tag都封装成一个message。message payload的数据格式和tag data的数据格式是相同的，message header和tag header的格式不同。</li>
<li>多路复用，RTMP可以将来自不同视频流的切片（chunk）在单个连接上传输，这种方法被称为“多路复用”，不同的流就用不同的Message Stream Id区分。</li>
<li>Message Header格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>3 bytes</td>
<td>Message Payload（消息负载）的长度，不包含Message Header。</td>
</tr>
<tr>
<td>Timestamp</td>
<td>4 bytes</td>
<td>时间戳（既是pts也是dts，因为直播场景中没有B帧，所以pts&#x3D;dts）。</td>
</tr>
<tr>
<td>Message Type Id</td>
<td>1 bytes</td>
<td>消息类型，主要包括协议控制消息、音视频消息、命令消息等。</td>
</tr>
<tr>
<td>Message Stream Id</td>
<td>3 bytes</td>
<td>消息流ID可以是任意值。不同的message可以有相同的值。复用到同一块流上的不同消息流基于它们的消息流ID解复用。</td>
</tr>
</tbody></table>
<ul>
<li>Message Payload格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>—</td>
<td>n bytes</td>
<td>是消息中包含的实际数据，消息类型不同payload大小也不同。例如，它可以是一些音频样本或压缩视频数据或Metadata等。</td>
</tr>
</tbody></table>
<ul>
<li><strong>这里注意RTMP消息的头（RTMP Message Header，不是chunk头中的 Message Header，两个不是同一个东西）有自己的统一格式，当然这部分也是会被切割到 Chunk 里传输的，不过，因为实际意义和 Chunk Header 内容重复，当前主流流媒体服务器在发送RTMP消息时，chunk data中不包含RTMP Message Header，只要双方约定好即可。</strong></li>
</ul>
<h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><ul>
<li><p>RTMP以Message为基本单位，通过把Message拆分成Chunk来进行网络发送。<strong>chunk data默认是128字节</strong>。<strong>chunk是RTMP最小的传输单元</strong>。目的是：防止一个大的数据包传输时间过长，阻塞其它数据包的传输。chunk合成message：接收端将接收到chunk的chunk data的大小加和，如果等于message payload（通过chunk-&gt;message header-&gt;message length获取）的则认为是同一个message。</p>
</li>
<li><p>Chunk在传输时：<strong>同一个Message产生的多个Chunk只会串行发送</strong>。先发送的Chunk一定先到达。<strong>不同Message产生的Chunk可以并行发送</strong>。<strong>并行发送的Chunk复用了一条TCP链接</strong>。</p>
</li>
<li><p>Chunk Header格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Basic Header</td>
<td>1-3 bytes</td>
<td>包含fmt（chunk type）和chunk stream id（csid），其中fmt决定了chunk的类型及message header的长度，占2 bit，而Basic header的长度取决于csid的数值大小，最少占1 byte。</td>
</tr>
<tr>
<td>Message Header</td>
<td>0，3，7 or 11 bytes</td>
<td>要发送的实际信息（可能是完整的，也可能是一部分）的描述信息。<br>长度取决于Basic Header中的chunk type，有Type 0，1，2，3类型的header</td>
</tr>
<tr>
<td>Extended Timestamp</td>
<td>0 or 4 bytes</td>
<td>扩展时间戳（0 bytes时表示此字段不存在）。</td>
</tr>
</tbody></table>
<ul>
<li>Chunk Data格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>—</td>
<td>n bytes</td>
<td>是消息中包含的实际数据，消息类型不同data大小也不同。</td>
</tr>
</tbody></table>
<h3 id="Basic-Header"><a href="#Basic-Header" class="headerlink" title="Basic Header"></a>Basic Header</h3><ul>
<li>Basic Header格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>fmt</td>
<td>2 bits</td>
<td>表示chunk type，取值[0, 3]，即chunk共有4种类型</td>
</tr>
<tr>
<td>csid(chunk stream id)</td>
<td>6，14 or 22 bits</td>
<td>csid范围是3 ~ 65599，0 ~ 2为协议保留用作特殊信息；<br>通常控制流csid为2，命令流为3，开发中发现音视频流csid可自定义，如音频流4，视频流6。<br>上文提到Basic Header大小为1-3 bytes，由于fmt域占2bits，所以CSID长度分别是6 bits、14 bits或22 bits</td>
</tr>
</tbody></table>
<ul>
<li><p>Basic Header为1bytes时：csid为6bits，取值在[3~63]。</p>
</li>
<li><p>Basic Header为2bytes时：第一个字节除了fmt外，其余6位表示数字0，csid范围是[64~319]，即最大为(2^8 - 1) + 64 &#x3D; 319。</p>
</li>
<li><p>Basic Header为3bytes时：第一个字节除了fmt外，其余6位表示数字1，csid范围是[64~65599]，最大值为 (2^16 - 1) + 64 &#x3D; 65599。</p>
</li>
</ul>
<h3 id="Message-Header"><a href="#Message-Header" class="headerlink" title="Message Header"></a>Message Header</h3><ul>
<li><p><strong>Message Header的格式和长度取决于Basic Header的chunk type</strong>，即fmt，fmt取值[0-3]，所以共有4种不同的chunk格式，目的是减少重复数据发送，提高 chunk data的占比。同时也有4种不同的Message Header。</p>
</li>
<li><p><strong>chunk type &#x3D; 0</strong>（fmt &#x3D; 0）：Message Header共11字节，<strong>此类型必须在块流开始时使用</strong>，当<strong>流时间戳</strong>向后（例如，回退播放）时也要使用此格式。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp</td>
<td>3 bytes</td>
<td>时间戳，如果值大于等于16777215（0xFFFFFF），该字段必须等于16777215，然后转存到4字节的Extended Timstamp字段中。接收端判断是0xFFFFFF后会去Extended Timstamp解析时间戳。</td>
</tr>
<tr>
<td>message length</td>
<td>3 bytes</td>
<td>指的是message拆分之前message payload的长度（不包含header），而且如果被拆分成chunk，此字段填充拆分前message的body长度，而不是chunk的长度。</td>
</tr>
<tr>
<td>message type id</td>
<td>1 byte</td>
<td>消息类型，如8代表audio数据，9代表video，其它值可参考后文的消息类型。</td>
</tr>
<tr>
<td>message stream id</td>
<td>4 bytes</td>
<td>表示该chunk所在的流的ID。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=0.png" alt="chunk-type=0" style="zoom:50%;">

<ul>
<li><strong>chunk type &#x3D; 1</strong>（fmt &#x3D; 1）：Message Header共7字节，<strong>和前一个chunk共用message stream id</strong>（msid），因此省去了message stream id的4字节，表示此Chunk和上一次发的Chunk所在的流相同（不是相同的message），如果在发送端和对端有一个流连接的时候尽量采用这种格式。</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp delta</td>
<td>3 bytes</td>
<td>和上一个chunk的时间差。如果值大于等于16777215（0xFFFFFF），该字段必须等于16777215，然后转存到4字节的Extended Timstamp字段中。接收端判断是0xFFFFFF后会去Extended Timstamp解析时间戳。</td>
</tr>
<tr>
<td>message length</td>
<td>3 bytes</td>
<td>指的是message拆分之前message payload的长度（不包含header），而且如果被拆分成chunk，此字段填充拆分前message的body长度，而不是chunk的长度。</td>
</tr>
<tr>
<td>message type id</td>
<td>1 byte</td>
<td>消息类型，如8代表audio数据，9代表video，其它值可参考后文的消息类型。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=1.png" alt="chunk-type=1" style="zoom:50%;">

<ul>
<li><strong>chunk type &#x3D; 2</strong>（fmt &#x3D; 2）：Message Header共3字节，相对于 chunk type &#x3D; 1 格式又省去了message length的3个字节和message type id的1个字节，表示此 chunk和上一次发送的 chunk 的message length、message type id都相同。余下的这三个字节表示 timestamp delta，使用同type&#x3D;1。</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp delta</td>
<td>3 bytes</td>
<td>和上一个chunk的时间差。如果值大于等于16777215（0xFFFFFF），该字段必须等于16777215，然后转存到4字节的Extended Timstamp字段中。接收端判断是0xFFFFFF后会去Extended Timstamp解析时间戳。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=2.png" alt="chunk-type=2" style="zoom:50%;">

<ul>
<li><strong>chunk type &#x3D; 3</strong>（fmt &#x3D; 3）：Message Header共0字节，即此时chunk没有Message header。</li>
</ul>
<p>当它在type &#x3D; 0的chunk后面时，表示和前一个chunk的时间戳是相同的，也就是一个Message拆分成多个chunk时，后一个chunk和前一个chunk同属一个Message自然也就可以不用传Message header。</p>
<p>当它跟在type &#x3D; 1或type &#x3D; 2的chunk后面时，表示和前一个时间戳的差相同。如第一个chunk是type &#x3D; 0，timestamp &#x3D; 0，第二个chunk是type &#x3D; 2，timestamp delta &#x3D; 20，表示时间戳为0+20&#x3D;20，第三个chunk是type &#x3D; 3，则timestamp delta &#x3D; 20，表示时间戳为20+20&#x3D;40。</p>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=3.png" alt="chunk-type=3" style="zoom:50%;">

<h2 id="Message和Chunk之间关系"><a href="#Message和Chunk之间关系" class="headerlink" title="Message和Chunk之间关系"></a>Message和Chunk之间关系</h2><p>前文已经介绍了RTMP传输的单位不是massage，而是把massage拆分成一个或多个chunk来进行传输，可根据msg stream id判断是否属于同一个Massage，其拆分过程如下：</p>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk和message关系.png" alt="chunk和message关系" style="zoom:50%;">

<p><strong>这里采用通用的做法，RTMP Message Header不拆分到chunk data中，虽然规范上RTMP massage应该作为一个整体被拆分成chunk，但是由于RTMP massage header与chunk massage header信息重复，本着最小传输数据原则，一般做法是在chunk data中去掉此信息。</strong></p>
<h1 id="RTMP消息类型"><a href="#RTMP消息类型" class="headerlink" title="RTMP消息类型"></a>RTMP消息类型</h1><p>RTMP协议中有多种消息，用于数据传输和命令控制等操作，所有的消息都是封装成message，然后通过chunk来传输。</p>
<h2 id="协议控制消息"><a href="#协议控制消息" class="headerlink" title="协议控制消息"></a>协议控制消息</h2><p>在RTMP的chunk流会用一些特殊的值来代表协议的控制消息，属于RTMP chunk流协议层的消息，它们的<strong>Message Stream ID必须为0</strong>（代表控制流信息），<strong>CSID必须为2</strong>，Message Type ID可以为1，2，3，5，6，具体代表的消息会在下面依次说明。控制消息的接受端会忽略掉chunk中的时间戳，收到后立即生效。</p>
<h3 id="设置块大小"><a href="#设置块大小" class="headerlink" title="设置块大小"></a>设置块大小</h3><ul>
<li><p>Type ID: Set Chunk Size ，Message Type ID &#x3D; 1。Message Type ID 就是chunk中Type ID，也就是0x01。</p>
</li>
<li><p>RTMP消息需要以chunk size为单位封装成chunk包发送，因此接收端需要根据chunk size才能正确解包，所以<strong>双端都要记录对端的封包单位chunk size</strong>，默认128 bytes。</p>
</li>
<li><p>通信过程中可发送此消息通知对端更新其记录的本端的chunk size。比如client想发送131 bytes的音频数据（此时chunk size为128 bytes，不更新chunk size的话需要拆成两个chunk），此时client可通知对端，这边client的chunk size更新为131 bytes，之后发送一个data为131 bytes的chunk即可，<strong>server端收到Set Chunk Size之后更新chunk size即可正确解析之后到来的chunk</strong>。</p>
</li>
<li><p><strong>双端的chunk size各自独立维护，可以不同。</strong>例如client可以发送131 bytes的chunk，server也按照131 bytes解析，server发送128 bytes的chunk，client也按照128 bytes解析。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>第一个bit</td>
<td>1 bit</td>
<td>恒为0</td>
</tr>
<tr>
<td>chunk size</td>
<td>31 bit</td>
<td>可表示[1, 0x7FFFFFFF]区间，但是由于chunk size要小于Message的length，<br>而Message length字段用3个字节存储，最大值为0xFFFFFF，所以实际可取值区间为[1, 0xFFFFFF]</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP设置块大小.png" alt="RTMP设置块大小" style="zoom:50%;">

<h3 id="应答窗口大小"><a href="#应答窗口大小" class="headerlink" title="应答窗口大小"></a>应答窗口大小</h3><ul>
<li><p>Type ID: Window Acknowledgement Size，Message Type ID &#x3D; 5。</p>
</li>
<li><p>规定接收端接收多少数据后需要发送一个应答消息。发送端可以发送此消息通知对端更新窗口大小，一般在音视频数据之前发送。并且<strong>双端的window size共同维护，保持相同</strong>。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>acknowledgement window size</td>
<td>32 bits</td>
<td>接收端接收多少数据后需要发送一个应答消息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP应答窗口大小.png" alt="RTMP应答窗口大小" style="zoom:50%;">

<h3 id="应答消息"><a href="#应答消息" class="headerlink" title="应答消息"></a>应答消息</h3><ul>
<li><p>Type ID: Acknowledgement，Message Type ID &#x3D; 3。</p>
</li>
<li><p>当收到对端消息字节数等于接收窗口大小时，接收端要回复一个应答消息（相当于ack）告知对端可以继续发送数据，<strong>发送方在收到应答消息之前不会再继续发送消息</strong>。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>chunk stream id</td>
<td>32 bits</td>
<td>截止目前接收到的数据总和，以字节为单位。</td>
</tr>
</tbody></table>
<h3 id="设置流带宽"><a href="#设置流带宽" class="headerlink" title="设置流带宽"></a>设置流带宽</h3><ul>
<li>Type ID: Set Peer Bandwidth，Message Type ID &#x3D; 6。</li>
<li>客户端或服务器发送此消息以限制其对等端的输出带宽。</li>
<li>message payload格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>acknowledgement window size</td>
<td>32 bits</td>
<td>设置对端出口带宽</td>
</tr>
<tr>
<td>limit type</td>
<td>8 bits</td>
<td>limit type &#x3D; 0：硬限制，立即更新出口带宽大小<br>limit type &#x3D; 1：软限制，可以更新出口带宽大小，也可以保留原值，但是原值一定要小于期望更新的大小<br>limit type &#x3D; 2：动态限制，如果上一次为硬限制，此消息被视为硬限制，否则忽略此消息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP设置流带宽.png" alt="RTMP设置流带宽" style="zoom:50%;">

<h3 id="中断消息"><a href="#中断消息" class="headerlink" title="中断消息"></a>中断消息</h3><ul>
<li><p>Type ID: Abort Message，Message Type ID &#x3D; 2。</p>
</li>
<li><p>发送数据过程中，发送端可发送Abort消息通知接收端丢弃当前未接收完的Message及忽略之后的消息。先前已收到的chunk将被全部被抛弃，接收端根据Abort消息中的chunk stream id（csid）可丢弃对应chunk流中之后的所有数据。比如在发送端需要关闭时，发送此消息通知对端之后的数据可以不用处理了。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>chunk stream id</td>
<td>32 bits</td>
<td>此字段保存要丢弃其当前消息的块流ID。</td>
</tr>
</tbody></table>
<h2 id="命令消息"><a href="#命令消息" class="headerlink" title="命令消息"></a>命令消息</h2><ul>
<li><p>命令消息（Command Messages）是用于 C-S 进行直接交互应答的一类消息。一般情况下，命令消息的发送对端，<strong>是需要对端进行应答信号反馈的</strong>。需要AMF编码，AMF0编码时Message Type ID &#x3D; 20，使用AMF3编码时Message Type ID &#x3D; 17，CSID通常为3。</p>
</li>
<li><p>命令类型的消息包含<strong>命令名称</strong>、<strong>事务ID</strong>和<strong>相关参数</strong>。如client端发送connect命令时需要包含要连接的应用名称作为参数，然后server端回复消息时带上收到的transaction ID表示对此条消息的回应。回复命令有<code>_result</code>，<code>_error</code>，或者其他如verifyClient，contactExternalServer的方法名。</p>
</li>
<li><p>发送命令消息的对象有两种分别是NetConnection和NetStream。</p>
<ul>
<li>NetConnection：表示双端的上层连接，服务器和客户端之间进行网络连接的一种高级表示形式。</li>
<li>NetStream：表示流信息的传输通道如音频流、视频流，以及控制流信息的状态，如Play播放流，Pause暂停。</li>
</ul>
</li>
</ul>
<h3 id="网络连接命令"><a href="#网络连接命令" class="headerlink" title="网络连接命令"></a>网络连接命令</h3><ul>
<li>表示双端的上层连接，服务器和客户端之间进行网络连接的一种高级表示形式。</li>
<li>网络连接允许使用：连接（connect）、调用（call）、创建流（createStream），每一种消息都有应答消息。</li>
<li>应答消息中的“Transaction ID”表明对哪个请求的应答。</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul>
<li><p>客户端向服务器发送connect命令，以请求连接到服务器<strong>应用程序实例</strong>（Application Instance）。不同的的Application Instance可根据功能进行区分，比如直播可以用live表示，点播可以用vod表示，测试环境可以用test表示，用户可自定义。例如：rtmp:&#x2F;&#x2F;192.127.0.1&#x2F;test&#x2F;16，可以表示test环境，16是对流的描述，用户可自定义。ip后面的内容可以用来标识流的内容。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>”connect”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为1</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数（具体内容可参考官方文档）</td>
</tr>
<tr>
<td>Optional User Arguments（额外的用户参数)</td>
<td>Object</td>
<td>用户自定义的额外信息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-connect请求消息.png" alt="RTMP-connect请求消息" style="zoom:50%;">

<ul>
<li>响应消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>”<code>_result</code>”或”<code>_err</code>“，表示响应是否为结果或者错误</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为1</td>
</tr>
<tr>
<td>Properties(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数（具体内容可参考官方文档）</td>
</tr>
<tr>
<td>Information（应答信息)</td>
<td>Object</td>
<td>描述应答的名称-值对，如“code”，“level”，“description”之类的内容</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-connect响应消息.png" alt="RTMP-connect响应消息" style="zoom:50%;">

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul>
<li>NetConnection对象的调用方法在接收端运行远程过程调用（RPC）。被调用的RPC名称作为参数传递给调用命令。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Procedure Name(程序名称)</td>
<td>String</td>
<td>指定调用对端的远程功能名称</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>事物ID，用来标记请求，如不需要也可以传0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数（具体内容可参考官方文档）</td>
</tr>
<tr>
<td>Optional User Arguments（额外的用户参数)</td>
<td>Object</td>
<td>用户自定义的额外信息</td>
</tr>
</tbody></table>
<ul>
<li>响应消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>RPC请求方定义的回应方法的名称</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>需要响应的RPC请求的事务ID，标识它属于哪个应答的</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>RPC需求的配置参数</td>
</tr>
<tr>
<td>Response（应答信息)</td>
<td>Object</td>
<td>被调用的RPC的返回结果</td>
</tr>
</tbody></table>
<h4 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h4><ul>
<li>客户端将此命令发送到服务器，以创建消息通信的逻辑通道。音频、视频和元数据的发布通过使用createStream命令创建的流通道执行。NetConnection是默认的通信信道，其流ID为0。协议和一些命令消息（包括createStream）使用默认的通信通道。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(程序名称)</td>
<td>String</td>
<td>“createstream”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>命令会话ID</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>如果存在任何命令信息，则设置此对象，否则设置为空类型。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-createStream请求消息.png" alt="RTMP-createStream请求消息" style="zoom:50%;">

<ul>
<li>响应消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>”<code>_result</code>”或”<code>_err</code>“，表示响应是否为结果或者错误</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>标识它属于哪个应答的</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>如果存在任何命令信息，则设置此对象，否则设置为空类型。</td>
</tr>
<tr>
<td>Stream ID（应答信息)</td>
<td>Number</td>
<td>stream id（用于唯一标识该Stream）或错误信息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-createStream响应消息.png" alt="RTMP-createStream响应消息" style="zoom:50%;">

<h3 id="网络流命令"><a href="#网络流命令" class="headerlink" title="网络流命令"></a>网络流命令</h3><ul>
<li>网络流命令是在数据信道建立完毕后（<strong>先有NetConnection，才有NetStream命令</strong>），用来对音视频数据流进行直接控制的命令类型。这些命令作用于当前信道对应数据的操控行为，都是客户端向服务端发送的命令，一个NetConnection对象可以有多个NetStream，进而支持多种数据。常见的命令如下：</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>play</td>
<td>播放</td>
</tr>
<tr>
<td>play2</td>
<td>播放2</td>
</tr>
<tr>
<td>deleteStream</td>
<td>删除流</td>
</tr>
<tr>
<td>closeStream</td>
<td>关闭流</td>
</tr>
<tr>
<td>receiveAudio</td>
<td>接收音频</td>
</tr>
<tr>
<td>receiveVideo</td>
<td>接收视频</td>
</tr>
<tr>
<td>publish</td>
<td>推流</td>
</tr>
<tr>
<td>seek</td>
<td>定位</td>
</tr>
<tr>
<td>pause</td>
<td>暂停</td>
</tr>
</tbody></table>
<ul>
<li>网络流命令的请求命令所对应的应答命令，被统一命名为 “<strong>onStatus</strong>” 以描述数据所处的状态发生变更，因此<strong>具有统一的格式</strong>（注意：<strong>不是所有的消息都有应答，而是有应答消息的都是如下格式</strong>）</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>onStatus</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>NULL</td>
</tr>
<tr>
<td>Info Object（应答信息)</td>
<td>Object</td>
<td>stream id或错误信息</td>
</tr>
</tbody></table>
<h4 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h4><ul>
<li><p>客户端发送此命令让服务器播放流。也可以多次使用此命令创建一个播放列表。如果你想创建一个在不同直播或录制流之间切换的动态播放列表，多次调用play并将reset字段设置为false。相反，如果你想立即播放指定的流，将reset字段设置为true。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“play”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Stream Name(流名称)</td>
<td>String</td>
<td>待播放流的名称和格式。<br> 如果要播放视频（FLV）文件，指定不带文件扩展名（比如，“sample”）的流名称。<br>如果要播放H.264&#x2F;AAC文件，你必须在流名称前加上mp4:的前缀，并且指定文件名后缀。比如，要播放文件sample.m4v，指定“mp4:sample.m4v”<br> 如果要回放MP3或者ID3标签，你必须要在流名称前加上mp3:的前缀。比如，“mp3:sample”</td>
</tr>
<tr>
<td>Start(开始时间)</td>
<td>String</td>
<td>一个可选的参数，指定开始播放的起开时间，单位是秒，默认值是-2。<br>Start &#x3D; -2，代表选取对应该流名称的直播流，即当前正在推送的流开始播放，如果对应该名称的直播流不存在，就选取该名称的流的录播版本，如果这也没有，<strong>当前播流端要等待直到对端开始该名称的流的直播</strong>。<br>Start &#x3D; -1，那么只会选取直播流进行播放，即使有录播流也不会播放；如果传值或者正数，就代表从该流的该时间点开始播放，<strong>如果流不存在的话就会自动播放播放列表中的下一个流</strong><br> Duration &gt;&#x3D; 0，一个在流名称字段指定的录播流会被播放，起始时间是Start字段指定的时间。如果找不到该记录流，<strong>播放列表的下一个条目会被播放</strong>。</td>
</tr>
<tr>
<td>Duration(时长)</td>
<td>String</td>
<td>一个可选的参数，指定回放时长，单位是秒，默认值是-1。<br>Duration &#x3D; -1，直播流被播放直到它不可用，或者录播流被播放直到结束。（如果你传递一个不同于-1的负数，它会把该值解析为-1）<br>Duration &#x3D; 0，它会播放录播流中Start字段指定开始时间的一帧。<br>Duration &gt; 0，如果你指定一个正数，它会播放Duration字段指定该段时间的直播流。之后，它能够播放Duration字段指定该段时间的录播流。（如果流在Duration字段指定的时间前结束，回放随着流的结束而结束）</td>
</tr>
<tr>
<td>Reset(重置)</td>
<td>Boolean</td>
<td>一个可选的布尔值，它指定是否清除之前的所有播放列表</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-play请求消息.png" alt="RTMP-play请求消息" style="zoom:50%;">

<h4 id="播放2"><a href="#播放2" class="headerlink" title="播放2"></a>播放2</h4><ul>
<li><p>play命令不同的是，play2命令可以将<strong>当前正在播放的流切换到同样数据但不同码率的流上</strong>，服务端会维护多种比特率的文件来供客户端使用play2命令来切换。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“play2”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Parameters(参数)</td>
<td>Object</td>
<td>AMF编码的Flash对象，包括了一些用于描述flash.net.NetstreamPlayOptions ActionScript obejct的参数</td>
</tr>
</tbody></table>
<h4 id="删除流"><a href="#删除流" class="headerlink" title="删除流"></a>删除流</h4><ul>
<li><p>NetStream在<strong>NetStream对象被销毁时发送deleteStream命令</strong>，用于客户端告知服务端本地的某个流对象已被删除，不需要再传输此路流。</p>
</li>
<li><p>删除流命令无应答消息。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“deleteStream”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Stream ID（流ID)</td>
<td>Number</td>
<td>本地已删除，不再需要服务器传输的流的ID</td>
</tr>
</tbody></table>
<h4 id="接收音频"><a href="#接收音频" class="headerlink" title="接收音频"></a>接收音频</h4><ul>
<li>客户端通知服务端是否要发送音频。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“receiveAudio”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Bool Flag(标识)</td>
<td>Boolean</td>
<td>Bool Flag &#x3D; true，表示发送音频，服务端就会准备接受音频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态<br> Bool Flag &#x3D; false，服务端不做响应</td>
</tr>
</tbody></table>
<h4 id="接收视频"><a href="#接收视频" class="headerlink" title="接收视频"></a>接收视频</h4><ul>
<li>客户端通知服务端是否要发送视频。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“receiveVideo”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Bool Flag(标识)</td>
<td>Boolean</td>
<td>Bool Flag &#x3D; true，表示发送音频，服务端就会准备接受音频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态<br> Bool Flag &#x3D; false，服务端不做响应</td>
</tr>
</tbody></table>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ul>
<li><p>客户端发送此消息，<strong>将命名流推送到服务器</strong>。其他客户端可以使用此流名来播放流，接收发布的音频，视频，以及其它数据消息。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“publish“</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>PublishingName(发布的流名称)</td>
<td>String</td>
<td>发布流的名称</td>
</tr>
<tr>
<td>PublishingType(发布类型)</td>
<td>String</td>
<td>有三种发布的类型：live, record 或 append<br>PublishingType &#x3D; record : 该流已被发布并且数据被记录到一个新的文件。该文件存储在服务器的一个包含服务器应用程序目录的子目录。如果文件已经存在，则它被覆盖<br>PublishingType &#x3D; append：流已经被发布，并且该数据被追加到一个文件。如果找不到文件，则创建它<br> PublishingType &#x3D; live：直播数据被发布，而没有记录到文件</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-publish请求消息.png" alt="RTMP-publish请求消息" style="zoom:50%;">

<ul>
<li>publish 的返回状态 NetStream.Publish.Start，这个消息不止由 onStatus 统一应答携带，也会由 onFCPublish 返回。</li>
</ul>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ul>
<li><p>定位（seek）到视频或音频的某个位置，以毫秒为单位。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“seek“</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>milliSeconds(毫秒)</td>
<td>Number</td>
<td>定位到该文件的xx毫秒处</td>
</tr>
</tbody></table>
<ul>
<li>当定位成功，服务器发送NetStream.Seek.Notify的状态消息。失败的时候，它返回一个_error的消息。</li>
</ul>
<h4 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h4><ul>
<li>客户端发送pause命令以告诉服务器暂停或者开始播放。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“pause“</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Pause&#x2F;Unpause Flag(暂停&#x2F;恢复播放)</td>
<td>Boolean</td>
<td>true，暂停<br>false，恢复播放</td>
</tr>
<tr>
<td>milliSeconds(毫秒)</td>
<td>Number</td>
<td>定位到该文件的xx毫秒处</td>
</tr>
</tbody></table>
<ul>
<li>pause 成功后，会有 ’code’ 为 NetStream.Pause.Notify 消息返回；unpause 成功后，会有 ’code’ 为 NetStream.Unpause.Notify 消息返回。</li>
</ul>
<h3 id="数据消息"><a href="#数据消息" class="headerlink" title="数据消息"></a>数据消息</h3><ul>
<li>传递一些元数据（MetaData，比如视频名，分辨率等等）或者用户自定义的一些消息。当信息使用AMF0编码时，Message Type ID＝18，AMF3编码时Message Type ID＝15。</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-数据消息.png" alt="RTMP-数据消息" style="zoom:50%;">

<h3 id="共享消息"><a href="#共享消息" class="headerlink" title="共享消息"></a>共享消息</h3><ul>
<li><p>共享对象是在多个客户端、实例等之间同步的Flash对象，Flash对象是由键值对组成的集合。每条消息可以包含多个事件。当信息使用AMF0编码时，Message Type ID＝19，AMF3编码时Message Type ID＝16。</p>
</li>
<li><p>消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Use(&#x3D;1)</td>
<td>客户端发送此事件通知服务器一个共享对象的创建</td>
</tr>
<tr>
<td>Release(&#x3D;2)</td>
<td>当在客户端删除共享对象时，客户端将此事件发送到服务器上</td>
</tr>
<tr>
<td>Request Change(&#x3D;3)</td>
<td>客户端发送此事件以请求更改与共享对象命名参数关联的值</td>
</tr>
<tr>
<td>Change(&#x3D;4)</td>
<td>服务器发送此事件通知除了正在发起请求之外的所有客户端命名参数值的变化</td>
</tr>
<tr>
<td>Success(&#x3D;5)</td>
<td>如果请求被受理，服务器发送此事件给正在请求的客户端，以响应RequestChange事件</td>
</tr>
<tr>
<td>SendMessage(&#x3D;6)</td>
<td>客户端将此事件发送到服务器以广播一个消息。在接收此事件时，服务器向所有客户端广播消息，包括该发送者</td>
</tr>
<tr>
<td>Status(&#x3D;7)</td>
<td>服务器发送此事件以通知客户端相关的错误状况</td>
</tr>
<tr>
<td>Clear(&#x3D;8)</td>
<td>服务器将此事件发送给客户端，以清除共享对象。服务器还发送此事件以响应客户端在连接时发送Use event</td>
</tr>
<tr>
<td>Remove(&#x3D;9)</td>
<td>服务器发送此事件让客户端删除一个slot</td>
</tr>
<tr>
<td>Request Remove(&#x3D;10)</td>
<td>客户端发送此事件让服务器删除一个slot</td>
</tr>
<tr>
<td>Use Success(&#x3D;11)</td>
<td>成功连接时，服务器将此事件发送给客户端8. 音频信息（Audio Message）</td>
</tr>
</tbody></table>
<h3 id="音视频信息"><a href="#音视频信息" class="headerlink" title="音视频信息"></a>音视频信息</h3><ul>
<li>每一个message就是一帧数据。对于flv的tag而言，就是对应rtmp每个message，一个tag就是一个message，是一一对应的关系；相当于每一个tag都封装成一个message。</li>
<li>RTMP 块流使用<strong>Message Type ID&#x3D;8 作为音频数据</strong>，flv的tag header-&gt;tag type也用8来表示音频。通常音频流的csid是4（也可以自定义），音频流的每一个chunk的csid都是相同的。</li>
<li>RTMP 块流使用<strong>Message Type ID&#x3D;9 作为视频数据</strong>，flv的tag header-&gt;tag type也用9来表示音频。通常视频流的csid是6（也可以自定义），视频流的每一个chunk的csid都是相同的。</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-音频消息.png" alt="RTMP-音频消息" style="zoom:50%;">



<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-视频消息.png" alt="RTMP-视频消息" style="zoom:50%;">

<h3 id="聚合消息"><a href="#聚合消息" class="headerlink" title="聚合消息"></a>聚合消息</h3><ul>
<li>聚合消息是包含一系列RTMP子消息的单个消息，Message Type ID＝22。</li>
<li>聚合消息的消息流ID覆盖聚合内部的子消息的消息流程ID；聚合消息和第一个子消息的时间戳之间的差异是用于将子消息的时间戳记重新规范化为流时间尺度的偏移量。偏移量被添加到每个子消息的时间戳，以达到标准化的流时间。第一个子消息的时间戳应与聚合消息的时间戳记相同，因此偏移量应为零；返回指针包含前一条消息的大小，包括其标头，它被包括以匹配FLV文件的格式，并用于反向搜索，类似于flv的previous tag header。</li>
<li>使用聚合消息有几个性能优势：<ul>
<li>区块流最多可以在一个区块内发送一条完整的消息。因此，增加块大小并使用聚合消息可以减少发送的块数。</li>
<li>子消息可以连续存储在内存中。当进行系统调用以在网络上发送数据时，效率更高。</li>
</ul>
</li>
<li>消息格式：</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-聚合消息.png" alt="RTMP-聚合消息" style="zoom:50%;">

<h3 id="用户控制消息"><a href="#用户控制消息" class="headerlink" title="用户控制消息"></a>用户控制消息</h3><ul>
<li><p>客户端或服务器发送此消息以通知对等方用户控制事件。</p>
</li>
<li><p>消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>StreamBegin(&#x3D;0)</td>
<td>服务器发送此事件通知客户端流成功创建，并可用于通信。默认情况下，在从客户端成功收到应用程序连接命令后，此事件以ID 0来发送<br>Event Data大小是4字节，表示开始运行的流的stream ID</td>
</tr>
<tr>
<td>StreamEOF(&#x3D;1)</td>
<td>服务器发送此事件通知客户端该流请求的数据回放结束。若不发出额外的命令，就没有更多的数据被发送了。客户端丢弃该流收到的消息<br>Event Data大小是4字节，代表播放已结束流的stream ID</td>
</tr>
<tr>
<td>StreamDry(&#x3D;2)</td>
<td>服务器发送此事件通知客户端，在流上没有更多的数据。如果服务器在一段时间内没有检测到任何的消息，它可以通知订阅的客户端流是结束的<br>Event Data大小是4字节，代表已结束流的stream ID</td>
</tr>
<tr>
<td>SetBufferLength(&#x3D;3)</td>
<td>客户端发送此事件通知服务器用于缓冲从流过来的任何数据的缓冲区大小（以毫秒为单位）。此事件在服务器开始处理流之前被发送<br>Event Data大小是8字节，前4字节是stream ID，后4字节是每毫秒缓冲区的长度</td>
</tr>
<tr>
<td>StreamIsRecorded (&#x3D;4)</td>
<td>服务器发送此事件来通知客户端，需要记录（录像）<br>Event Data大小是4字节，代表需要记录的流的stream ID</td>
</tr>
<tr>
<td>PingRequest(&#x3D;6)</td>
<td>服务器发送此事件来测试客户端是否是可到达的<br>Event Data大小是4字节，内容是时间戳，表示当服务器发出命令时，本地服务器的时间。客户收到PingRequest时响应PingResponse</td>
</tr>
<tr>
<td>PingResponse(&#x3D;7)</td>
<td>客户端向服务器发送此事件响应ping请求<br>Event Data大小是4字节，内容是收到PingRequest时时间戳</td>
</tr>
</tbody></table>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ul>
<li>为什么会有AMF0和AMF3？有什么区别？<ul>
<li>AMF从Flash MX时代的AMF0发展到现在的AMF3。AMF3用作Flash Playe 9的ActionScript 3.0的默认序列化格式，而AMF0则用作旧版的ActionScript 1.0和2.0的序列化格式。 在网络传输数据方面，AMF3比AMF0更有效率。AMF3能将int和uint对象作为整数（integer）传输，并且能序列化ActionScript 3.0才支持的数据类型, 比如ByteArray，XML和Iexternalizable。</li>
</ul>
</li>
<li>接收端如何知道哪些chunk属于同一个message？<ul>
<li>通过srs代码（SrsProtocol::read_message_payload）得知：接收端将接收到chunk的chunk data的大小加和，如果等于message payload（通过chunk-&gt;message header-&gt;message length获取）的则认为是同一个message。</li>
</ul>
</li>
<li>每个chunk的csid是否相同？<ul>
<li>csid是chunk的一个标识，csid和chunk的类型有关，所以同一类型的不同chunk的csid是相同的。csid和chunk是否属于同一个message没关系。</li>
</ul>
</li>
</ul>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuweifeng/p/17444833.html">https://www.cnblogs.com/yuweifeng/p/17444833.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/12/FFplay%E6%92%AD%E6%94%BE%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/12/FFplay%E6%92%AD%E6%94%BE%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">FFplay播放控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-12 20:58:18" itemprop="dateCreated datePublished" datetime="2023-09-12T20:58:18+08:00">2023-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:35" itemprop="dateModified" datetime="2023-12-30T22:40:35+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFplay/" itemprop="url" rel="index"><span itemprop="name">FFplay</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h1><p>ffplay通过事件循环检查事件，可以通过p键或者空格键来切换暂停状态。</p>
<h2 id="播放进入暂停"><a href="#播放进入暂停" class="headerlink" title="播放进入暂停"></a>播放进入暂停</h2><p>在主函数事件循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SDLK_p:</span><br><span class="line"><span class="keyword">case</span> SDLK_SPACE:</span><br><span class="line">    toggle_pause(cur_stream);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">toggle_pause</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    stream_toggle_pause(is);</span><br><span class="line">    <span class="comment">//is-&gt;step给逐帧播放用的，为0代表退出逐帧播放模式</span></span><br><span class="line">    is-&gt;step = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从启动状态切换到暂停状态的时候，is-&gt;paused等于 0，所以是不会进去 <code>if (is-&gt;paused) &#123;...&#125;</code> 里面的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pause or resume the video */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stream_toggle_pause</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused) &#123;</span><br><span class="line">        is-&gt;frame_timer += av_gettime_relative() / <span class="number">1000000.0</span> - is-&gt;vidclk.last_updated;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;read_pause_return != AVERROR(ENOSYS)) &#123;</span><br><span class="line">            is-&gt;vidclk.paused = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_clock(&amp;is-&gt;vidclk, get_clock(&amp;is-&gt;vidclk), is-&gt;vidclk.serial);</span><br><span class="line">    &#125;</span><br><span class="line">    set_clock(&amp;is-&gt;extclk, get_clock(&amp;is-&gt;extclk), is-&gt;extclk.serial);</span><br><span class="line">    <span class="comment">//4个暂停变量都被设置成1，或者从1切换成0</span></span><br><span class="line">    is-&gt;paused = is-&gt;audclk.paused = is-&gt;vidclk.paused = is-&gt;extclk.paused = !is-&gt;paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暂停影响的函数"><a href="#暂停影响的函数" class="headerlink" title="暂停影响的函数"></a>暂停影响的函数</h3><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>主线程主要是处理键盘事件跟播放视频画面，键盘事件不会受到暂停状态影响，该处理还是继续处理。播放视频画面的函数是video_refresh()，但是暂停状态下也不会调video_refresh()。但是暂停状态下，如果改变了窗口大小，is-&gt;forece_refresh机会变成 1，就会调video_refresh()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">refresh_loop_wait_event</span><span class="params">(VideoState *is, SDL_Event *event)</span> &#123;</span><br><span class="line">    <span class="type">double</span> remaining_time = <span class="number">0.0</span>;</span><br><span class="line">    SDL_PumpEvents();</span><br><span class="line">    <span class="keyword">while</span> (!SDL_PeepEvents(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cursor_hidden &amp;&amp; av_gettime_relative() - cursor_last_shown &gt; CURSOR_HIDE_DELAY) &#123;</span><br><span class="line">            SDL_ShowCursor(<span class="number">0</span>);</span><br><span class="line">            cursor_hidden = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>)</span><br><span class="line">            av_usleep((<span class="type">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>));</span><br><span class="line">        remaining_time = REFRESH_RATE;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">            video_refresh(is, &amp;remaining_time);</span><br><span class="line">        SDL_PumpEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解复用线程"><a href="#解复用线程" class="headerlink" title="解复用线程"></a>解复用线程</h4><p>对于网络流的播放，有些流媒体协议支持暂停跟播放操作，当暂停的时候，服务器端就不会再推流过来了。对于本地播放是没用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;paused != is-&gt;last_paused) &#123;</span><br><span class="line">    is-&gt;last_paused = is-&gt;paused;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        is-&gt;read_pause_return = av_read_pause(ic);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        av_read_play(ic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于本地文件的播放，该线程即使在暂停状态下，也是不断运行，不断读取数据，直到塞满队列，塞满队列就会休眠10 ms，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if the queue are full, no need to read more */</span></span><br><span class="line"><span class="keyword">if</span> (infinite_buffer&lt;<span class="number">1</span> &amp;&amp;</span><br><span class="line">      (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; MAX_QUEUE_SIZE</span><br><span class="line">    || (stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream, &amp;is-&gt;audioq) &amp;&amp;</span><br><span class="line">        stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream, &amp;is-&gt;videoq) &amp;&amp;</span><br><span class="line">        stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream, &amp;is-&gt;subtitleq)))) &#123;</span><br><span class="line">    <span class="comment">/* wait 10 ms */</span></span><br><span class="line">    SDL_LockMutex(wait_mutex);</span><br><span class="line">    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class="number">10</span>);</span><br><span class="line">    SDL_UnlockMutex(wait_mutex);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视频解码线程"><a href="#视频解码线程" class="headerlink" title="视频解码线程"></a>视频解码线程</h4><p>在get_video_frame()函数中有掉用get_master_clock()，当外部时钟是主时钟的时候，这里的 get_master_clock()获取的就是外部时钟的播放时刻。因此如果在stream_toggle_pause()里面不更新外部时钟，这里获取到的时间就是错误的，会导致误判，丢帧。</p>
<p>该线程还是会正常解码，但是如果塞满FrameQueue队列的时候，就会一直阻塞在frame_queue_peek_writable()函数里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">            diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">            is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">            is-&gt;frame_drops_early++;</span><br><span class="line">            av_frame_unref(frame);</span><br><span class="line">            got_picture = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="音频解码线程"><a href="#音频解码线程" class="headerlink" title="音频解码线程"></a>音频解码线程</h4><p>类似视频解码线程，该线程还是会正常解码，但是如果塞满FrameQueue队列的时候，就会一直阻塞在frame_queue_peek_writable()函数里面。</p>
<h4 id="音频播放回调"><a href="#音频播放回调" class="headerlink" title="音频播放回调"></a>音频播放回调</h4><p>暂停状态下，audio_decode_frame()函数会直接返回 -1，就会导致输出静音数据，只要直接把stream指向的内存数据设置为0就是输出静音数据了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然是输出静音数据，但是音频播放线程还是在跑的，没有阻塞并且就会更新音频时钟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prepare a new audio buffer */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = opaque;</span><br><span class="line">    <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">    audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">           audio_size = audio_decode_frame(is);</span><br><span class="line">           <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if error, just output silence */</span></span><br><span class="line">               is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">               is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / </span><br><span class="line">                   is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">                   update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">               is-&gt;audio_buf_size = audio_size;</span><br><span class="line">           &#125;</span><br><span class="line">           is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">            <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">            <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">                SDL_MixAudioFormat(stream, </span><br><span class="line">                                   (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, </span><br><span class="line">                                   AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">        &#125;</span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">        set_clock_at(&amp;is-&gt;audclk,</span><br><span class="line">                     is-&gt;audio_clock -</span><br><span class="line">                     (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) /</span><br><span class="line">                     is-&gt;audio_tgt.bytes_per_sec,</span><br><span class="line">                     is-&gt;audio_clock_serial,</span><br><span class="line">                     audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">        sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暂停进入播放"><a href="#暂停进入播放" class="headerlink" title="暂停进入播放"></a>暂停进入播放</h2><p>暂停恢复继续播放后进入<code>if (is-&gt;paused) &#123;&#125;</code>逻辑，注意到在暂停过程中音频是有一直播放（静音播发）并设置音频时钟的，所以暂停恢复后需要对frame_timer加上暂停流逝的时间，同时设置视频时钟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pause or resume the video */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stream_toggle_pause</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused) &#123;</span><br><span class="line">        <span class="comment">//暂停恢复，frame_timer = frame_timer+暂停流逝的时间</span></span><br><span class="line">        is-&gt;frame_timer += av_gettime_relative() / <span class="number">1000000.0</span> - is-&gt;vidclk.last_updated;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;read_pause_return != AVERROR(ENOSYS)) &#123;</span><br><span class="line">            is-&gt;vidclk.paused = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置视频时钟</span></span><br><span class="line">        set_clock(&amp;is-&gt;vidclk, get_clock(&amp;is-&gt;vidclk), is-&gt;vidclk.serial);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置外部时钟</span></span><br><span class="line">    set_clock(&amp;is-&gt;extclk, get_clock(&amp;is-&gt;extclk), is-&gt;extclk.serial);</span><br><span class="line">    <span class="comment">//4个暂停变量都被设置成1，或者从1切换成0</span></span><br><span class="line">    is-&gt;paused = is-&gt;audclk.paused = is-&gt;vidclk.paused = is-&gt;extclk.paused = !is-&gt;paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在video_refresh()里面会用frame_timer来判断是否已经超过预定的播放时刻，如果<code>time &gt; is-&gt;frame_timer + duration</code>，就会发生丢帧的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">double</span> *remaining_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    is-&gt;frame_timer += delay;</span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)</span><br><span class="line">        is-&gt;frame_timer = time;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">    <span class="keyword">if</span> (!isnan(vp-&gt;pts))</span><br><span class="line">        update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">        duration = vp_duration(is, vp, nextvp);</span><br><span class="line">        <span class="keyword">if</span>(!is-&gt;step &amp;&amp; (framedrop&gt;<span class="number">0</span> || </span><br><span class="line">           (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; </span><br><span class="line">           time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">            is-&gt;frame_drops_late++;</span><br><span class="line">            frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：若暂停恢复但是不处理<code>if (is-&gt;paused) &#123;&#125;</code>中的逻辑，假设frame_time&#x3D;100，time&#x3D;105，可以计算出diff&#x3D;5s。</p>
<p>如果进入<code>delay = delay + diff</code>中，由于加上了diff为5s的时间，在video_refresh()可以看出此时frame_time和timer差距不大，不会发生丢帧；但是如果进入<code>delay = 2 * delay</code>中，在video_refresh()可以看出此时frame_time和timer差距过大会发生丢帧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">compute_target_delay</span><span class="params">(<span class="type">double</span> delay, VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> sync_threshold, diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update delay to follow master synchronisation source */</span></span><br><span class="line">    <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">        <span class="comment">/* if video is slave, we try to correct big delays by</span></span><br><span class="line"><span class="comment">           duplicating or deleting a frame */</span></span><br><span class="line">        <span class="comment">//视频时钟与同步时钟(如音频时钟)的差异</span></span><br><span class="line">        diff = get_clock(&amp;is-&gt;vidclk) - get_master_clock(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delay是上一帧播放时长</span></span><br><span class="line">        <span class="comment">// diff是视频时钟与同步时钟的差值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* skip or repeat frame. We take into account the</span></span><br><span class="line"><span class="comment">           delay to compute the threshold. I still don&#x27;t know</span></span><br><span class="line"><span class="comment">           if it is the best guess */</span></span><br><span class="line">        </span><br><span class="line">        sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));</span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt;= -sync_threshold)    <span class="comment">//播放较慢</span></span><br><span class="line">                delay = FFMAX(<span class="number">0</span>, delay + diff);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)    <span class="comment">//播放过快</span></span><br><span class="line">                delay = delay + diff;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)    <span class="comment">//播放较快</span></span><br><span class="line">                delay = <span class="number">2</span> * delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;video: delay=%0.3f A-V=%f\n&quot;</span>,</span><br><span class="line">           delay, -diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逐帧播放"><a href="#逐帧播放" class="headerlink" title="逐帧播放"></a>逐帧播放</h2><p>在FFplay播放器运行过程中，按S键进入<strong>逐帧播放模式</strong>，不断按S键可以逐步看下一帧的内容，如果想重新开始播放视频，直接按P键即可，<strong>逐帧播放其实是用暂停功能实现的</strong>。</p>
<p>在主函数事件循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SDLK_s: <span class="comment">// S: Step to next frame</span></span><br><span class="line">    step_to_next_frame(cur_stream);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>stream_toggle_pause()函数把播放器状态从暂停（在video_refresh中会置为暂停状态）恢复成启动。这样才能从refresh_loop_wait_event()进去video_refresh()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">step_to_next_frame</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* if the stream is paused unpause it, then step */</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        stream_toggle_pause(is);</span><br><span class="line">    <span class="comment">//代表进入了逐帧播放模式</span></span><br><span class="line">    is-&gt;step = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在video_refresh中不会丢帧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">    duration = vp_duration(is, vp, nextvp);</span><br><span class="line">    <span class="comment">//逐帧模式下不会丢帧</span></span><br><span class="line">    <span class="keyword">if</span>(!is-&gt;step &amp;&amp; (framedrop&gt;<span class="number">0</span> || </span><br><span class="line">       (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; </span><br><span class="line">       time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">        is-&gt;frame_drops_late++;</span><br><span class="line">        frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且取出一帧之后，调用stream_toggle_pause()进入暂停，之后可以继续按下S键处理上面流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused)</span><br><span class="line">    stream_toggle_pause(is);</span><br></pre></td></tr></table></figure>

<p>按P键会调用toggle_pause()，把is-&gt;step设置为0，即退出逐帧播放模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SDLK_p:</span><br><span class="line"><span class="keyword">case</span> SDLK_SPACE:</span><br><span class="line">    toggle_pause(cur_stream);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">toggle_pause</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    stream_toggle_pause(is);</span><br><span class="line">    is-&gt;step = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调节音量"><a href="#调节音量" class="headerlink" title="调节音量"></a>调节音量</h2><ul>
<li><p>⾳量控制的本质：控制采样点的幅值。</p>
<ul>
<li><p>静⾳，将采样点数值置为0。</p>
</li>
<li><p>⾳量+，提升采样点的幅值。</p>
</li>
<li><p>⾳量-，降低采样点的幅值。</p>
</li>
</ul>
</li>
<li><p>ffplay控制⾳量的⽅式 </p>
<ul>
<li><p>最⼤⾳量：输出解码后的原始数据。</p>
</li>
<li><p>静⾳：即是输出数值为0的数据。</p>
</li>
<li><p>改变⾳量：通过SDL_MixAudioFormat改变解码后数据的幅值。</p>
</li>
</ul>
</li>
</ul>
<p>ffplay中通过0键减小音量，9键增加音量。</p>
<p>在主函数事件循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SDLK_KP_MULTIPLY:</span><br><span class="line"><span class="keyword">case</span> SDLK_0:</span><br><span class="line">    update_volume(cur_stream, <span class="number">1</span>, SDL_VOLUME_STEP);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SDLK_KP_DIVIDE:</span><br><span class="line"><span class="keyword">case</span> SDLK_9:</span><br><span class="line">    update_volume(cur_stream, <span class="number">-1</span>, SDL_VOLUME_STEP);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_volume</span><span class="params">(VideoState *is, <span class="type">int</span> sign, <span class="type">double</span> step)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> volume_level = is-&gt;audio_volume ? </span><br><span class="line">        (<span class="number">20</span> * <span class="built_in">log</span>(is-&gt;audio_volume / (<span class="type">double</span>)SDL_MIX_MAXVOLUME) / <span class="built_in">log</span>(<span class="number">10</span>)) : <span class="number">-1000.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> new_volume = lrint(SDL_MIX_MAXVOLUME * </span><br><span class="line">                           <span class="built_in">pow</span>(<span class="number">10.0</span>, (volume_level + sign * step) / <span class="number">20.0</span>));</span><br><span class="line">    </span><br><span class="line">    is-&gt;audio_volume = av_clip(is-&gt;audio_volume == </span><br><span class="line">                               new_volume ? (is-&gt;audio_volume + sign) : new_volume, <span class="number">0</span>, SDL_MIX_MAXVOLUME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在音频播放sdl_audio_callback()回调中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">    <span class="comment">//最大音量直接拷贝原始数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//数据清零，为静音</span></span><br><span class="line">    <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过SDL_MixAudioFormat改变解码后数据的幅值</span></span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">        SDL_MixAudioFormat(stream, </span><br><span class="line">                           (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, </span><br><span class="line">                           AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="seek操作"><a href="#seek操作" class="headerlink" title="seek操作"></a>seek操作</h2><p>SDLK_LEFT：后退10秒。</p>
<p>SDLK_RIGHT：前进10秒。</p>
<p>SDLK_UP：前进60秒。</p>
<p>SDLK_DOWN：后退60秒。</p>
<p>SDL_MOUSEMOTION：⿏标右键按下，seek到指定的位置。</p>
<p>在主函数事件循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SDLK_LEFT:</span><br><span class="line">    incr = seek_interval ? -seek_interval : <span class="number">-10.0</span>;</span><br><span class="line">    <span class="keyword">goto</span> do_seek;</span><br><span class="line"><span class="keyword">case</span> SDLK_RIGHT:</span><br><span class="line">    incr = seek_interval ? seek_interval : <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">goto</span> do_seek;</span><br><span class="line"><span class="keyword">case</span> SDLK_UP:</span><br><span class="line">    incr = <span class="number">60.0</span>;</span><br><span class="line">    <span class="keyword">goto</span> do_seek;</span><br><span class="line"><span class="keyword">case</span> SDLK_DOWN:</span><br><span class="line">    incr = <span class="number">-60.0</span>;</span><br><span class="line">do_seek:</span><br><span class="line">    <span class="keyword">if</span> (seek_by_bytes) &#123;</span><br><span class="line">        pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> &amp;&amp; cur_stream-&gt;video_stream &gt;= <span class="number">0</span>)</span><br><span class="line">            pos = frame_queue_last_pos(&amp;cur_stream-&gt;pictq);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> &amp;&amp; cur_stream-&gt;audio_stream &gt;= <span class="number">0</span>)</span><br><span class="line">            pos = frame_queue_last_pos(&amp;cur_stream-&gt;sampq);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">            pos = avio_tell(cur_stream-&gt;ic-&gt;pb);</span><br><span class="line">        <span class="keyword">if</span> (cur_stream-&gt;ic-&gt;bit_rate)</span><br><span class="line">            incr *= cur_stream-&gt;ic-&gt;bit_rate / <span class="number">8.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            incr *= <span class="number">180000.0</span>;</span><br><span class="line">        pos += incr;</span><br><span class="line">        stream_seek(cur_stream, pos, incr, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = get_master_clock(cur_stream);</span><br><span class="line">        <span class="keyword">if</span> (isnan(pos))</span><br><span class="line">            pos = (<span class="type">double</span>)cur_stream-&gt;seek_pos / AV_TIME_BASE;</span><br><span class="line">        pos += incr;</span><br><span class="line">        <span class="keyword">if</span> (cur_stream-&gt;ic-&gt;start_time != AV_NOPTS_VALUE &amp;&amp; </span><br><span class="line">            pos &lt; cur_stream-&gt;ic-&gt;start_time / (<span class="type">double</span>)AV_TIME_BASE)</span><br><span class="line">            pos = cur_stream-&gt;ic-&gt;start_time / (<span class="type">double</span>)AV_TIME_BASE;</span><br><span class="line">        stream_seek(cur_stream, (<span class="type">int64_t</span>)(pos * AV_TIME_BASE), (<span class="type">int64_t</span>)(incr * AV_TIME_BASE), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SDL_MOUSEBUTTONDOWN:</span><br><span class="line">    <span class="keyword">if</span> (exit_on_mousedown) &#123;</span><br><span class="line">        do_exit(cur_stream);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.button.button == SDL_BUTTON_LEFT) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int64_t</span> last_mouse_left_click = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (av_gettime_relative() - last_mouse_left_click &lt;= <span class="number">500000</span>) &#123;</span><br><span class="line">            toggle_full_screen(cur_stream);</span><br><span class="line">            cur_stream-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line">            last_mouse_left_click = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last_mouse_left_click = av_gettime_relative();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* seek in the stream */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stream_seek</span><span class="params">(VideoState *is, <span class="type">int64_t</span> pos, <span class="type">int64_t</span> rel, <span class="type">int</span> seek_by_bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;seek_req) &#123;</span><br><span class="line">        is-&gt;seek_pos = pos;    <span class="comment">//按时间微妙，按字节byte</span></span><br><span class="line">        is-&gt;seek_rel = rel;    <span class="comment">//本次SEEK的位置增量</span></span><br><span class="line">        is-&gt;seek_flags &amp;= ~AVSEEK_FLAG_BYTE;</span><br><span class="line">        <span class="keyword">if</span> (seek_by_bytes)</span><br><span class="line">            is-&gt;seek_flags |= AVSEEK_FLAG_BYTE;</span><br><span class="line">        is-&gt;seek_req = <span class="number">1</span>;    <span class="comment">//请求seek，在read_thread线程seek成功才将其置为0</span></span><br><span class="line">        SDL_CondSignal(is-&gt;continue_read_thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解复⽤线程主循环中处理了seek操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;seek_req) &#123;</span><br><span class="line">    <span class="type">int64_t</span> seek_target = is-&gt;seek_pos;</span><br><span class="line">    <span class="type">int64_t</span> seek_min    = is-&gt;seek_rel &gt; <span class="number">0</span> ? seek_target - is-&gt;seek_rel + <span class="number">2</span>: INT64_MIN;</span><br><span class="line">    <span class="type">int64_t</span> seek_max    = is-&gt;seek_rel &lt; <span class="number">0</span> ? seek_target - is-&gt;seek_rel - <span class="number">2</span>: INT64_MAX;</span><br><span class="line">    <span class="comment">// FIXME the +-2 is due to rounding being not done in the correct direction in generation</span></span><br><span class="line">    <span class="comment">//      of the seek_pos/seek_rel variables</span></span><br><span class="line"></span><br><span class="line">    ret = avformat_seek_file(is-&gt;ic, <span class="number">-1</span>, seek_min, seek_target, seek_max, is-&gt;seek_flags);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;%s: error while seeking\n&quot;</span>, is-&gt;ic-&gt;url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            packet_queue_flush(&amp;is-&gt;audioq);    <span class="comment">//清空音频队列</span></span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);    <span class="comment">//放入flush_pkt，来清空解码器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            packet_queue_flush(&amp;is-&gt;subtitleq);</span><br><span class="line">            packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            packet_queue_flush(&amp;is-&gt;videoq);</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;seek_flags &amp; AVSEEK_FLAG_BYTE) &#123;</span><br><span class="line">            set_clock(&amp;is-&gt;extclk, NAN, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set_clock(&amp;is-&gt;extclk, seek_target / (<span class="type">double</span>)AV_TIME_BASE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置seek_req</span></span><br><span class="line">    is-&gt;seek_req = <span class="number">0</span>;</span><br><span class="line">    is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//eof</span></span><br><span class="line">    is-&gt;eof = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//暂停状态，播放第一帧</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        step_to_next_frame(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="退出播放"><a href="#退出播放" class="headerlink" title="退出播放"></a>退出播放</h2><p>ffplay中通过q键退出播放器。</p>
<p>在主函数事件循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SDL_KEYDOWN:</span><br><span class="line">    <span class="keyword">if</span> (exit_on_keydown || event.key.keysym.sym == SDLK_ESCAPE || event.key.keysym.sym == SDLK_q) &#123;</span><br><span class="line">        do_exit(cur_stream);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>do_exit()函数实际上只有两部分，调stream_close()和释放数据。后面的都是释放各种数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is) &#123;</span><br><span class="line">        stream_close(is);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (renderer)</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    <span class="keyword">if</span> (window)</span><br><span class="line">        SDL_DestroyWindow(window);</span><br><span class="line">    uninit_opts();</span><br><span class="line">    avformat_network_deinit();</span><br><span class="line">    <span class="keyword">if</span> (show_status)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_QUIET, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is-&gt;abort_request会在退出播放器的时候置为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stream_close</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> use a special url_shutdown call to abort parse cleanly */</span></span><br><span class="line">    is-&gt;abort_request = <span class="number">1</span>;</span><br><span class="line">    SDL_WaitThread(is-&gt;read_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* close each stream */</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>)</span><br><span class="line">        stream_component_close(is, is-&gt;audio_stream);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>)</span><br><span class="line">        stream_component_close(is, is-&gt;video_stream);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>)</span><br><span class="line">        stream_component_close(is, is-&gt;subtitle_stream);</span><br><span class="line"></span><br><span class="line">    avformat_close_input(&amp;is-&gt;ic);</span><br><span class="line"></span><br><span class="line">    packet_queue_destroy(&amp;is-&gt;videoq);</span><br><span class="line">    packet_queue_destroy(&amp;is-&gt;audioq);</span><br><span class="line">    packet_queue_destroy(&amp;is-&gt;subtitleq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free all pictures */</span></span><br><span class="line">    frame_queue_destory(&amp;is-&gt;pictq);</span><br><span class="line">    frame_queue_destory(&amp;is-&gt;sampq);</span><br><span class="line">    frame_queue_destory(&amp;is-&gt;subpq);</span><br><span class="line">    SDL_DestroyCond(is-&gt;continue_read_thread);</span><br><span class="line">    sws_freeContext(is-&gt;img_convert_ctx);</span><br><span class="line">    sws_freeContext(is-&gt;sub_convert_ctx);</span><br><span class="line">    av_free(is-&gt;filename);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;vis_texture)</span><br><span class="line">        SDL_DestroyTexture(is-&gt;vis_texture);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;vid_texture)</span><br><span class="line">        SDL_DestroyTexture(is-&gt;vid_texture);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;sub_texture)</span><br><span class="line">        SDL_DestroyTexture(is-&gt;sub_texture);</span><br><span class="line">    av_free(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="FFmpeg函数"><a href="#FFmpeg函数" class="headerlink" title="FFmpeg函数"></a>FFmpeg函数</h2><h3 id="avformat-seek-file"><a href="#avformat-seek-file" class="headerlink" title="avformat_seek_file"></a>avformat_seek_file</h3><p>用于在媒体文件中进行时间戳定位和跳转。它允许你在音频或视频文件中以特定的时间戳或帧号为基准进行跳转，以便在文件中找到特定的位置开始播放或处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">avformat_seek_file</span><span class="params">(AVFormatContext *s, <span class="type">int</span> stream_index, <span class="type">int64_t</span> min_ts, <span class="type">int64_t</span> ts, <span class="type">int64_t</span> max_ts, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><code>s</code>：<code>AVFormatContext</code> 结构体，表示打开的媒体文件的上下文。</p>
<p><code>stream_index</code>：指定要跳转的流的索引。</p>
<p><code>min_ts</code>：允许的最小时间戳。</p>
<p><code>ts</code>：要跳转到的时间戳或帧号。</p>
<p><code>max_ts</code>：允许的最大时间戳。</p>
<p><code>flags</code>：标志位，用于控制跳转的行为。常见的标志包括 <code>AVSEEK_FLAG_BACKWARD</code>（向后跳转）和 <code>AVSEEK_FLAG_FRAME</code>（基于帧号进行跳转）等。</p>
<p>返回值大等于零为成功，否则失败。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://ffmpeg.xianwaizhiyin.net/ffplay/step.html">https://ffmpeg.xianwaizhiyin.net/ffplay/step.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/10/FFplay%E2%BE%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/10/FFplay%E2%BE%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">FFplay⾳视频同步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-10 20:53:38" itemprop="dateCreated datePublished" datetime="2023-09-10T20:53:38+08:00">2023-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:03" itemprop="dateModified" datetime="2023-12-30T22:40:03+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFplay/" itemprop="url" rel="index"><span itemprop="name">FFplay</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="⾳视频同步"><a href="#⾳视频同步" class="headerlink" title="⾳视频同步"></a>⾳视频同步</h1><p><strong>为什么要进行音视频同步</strong>：由于⾳频和视频的输出不在同⼀个线程，⽽且，也不⼀定会同时解出同⼀个pts的⾳频帧和视频帧。甚至，编码或封装的时候可能pts还是不连续的，或有个别错误的。因此，在进⾏⾳频和视频的播放时，需要对⾳频和视频的播放速度、播放时刻进⾏控制，以实现⾳频和视频保持同步，即所谓的⾳视频同步。</p>
<p>在ffplay中，⾳频（audio）和视频（video）有各⾃的输出线程，其中⾳频的输出线程是sdl的⾳频输出回调线程，video的输出线程是程序的主线程。 </p>
<h2 id="⾳视频同步方式"><a href="#⾳视频同步方式" class="headerlink" title="⾳视频同步方式"></a>⾳视频同步方式</h2><ul>
<li><p>以⾳频为基准，同步视频到⾳频</p>
<ul>
<li>视频慢了则丢掉部分视频帧（视觉-&gt;画⾯跳帧）。</li>
<li>视频快了则继续渲染上⼀帧。</li>
</ul>
</li>
<li><p>以视频为基准，同步⾳频到视频 </p>
<ul>
<li>⾳频慢了则加快播放速度（或丢掉部分⾳频帧，丢帧极容易听出来断⾳）。</li>
<li>⾳频快了则放慢播放速度（或重复上⼀帧 ）。</li>
<li>⾳频改变播放速度时涉及到重采样。</li>
</ul>
</li>
<li><p>以外部时钟为基准，同步⾳频和视频到外部时钟。</p>
<ul>
<li>前两者的综合，根据外部时钟改变播放速度。</li>
</ul>
</li>
<li><p>视频和⾳频各⾃输出，即不作同步处理（FREE RUN）。</p>
</li>
</ul>
<p>由于⼈⽿对于声⾳变化的敏感度⽐视觉⾼，因此，⼀般采样的策略是将视频同步到⾳频，即对画⾯进⾏适当的丢帧或重复以追赶或等待⾳频。 特殊地，有时候会碰到⼀些特殊封装（或者有问题的封装），此时就不作同步处理，各⾃为主时钟，进⾏播放。 </p>
<h2 id="⾳视频同步概念"><a href="#⾳视频同步概念" class="headerlink" title="⾳视频同步概念"></a>⾳视频同步概念</h2><h3 id="FFmpeg基本概念"><a href="#FFmpeg基本概念" class="headerlink" title="FFmpeg基本概念"></a>FFmpeg基本概念</h3><p><strong>PTS</strong></p>
<p>pts是presentation timestamp的缩写，即显示时间戳，⽤于标记⼀个帧的呈现时刻，它的单位由timebase决定。timebase的类型是结构体AVRational（⽤于表示分数）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">///&lt; Numerator</span></span><br><span class="line">    <span class="type">int</span> den; <span class="comment">///&lt; Denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure>

<p>如 timebase&#x3D;{1, 1000} 表示千分之⼀秒（毫秒），那么pts&#x3D;1000，即为pts*1&#x2F;1000 &#x3D; 1秒，那么这⼀帧就需要在第⼀秒的时候呈现。</p>
<p><strong>AVRatioal转为小数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">av_q2d</span><span class="params">(AVRational a)</span>｛ </span><br><span class="line">    <span class="keyword">return</span> a.num / <span class="params">(<span class="type">double</span>)</span> a.den;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算时间戳</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp = pts * av_q2d(st-&gt;time_base)</span><br></pre></td></tr></table></figure>

<p><strong>计算帧时⻓</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = st-&gt;duration * av_q2d(st-&gt;time_base)</span><br></pre></td></tr></table></figure>

<p><strong>不同时间基之间的转换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">av_rescale_q</span><span class="params">(<span class="type">int64_t</span> a, AVRational bq, AVRational cq)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="FFplay同步概念"><a href="#FFplay同步概念" class="headerlink" title="FFplay同步概念"></a>FFplay同步概念</h3><p>在做同步的时候，我们需要⼀个”时钟”的概念，⾳频、视频、外部时钟都有⾃⼰独⽴的时钟，各⾃set各⾃的时钟，以谁为基准(master), 其他的则只能get该时钟进⾏同步。</p>
<p><strong>时钟结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> pts;                      <span class="comment">//时钟基础, 当前帧(待播放)显示时间戳，播放后,当前帧变成上一帧</span></span><br><span class="line">    <span class="type">double</span> pts_drift;                <span class="comment">//当前pts与当前系统时钟的差值, audio、video对于该值是独立的</span></span><br><span class="line">    <span class="type">double</span> last_updated;             <span class="comment">//最后一次更新的系统时钟</span></span><br><span class="line">    <span class="type">double</span> speed;                    <span class="comment">//时钟速度控制，用于控制播放速度</span></span><br><span class="line">    <span class="type">int</span> serial;                      <span class="comment">//播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列</span></span><br><span class="line">    <span class="type">int</span> paused;                      <span class="comment">//= 1 说明是暂停状态</span></span><br><span class="line">    <span class="type">int</span> *queue_serial;               <span class="comment">//指向packet_serial</span></span><br><span class="line">&#125; Clock;</span><br></pre></td></tr></table></figure>

<p><strong>初始化时钟</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_clock</span><span class="params">(Clock *c, <span class="type">int</span> *queue_serial)</span></span><br><span class="line">&#123;</span><br><span class="line">    c-&gt;speed = <span class="number">1.0</span>;</span><br><span class="line">    c-&gt;paused = <span class="number">0</span>;</span><br><span class="line">    c-&gt;queue_serial = queue_serial;</span><br><span class="line">    set_clock(c, NAN, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置时钟</strong></p>
<p>并且提供set_clock_at()函数，需要⽤pts、serial、time（系统时间）进⾏对时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_clock_at</span><span class="params">(Clock *c, <span class="type">double</span> pts, <span class="type">int</span> serial, <span class="type">double</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    c-&gt;pts = pts;</span><br><span class="line">    c-&gt;last_updated = time;</span><br><span class="line">    c-&gt;pts_drift = c-&gt;pts - time;</span><br><span class="line">    c-&gt;serial = serial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_clock</span><span class="params">(Clock *c, <span class="type">double</span> pts, <span class="type">int</span> serial)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">    set_clock_at(c, pts, serial, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取时钟</strong></p>
<p>也提供了get_clock()函数来查询时间。</p>
<p>对于视频时钟和音频时钟speed在初始化的时候就是1之后不会被改变，所以对于视频时钟和音频时钟来说，get_clock函数一般返回的是<code>c-&gt;pts_drift + time</code>。</p>
<p>但对于speed会改变的外部时钟来说，get_clock函数一般返回的是<code>c-&gt;pts_drift + time - (time - c-&gt;last_updated) * (1.0 - c-&gt;speed)</code>。表达式中的last_updated意思是时钟上次更新的时间（在set_clock_at中更新）。</p>
<p>所以表达式的意思是如果播放速度过快（speed &gt; 1），返回的时间就加上（speed-1）倍的当前时间和时钟上次更新的时间的差值。如果播放速度过慢（speed &lt; 1），返回的时间就减去（speed-1）倍的当前时间和时钟上次更新的时间的差值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">get_clock</span><span class="params">(Clock *c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*c-&gt;queue_serial != c-&gt;serial)</span><br><span class="line">        <span class="keyword">return</span> NAN;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;paused) &#123;</span><br><span class="line">        <span class="keyword">return</span> c-&gt;pts;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">double</span> time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">        <span class="keyword">return</span> c-&gt;pts_drift + time - (time - c-&gt;last_updated) * (<span class="number">1.0</span> - c-&gt;speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：⼀个时间轴（time是⼀直在按时间递增），从左往右看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----T1---T2------------T3---T4-----&gt;time</span><br></pre></td></tr></table></figure>

<p>T1时刻调用set_clock()设置时间，假设这时的pts是落后时间T2的，那么计算pts_drift &#x3D; pts - T2。</p>
<p>T3时刻调用get_clock()查询时间，因为set_clock时的pts已经过时，不能直接拿set_clock()时的pts当做这个时钟的时间。不过我们前⾯计算过pts_drift ，也就是pts和T4的差值，所以我们可以通过当前时刻的时间来估算当前时刻的pts： <code>pts = T4 + pts_drift</code>。 </p>
<p><strong>获取主时钟</strong></p>
<p>ffplay默认使用音频作为主时钟，并且提供获取主时钟的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the current master clock value */</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">get_master_clock</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (get_master_sync_type(is)) &#123;</span><br><span class="line">    <span class="keyword">case</span> AV_SYNC_VIDEO_MASTER:</span><br><span class="line">        val = get_clock(&amp;is-&gt;vidclk);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_SYNC_AUDIO_MASTER:</span><br><span class="line">        val = get_clock(&amp;is-&gt;audclk);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = get_clock(&amp;is-&gt;extclk);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="以音频为基准"><a href="#以音频为基准" class="headerlink" title="以音频为基准"></a>以音频为基准</h1><h2 id="设置音频时钟"><a href="#设置音频时钟" class="headerlink" title="设置音频时钟"></a>设置音频时钟</h2><p>当用SDL打开音频硬件设备的时候，SDL库就会创建一个线程，来及时执行回调函数来获取数据进行播放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = opaque;</span><br><span class="line">    <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">    audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            audio_size = audio_decode_frame(is);</span><br><span class="line">            <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if error, just output silence */</span></span><br><span class="line">                is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">                is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / </span><br><span class="line">                    is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">                    update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">            <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">            <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">                SDL_MixAudioFormat(stream, </span><br><span class="line">                                   (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index,</span><br><span class="line">                                   AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">        &#125;</span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">        set_clock_at(&amp;is-&gt;audclk,</span><br><span class="line">                     is-&gt;audio_clock -</span><br><span class="line">                     (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / </span><br><span class="line">                     is-&gt;audio_tgt.bytes_per_sec,</span><br><span class="line">                     is-&gt;audio_clock_serial,</span><br><span class="line">                     audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">        </span><br><span class="line">        sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码主要是设置音频的时钟，记录当前这一刻，音频流播放到哪里了。下面分析一下一些变量：</p>
<ul>
<li><code>is-&gt;audio_write_buf_size</code> 代表当前缓存里还剩多少数据没有拷贝给SDL。</li>
<li><code>is-&gt;audio_clock</code> 这个变量是在 audio_decode_frame()函数里面赋值的，记录的就是当这个AVFrame播放完之后，音频流所处的位置。<code>is-&gt;audio_clock</code> 记录的是播放完那个AVFrame之后的pts，但是此时此刻只是把这个AVFrame的内存数据拷贝给了SDL。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_clock = af-&gt;pts + (<span class="type">double</span>) af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line"><span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk,</span><br><span class="line">                 is-&gt;audio_clock -</span><br><span class="line">                 (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / </span><br><span class="line">                 is-&gt;audio_tgt.bytes_per_sec,</span><br><span class="line">                 is-&gt;audio_clock_serial,</span><br><span class="line">                 audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line"></span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SDL线程并不是没有音频数据可以播放了才调sdl_audio_callback()来拿数据，而是他内部还剩audio_hw_buf_size长度的数据就会调 sdl_audio_callback()来拿数据，是提前拿数据的。所以，SDL内部还剩audio_hw_buf_size字节，现在又来取了len字节，同时我们的 audio_buf缓存还剩audio_write_buf_size字节。总共有3块内存等待播放，而这3块内存播放完之后的pts就是is-&gt;audio_clock，len实际上就是等于audio_write_buf_size，只是换了下名字，所以可以直接用audio_hw_buf_size乘以2。</p>
<h2 id="视频同步到音频"><a href="#视频同步到音频" class="headerlink" title="视频同步到音频"></a>视频同步到音频</h2><p>ffplay中将视频同步到⾳频的主要⽅案是，如果视频播放过快，则重复播放上⼀帧，以等待⾳频；如果视频播放过慢，则丢帧追赶⾳频。这⼀部分的逻辑实现在视频输出函数video_refresh中。</p>
<p>视频同步流程：</p>
<ul>
<li>根据上一帧lastvp的播放时长duration，校正等到delay值，duration是上一帧理想播放时长，delay是上一帧实际播放时长，根据delay值可以计算得到当前帧的播放时刻。</li>
<li>如果当前帧vp播放时刻未到，则继续显示上一帧lastvp，并将延时值remaining_time作为输出参数供上级调用函数处理。</li>
<li>如果<strong>当前帧vp播放时刻已到</strong>并且<strong>lastvp播放时刻未到</strong>，则立即显示当前帧，否则会丢弃当前帧。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* called to display each frame */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">double</span> *remaining_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = opaque;</span><br><span class="line">    <span class="type">double</span> time;</span><br><span class="line"></span><br><span class="line">    Frame *sp, *sp2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;paused &amp;&amp; get_master_sync_type(is) == AV_SYNC_EXTERNAL_CLOCK &amp;&amp; is-&gt;realtime)</span><br><span class="line">        check_external_clock_speed(is);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO &amp;&amp; is-&gt;audio_st) &#123;</span><br><span class="line">        time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;force_refresh || is-&gt;last_vis_time + rdftspeed &lt; time) &#123;</span><br><span class="line">            video_display(is);</span><br><span class="line">            is-&gt;last_vis_time = time;</span><br><span class="line">        &#125;</span><br><span class="line">        *remaining_time = FFMIN(*remaining_time, is-&gt;last_vis_time + rdftspeed - time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// nothing to do, no picture to display in the queue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> last_duration, duration, delay;</span><br><span class="line">            Frame *vp, *lastvp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* dequeue the picture */</span></span><br><span class="line">            lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">            vp = frame_queue_peek(&amp;is-&gt;pictq);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vp-&gt;serial != is-&gt;videoq.serial) &#123;</span><br><span class="line">                frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastvp-&gt;serial != vp-&gt;serial)</span><br><span class="line">                is-&gt;frame_timer = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">                <span class="keyword">goto</span> display;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* compute nominal last_duration */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//lastvp上⼀帧，vp当前帧，nextvp下⼀帧</span></span><br><span class="line">            <span class="comment">//last_duration 代表当前帧本来需要显示多长时间。当前帧是指窗口正在显示的帧。</span></span><br><span class="line">            last_duration = vp_duration(is, lastvp, vp);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//经过compute_target_delay⽅法，计算出待显示帧vp需要等待的时间。</span></span><br><span class="line">            <span class="comment">//如果以video同步，则delay直接等于last_duration。</span></span><br><span class="line">            <span class="comment">//如果以audio或外部时钟同步，则需要⽐对主时钟调整待显示帧vp要等待的时间。</span></span><br><span class="line">            <span class="comment">//delay 代表当前帧实际应该显示多长时间</span></span><br><span class="line">            delay = compute_target_delay(last_duration, is);</span><br><span class="line"></span><br><span class="line">            time = av_gettime_relative()/<span class="number">1000000.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//is-&gt;frame_timer 实际上就是上⼀帧lastvp的播放时间</span></span><br><span class="line">            <span class="comment">//is-&gt;frame_timer + delay 是待显示帧vp该播放的时间</span></span><br><span class="line">            <span class="keyword">if</span> (time &lt; is-&gt;frame_timer + delay) &#123;    <span class="comment">//判断是否继续显示上⼀帧</span></span><br><span class="line">                <span class="comment">//当前系统时刻还未到达上⼀帧的结束时刻，那么还应该继续显示上⼀帧。</span></span><br><span class="line">                <span class="comment">//计算出最⼩等待时间</span></span><br><span class="line">                *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">                <span class="keyword">goto</span> display;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//接下来准备显示当前帧，若不丢帧</span></span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer += delay;    <span class="comment">//更新当前帧播放的时间</span></span><br><span class="line">            <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)</span><br><span class="line">                is-&gt;frame_timer = time;</span><br><span class="line"></span><br><span class="line">            SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">            <span class="keyword">if</span> (!isnan(vp-&gt;pts))</span><br><span class="line">                update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);    <span class="comment">//更新视频时钟</span></span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">                <span class="comment">//当前帧vp播放时长 = nextvp-&gt;pts - vp-&gt;pts</span></span><br><span class="line">                duration = vp_duration(is, vp, nextvp);</span><br><span class="line">                <span class="keyword">if</span>(!is-&gt;step &amp;&amp; </span><br><span class="line">                   (framedrop&gt;<span class="number">0</span> || </span><br><span class="line">                    (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; </span><br><span class="line">                   <span class="comment">//当前帧vp未能及时播放，即下一帧播放时刻(is-&gt;frame_timer+duration)小于当前系统时刻(time)</span></span><br><span class="line">                   time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">                    is-&gt;frame_drops_late++;</span><br><span class="line">                    frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">                    <span class="keyword">goto</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">            is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused)</span><br><span class="line">                stream_toggle_pause(is);</span><br><span class="line">        &#125;</span><br><span class="line">    display:</span><br><span class="line">        <span class="comment">/* display picture */</span></span><br><span class="line">        <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; </span><br><span class="line">            is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">            video_display(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compute_target_delay</code>根据视频时钟与同步时钟（如音频时钟）的差值，校正delay值，使视频时钟追赶或等待同步时钟。</p>
<p>可以看到，如果是音频时钟为主时钟，就会跑进去 <code>if</code> 里面的逻辑。</p>
<p>变量 <code>diff</code> 代表视频时钟与主时钟的时间差，主时钟默认是音频时钟。<strong>当 diff 大于 0 的时候，代表视频时钟比音频时钟快</strong>。<strong>当 diff 小于 0 的时候，代表视频时钟比音频时钟慢</strong>。<code>diff</code> 的单位是秒。</p>
<p>音视频不同步是常态，不需要做到完全同步，只要把不同步的程度控制在阈值范围内，人就感受不到不同步了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">compute_target_delay</span><span class="params">(<span class="type">double</span> delay, VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> sync_threshold, diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update delay to follow master synchronisation source */</span></span><br><span class="line">    <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">        <span class="comment">/* if video is slave, we try to correct big delays by</span></span><br><span class="line"><span class="comment">           duplicating or deleting a frame */</span></span><br><span class="line">        <span class="comment">//视频时钟与同步时钟(如音频时钟)的差异</span></span><br><span class="line">        diff = get_clock(&amp;is-&gt;vidclk) - get_master_clock(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delay 代表当前帧实际应该显示多长时间</span></span><br><span class="line">        <span class="comment">// diff是视频时钟与同步时钟的差值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* skip or repeat frame. We take into account the</span></span><br><span class="line"><span class="comment">           delay to compute the threshold. I still don&#x27;t know</span></span><br><span class="line"><span class="comment">           if it is the best guess */</span></span><br><span class="line">        </span><br><span class="line">        sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));</span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt;= -sync_threshold)    <span class="comment">//播放较慢</span></span><br><span class="line">                delay = FFMAX(<span class="number">0</span>, delay + diff);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)    <span class="comment">//播放过快</span></span><br><span class="line">                delay = delay + diff;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)    <span class="comment">//播放较快</span></span><br><span class="line">                delay = <span class="number">2</span> * delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;video: delay=%0.3f A-V=%f\n&quot;</span>,</span><br><span class="line">           delay, -diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FFplay 里面计算同步阈值（sync_threshold）的方式有点复杂，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync_threshold = <span class="built_in">FFMAX</span>(AV_SYNC_THRESHOLD_MIN, <span class="built_in">FFMIN</span>(AV_SYNC_THRESHOLD_MAX, delay));</span><br></pre></td></tr></table></figure>

<p>先介绍一下两个宏：</p>
<p>1，AV_SYNC_THRESHOLD_MIN，最小的同步阈值，值为 0.04，单位是秒。</p>
<p>2，AV_SYNC_THRESHOLD_MAX，最大的同步阈值，值为 0.1，单位是秒。</p>
<p>上面的代码，就是从 0.04 ~ 0.1 之间选出一个值作为同步阈值。</p>
<p>对于 1&#x2F;12帧的视频，delay 是 0.082，所以 sync_threshold 等于 0.082，等于一帧的播放时长。</p>
<p>对于 1&#x2F;24 帧的视频，delay 是 0.041，所以 sync_threshold 等于 0.041，等于一帧的播放时长。</p>
<p>对于 1&#x2F;48 帧的视频，delay 是 0.0205，所以 sync_threshold 等于 0.04，约等于两帧的播放时长。</p>
<p>这就是 FFplay 计算同步阈值（sync_threshold） 的算法。</p>
<p>计算出同步阈值之后，就需要判断音视频的时间差 <code>diff</code> 是否超过阈值，所以就有了下面的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">isnan</span>(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= -sync_threshold)</span><br><span class="line">        delay = <span class="built_in">FFMAX</span>(<span class="number">0</span>, delay + diff);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)</span><br><span class="line">        delay = delay + diff;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">        delay = <span class="number">2</span> * delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>is-&gt;max_frame_duration</code> 通常是 10s，这个判断是当音视频不同步的差异超过 10s，就不再进行同步操作。</p>
<p><code>sync_threshold</code> 同步域值，当前帧显示多长时间。</p>
<p><code>diff</code> 是负数的时候（<code>diff + sync_threshold &lt;= 0</code>），代表视频比音频慢了，通常会将 <code>delay</code> 置为 0。</p>
<p><code>diff</code> 是正数的时候（<code>diff - sync_threshold &gt;= 0</code>），代表视频比音频快了，当超过阈值的时候，就会把 <code>delay * 2</code>。</p>
<h1 id="以视频为基准"><a href="#以视频为基准" class="headerlink" title="以视频为基准"></a>以视频为基准</h1><p>媒体流⾥⾯只有视频成分，这个时候才会⽤以视频为基准。 </p>
<p>在⾳频输出时，最⼩单位是“样本”。⾳频⼀般以数字采样值保存，⼀般常⽤的采样频率有44.1K，48K等，也就是每秒钟有44100或48000个样本。视频输出中与“样本”概念最为接近的画⾯帧，如⼀个24fps(frame per second)的视频，⼀秒钟有24个画⾯输出，这⾥的⼀个画⾯和⾳频中的⼀个样本是等效的。可以想⻅，如果对⾳频使⽤⼀样的丢帧（丢样本）和重复显示⽅案，是不科学的。（⾳频的连续性远⾼于视频，通过重复⼏百个样本或者丢弃⼏百个样本来达到同步，会在听觉有很明显的不连贯）。</p>
<p>⾳频本质上来讲：就是做重采样补偿，⾳频慢了，重采样后的样本就⽐正常的减少，以赶紧播放下⼀帧；⾳频快了，重采样后的样本就⽐正常的增加，从⽽播放慢⼀些。 </p>
<h2 id="设置视频时钟"><a href="#设置视频时钟" class="headerlink" title="设置视频时钟"></a>设置视频时钟</h2><p>按照着视频帧间隔去播放，并实时地重新矫正video时钟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">double</span> *remaining_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span> (!isnan(vp-&gt;pts))</span><br><span class="line">    	update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_video_pts</span><span class="params">(VideoState *is, <span class="type">double</span> pts, <span class="type">int64_t</span> pos, <span class="type">int</span> serial)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* update current video pts */</span></span><br><span class="line">    set_clock(&amp;is-&gt;vidclk, pts, serial);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;vidclk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="音频同步到视频"><a href="#音频同步到视频" class="headerlink" title="音频同步到视频"></a>音频同步到视频</h2><p>音频同步流程：</p>
<ul>
<li>根据与vidoe clock的差值，计算应该输出的样本数。由函数synchronize_audio完成。</li>
<li>判断是否需要重采样：如果要输出的样本数与frame的样本数不相等，也就是需要适当减少或增加样本。</li>
<li>重采样——利⽤重采样库进⾏样本的插⼊或剔除。</li>
</ul>
<p>注意：与视频的处理略有不同，视频的同步控制主要体现在上⼀帧显示时⻓的控制，即对frame_timer的控制；⽽⾳频是直接体现在输出样本上的控制。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data_size, resampled_data_size;</span><br><span class="line">    <span class="type">int64_t</span> dec_channel_layout;</span><br><span class="line">    av_unused <span class="type">double</span> audio_clock0;</span><br><span class="line">    <span class="type">int</span> wanted_nb_samples;</span><br><span class="line">    Frame *af;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(af = frame_queue_peek_readable(&amp;is-&gt;sampq)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        frame_queue_next(&amp;is-&gt;sampq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (af-&gt;serial != is-&gt;audioq.serial);</span><br><span class="line"></span><br><span class="line">    data_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, af-&gt;frame-&gt;channels,</span><br><span class="line">                                           af-&gt;frame-&gt;nb_samples,</span><br><span class="line">                                           af-&gt;frame-&gt;format, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取声道布局</span></span><br><span class="line">    dec_channel_layout =</span><br><span class="line">        (af-&gt;frame-&gt;channel_layout &amp;&amp; af-&gt;frame-&gt;channels == </span><br><span class="line">         av_get_channel_layout_nb_channels(af-&gt;frame-&gt;channel_layout)) ?</span><br><span class="line">            af-&gt;frame-&gt;channel_layout : av_get_default_channel_layout(af-&gt;frame-&gt;channels);</span><br><span class="line">    <span class="comment">// 获取样本数校正值：若同步时钟是⾳频，则不调整样本数；否则根据同步需要调整样本数</span></span><br><span class="line">    wanted_nb_samples = synchronize_audio(is, af-&gt;frame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//is-&gt;audio_src第一次由is-&gt;audio_tgt设置 见上面</span></span><br><span class="line">    <span class="keyword">if</span> (af-&gt;frame-&gt;format        != is-&gt;audio_src.fmt            ||</span><br><span class="line">        dec_channel_layout       != is-&gt;audio_src.channel_layout ||</span><br><span class="line">        af-&gt;frame-&gt;sample_rate   != is-&gt;audio_src.freq           ||</span><br><span class="line">        (wanted_nb_samples       != af-&gt;frame-&gt;nb_samples &amp;&amp; !is-&gt;swr_ctx)) &#123;</span><br><span class="line">        swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">        <span class="comment">//分配swr_ctx</span></span><br><span class="line">        is-&gt;swr_ctx = swr_alloc_set_opts(<span class="literal">NULL</span>,</span><br><span class="line">                                         is-&gt;audio_tgt.channel_layout, </span><br><span class="line">                                         is-&gt;audio_tgt.fmt, </span><br><span class="line">                                         is-&gt;audio_tgt.freq,</span><br><span class="line">                                         dec_channel_layout,           </span><br><span class="line">                                         af-&gt;frame-&gt;format, </span><br><span class="line">                                         af-&gt;frame-&gt;sample_rate,</span><br><span class="line">                                         <span class="number">0</span>, </span><br><span class="line">                                         <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;swr_ctx || swr_init(is-&gt;swr_ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">                   <span class="string">&quot;Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n&quot;</span>,</span><br><span class="line">                   af-&gt;frame-&gt;sample_rate, av_get_sample_fmt_name(af-&gt;frame-&gt;format), af-&gt;frame-&gt;channels,</span><br><span class="line">                   is-&gt;audio_tgt.freq, av_get_sample_fmt_name(is-&gt;audio_tgt.fmt), is-&gt;audio_tgt.channels);</span><br><span class="line">            swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_src.channel_layout = dec_channel_layout;</span><br><span class="line">        is-&gt;audio_src.channels       = af-&gt;frame-&gt;channels;</span><br><span class="line">        is-&gt;audio_src.freq = af-&gt;frame-&gt;sample_rate;</span><br><span class="line">        is-&gt;audio_src.fmt = af-&gt;frame-&gt;format;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;swr_ctx) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> **in = (<span class="type">const</span> <span class="type">uint8_t</span> **)af-&gt;frame-&gt;extended_data;</span><br><span class="line">        <span class="type">uint8_t</span> **out = &amp;is-&gt;audio_buf1;</span><br><span class="line">        <span class="type">int</span> out_count = (<span class="type">int64_t</span>)wanted_nb_samples * is-&gt;audio_tgt.freq / af-&gt;frame-&gt;sample_rate + <span class="number">256</span>;</span><br><span class="line">        <span class="type">int</span> out_size  = av_samples_get_buffer_size(<span class="literal">NULL</span>, </span><br><span class="line">                                                   is-&gt;audio_tgt.channels, </span><br><span class="line">                                                   out_count, </span><br><span class="line">                                                   is-&gt;audio_tgt.fmt, </span><br><span class="line">                                                   <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len2;</span><br><span class="line">        <span class="keyword">if</span> (out_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wanted_nb_samples != af-&gt;frame-&gt;nb_samples) &#123;</span><br><span class="line">            <span class="comment">//激活重采样补偿</span></span><br><span class="line">            <span class="keyword">if</span> (swr_set_compensation(is-&gt;swr_ctx, </span><br><span class="line">                                     (wanted_nb_samples - af-&gt;frame-&gt;nb_samples) * </span><br><span class="line">                                     is-&gt;audio_tgt.freq / af-&gt;frame-&gt;sample_rate,</span><br><span class="line">                                     wanted_nb_samples * is-&gt;audio_tgt.freq / </span><br><span class="line">                                     af-&gt;frame-&gt;sample_rate) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_set_compensation() failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_fast_malloc(&amp;is-&gt;audio_buf1, &amp;is-&gt;audio_buf1_size, out_size);</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;audio_buf1)</span><br><span class="line">            <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换</span></span><br><span class="line">        len2 = swr_convert(is-&gt;swr_ctx, out, out_count, in, af-&gt;frame-&gt;nb_samples);</span><br><span class="line">        <span class="keyword">if</span> (len2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_convert() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == out_count) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;audio buffer is probably too small\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (swr_init(is-&gt;swr_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">                swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        is-&gt;audio_buf = is-&gt;audio_buf1;</span><br><span class="line">        resampled_data_size = len2 * is-&gt;audio_tgt.channels * av_get_bytes_per_sample(is-&gt;audio_tgt.fmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is-&gt;audio_buf = af-&gt;frame-&gt;data[<span class="number">0</span>];</span><br><span class="line">        resampled_data_size = data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_clock0 = is-&gt;audio_clock;</span><br><span class="line">    <span class="comment">/* update the audio clock with the pts */</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(af-&gt;pts))</span><br><span class="line">        is-&gt;audio_clock = af-&gt;pts + (<span class="type">double</span>) af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        is-&gt;audio_clock = NAN;</span><br><span class="line">    is-&gt;audio_clock_serial = af-&gt;serial;</span><br><span class="line">    <span class="keyword">return</span> resampled_data_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronize_audio负责根据与video clock的差值计算出合适的⽬标样本数，通过样本数控制⾳频输出速度。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return the wanted number of samples to get better sync if sync_type is video</span></span><br><span class="line"><span class="comment"> * or external master clock */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">synchronize_audio</span><span class="params">(VideoState *is, <span class="type">int</span> nb_samples)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wanted_nb_samples = nb_samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if not master, then we try to remove or add samples to correct the clock */</span></span><br><span class="line">    <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">        <span class="type">double</span> diff, avg_diff;</span><br><span class="line">        <span class="type">int</span> min_nb_samples, max_nb_samples;</span><br><span class="line"></span><br><span class="line">        diff = get_clock(&amp;is-&gt;audclk) - get_master_clock(is);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">            is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum;</span><br><span class="line">            <span class="keyword">if</span> (is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">                <span class="comment">/* not enough measures to have a correct estimate */</span></span><br><span class="line">                is-&gt;audio_diff_avg_count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* estimate the A-V difference */</span></span><br><span class="line">                avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">                    wanted_nb_samples = nb_samples + (<span class="type">int</span>)(diff * is-&gt;audio_src.freq);</span><br><span class="line">                    min_nb_samples = ((nb_samples * (<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">                    max_nb_samples = ((nb_samples * (<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">                    wanted_nb_samples = av_clip(wanted_nb_samples, min_nb_samples, max_nb_samples);</span><br><span class="line">                &#125;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;diff=%f adiff=%f sample_diff=%d apts=%0.3f %f\n&quot;</span>,</span><br><span class="line">                       diff, avg_diff, wanted_nb_samples - nb_samples,</span><br><span class="line">                       is-&gt;audio_clock, is-&gt;audio_diff_threshold);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* too big difference : may be initial PTS errors, so</span></span><br><span class="line"><span class="comment">               reset A-V filter */</span></span><br><span class="line">            is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">            is-&gt;audio_diff_cum       = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wanted_nb_samples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="以外部时钟为基准"><a href="#以外部时钟为基准" class="headerlink" title="以外部时钟为基准"></a>以外部时钟为基准</h1><p>在seek的时候体验⾮常差，没有必要选择这种同步⽅式。	</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/449755257">https://zhuanlan.zhihu.com/p/449755257</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15655186/6090529">https://blog.51cto.com/u_15655186/6090529</a></p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.xianwaizhiyin.net/ffplay/video_sync.html">https://ffmpeg.xianwaizhiyin.net/ffplay/video_sync.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leisure_chn/p/10307089.html">https://www.cnblogs.com/leisure_chn/p/10307089.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/10/FFplay%E8%A7%86%E9%A2%91%E8%BE%93%E5%87%BA%E5%92%8C%E5%B0%BA%E2%BC%A8%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/10/FFplay%E8%A7%86%E9%A2%91%E8%BE%93%E5%87%BA%E5%92%8C%E5%B0%BA%E2%BC%A8%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">FFplay视频输出和尺⼨变换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-10 10:52:55" itemprop="dateCreated datePublished" datetime="2023-09-10T10:52:55+08:00">2023-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:23" itemprop="dateModified" datetime="2023-12-30T22:40:23+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFplay/" itemprop="url" rel="index"><span itemprop="name">FFplay</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="视频输出模块"><a href="#视频输出模块" class="headerlink" title="视频输出模块"></a>视频输出模块</h1><p>视频输出的主要流程：</p>
<ul>
<li>视频（图像）输出初始化。</li>
<li>视频（图像）输出逻辑。</li>
</ul>
<h2 id="视频输出初始化"><a href="#视频输出初始化" class="headerlink" title="视频输出初始化"></a>视频输出初始化</h2><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//SDL的初始化</span></span><br><span class="line">    flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;</span><br><span class="line">    <span class="keyword">if</span> (SDL_Init (flags)) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;(Did you set the DISPLAY variable?)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建窗⼝</span></span><br><span class="line">    window = SDL_CreateWindow(program_name, </span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED, </span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED, </span><br><span class="line">                              default_width, </span><br><span class="line">                              default_height, </span><br><span class="line">                              flags);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (window) &#123;</span><br><span class="line">        <span class="comment">//创建renderer</span></span><br><span class="line">        renderer = SDL_CreateRenderer(window, </span><br><span class="line">                                      <span class="number">-1</span>, </span><br><span class="line">                                      SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);</span><br><span class="line">        <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, </span><br><span class="line">                   AV_LOG_WARNING, </span><br><span class="line">                   <span class="string">&quot;Failed to initialize a hardware accelerated renderer: %s\n&quot;</span>, </span><br><span class="line">                   SDL_GetError());</span><br><span class="line">            renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!SDL_GetRendererInfo(renderer, &amp;renderer_info))</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_VERBOSE, <span class="string">&quot;Initialized %s renderer.\n&quot;</span>, renderer_info.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is = stream_open(input_filename, file_iformat);</span><br><span class="line">    <span class="keyword">if</span> (!is) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to initialize VideoState!\n&quot;</span>);</span><br><span class="line">        do_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件响应</span></span><br><span class="line">    event_loop(is);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化窗⼝显示⼤⼩"><a href="#初始化窗⼝显示⼤⼩" class="headerlink" title="初始化窗⼝显示⼤⼩"></a>初始化窗⼝显示⼤⼩</h3><p>在读取数据线程中有初始化窗口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从待处理流中获取相关参数，设置显示窗⼝的宽度、⾼度及宽⾼⽐</span></span><br><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">    AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">    <span class="comment">//sar为一个像素的比率，具体见附录</span></span><br><span class="line">    AVRational sar = av_guess_sample_aspect_ratio(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (codecpar-&gt;width)</span><br><span class="line">        set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置显示窗⼝的⼤⼩和宽⾼⽐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_default_window_size</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, AVRational sar)</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    <span class="comment">//srceen_width和screen_height可以有命令指定： -x screen_width -y screen_height</span></span><br><span class="line">    <span class="type">int</span> max_width  = screen_width  ? screen_width  : INT_MAX;</span><br><span class="line">    <span class="type">int</span> max_height = screen_height ? screen_height : INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (max_width == INT_MAX &amp;&amp; max_height == INT_MAX)</span><br><span class="line">        max_height = height;    <span class="comment">//没有指定最⼤⾼度时则使⽤视频的⾼度</span></span><br><span class="line">    calculate_display_rect(&amp;rect, <span class="number">0</span>, <span class="number">0</span>, max_width, max_height, width, height, sar);</span><br><span class="line">    default_width  = rect.w;</span><br><span class="line">    default_height = rect.h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">calculate_display_rect</span><span class="params">(SDL_Rect *rect,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> scr_xleft, <span class="type">int</span> scr_ytop, <span class="type">int</span> scr_width, <span class="type">int</span> scr_height,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> pic_width, <span class="type">int</span> pic_height, AVRational pic_sar)</span></span><br><span class="line">&#123;</span><br><span class="line">    AVRational aspect_ratio = pic_sar;</span><br><span class="line">    <span class="type">int64_t</span> width, height, x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果aspect_ratio是负数或者为0,设置为1:1	</span></span><br><span class="line">    <span class="keyword">if</span> (av_cmp_q(aspect_ratio, av_make_q(<span class="number">0</span>, <span class="number">1</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">        aspect_ratio = av_make_q(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转成真正的播放⽐例</span></span><br><span class="line">    aspect_ratio = av_mul_q(aspect_ratio, av_make_q(pic_width, pic_height));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> we suppose the screen has a 1.0 pixel ratio */</span></span><br><span class="line">    <span class="comment">//先以⾼度为基准</span></span><br><span class="line">    height = scr_height;</span><br><span class="line">    width = av_rescale(height, aspect_ratio.num, aspect_ratio.den) &amp; ~<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (width &gt; scr_width) &#123;</span><br><span class="line">        <span class="comment">//先以宽度为基准</span></span><br><span class="line">        width = scr_width;</span><br><span class="line">        height = av_rescale(width, aspect_ratio.den, aspect_ratio.num) &amp; ~<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算显示视频帧区域的起始坐标（在显示窗⼝内部的区域）</span></span><br><span class="line">    x = (scr_width - width) / <span class="number">2</span>;</span><br><span class="line">    y = (scr_height - height) / <span class="number">2</span>;</span><br><span class="line">    rect-&gt;x = scr_xleft + x;</span><br><span class="line">    rect-&gt;y = scr_ytop  + y;</span><br><span class="line">    rect-&gt;w = FFMAX((<span class="type">int</span>)width,  <span class="number">1</span>);</span><br><span class="line">    rect-&gt;h = FFMAX((<span class="type">int</span>)height, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视频输出逻辑"><a href="#视频输出逻辑" class="headerlink" title="视频输出逻辑"></a>视频输出逻辑</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>event_loop中会调用refresh_loop_wait_event进行图像显示。</p>
<p>是否要调⽤video_refresh的前置条件：</p>
<ul>
<li>显示模式不为SHOW_MODE_NONE。</li>
<li>或者，当前没有被暂停。</li>
<li>或者，当前设置了force_refresh，我们分析force_refresh置为1的场景：<ul>
<li>video_refresh⾥⾯帧该显示，这个是常规情况。</li>
<li>SDL_WINDOWEVENT_EXPOSED，窗⼝需要重新绘制。</li>
<li>SDL_MOUSEBUTTONDOWN &amp;&amp; SDL_BUTTON_LEFT 连续⿏标左键点击2次显示窗⼝间隔⼩于0.5秒，进⾏全屏或者恢复原始窗⼝播放。</li>
<li>SDLK_f，按f键进⾏全屏或者恢复原始窗⼝播放。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">refresh_loop_wait_event</span><span class="params">(VideoState *is, SDL_Event *event)</span> &#123;</span><br><span class="line">    <span class="type">double</span> remaining_time = <span class="number">0.0</span>;</span><br><span class="line">    SDL_PumpEvents();</span><br><span class="line">    <span class="keyword">while</span> (!SDL_PeepEvents(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cursor_hidden &amp;&amp; av_gettime_relative() - cursor_last_shown &gt; CURSOR_HIDE_DELAY) &#123;</span><br><span class="line">            SDL_ShowCursor(<span class="number">0</span>);</span><br><span class="line">            cursor_hidden = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>)</span><br><span class="line">            av_usleep((<span class="type">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>));</span><br><span class="line">        remaining_time = REFRESH_RATE;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">            video_refresh(is, &amp;remaining_time);</span><br><span class="line">        SDL_PumpEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h3><p>获取FrameQueue中的帧时间，播放序列等判断是否需要进行播放，以及如果播放时间已过是否丢帧进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* called to display each frame */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">double</span> *remaining_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = opaque;</span><br><span class="line">    <span class="type">double</span> time;</span><br><span class="line">    Frame *sp, *sp2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// nothing to do, no picture to display in the queue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> last_duration, duration, delay;</span><br><span class="line">            Frame *vp, *lastvp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* dequeue the picture */</span></span><br><span class="line">            <span class="comment">//读取上⼀帧</span></span><br><span class="line">            lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">            <span class="comment">//读取待显示帧</span></span><br><span class="line">            vp = frame_queue_peek(&amp;is-&gt;pictq);</span><br><span class="line">            <span class="comment">//如果不是最新的播放序列，则将其出队列 goto retry;</span></span><br><span class="line">            <span class="keyword">if</span> (vp-&gt;serial != is-&gt;videoq.serial) &#123;</span><br><span class="line">                frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新的播放序列重置当前时间</span></span><br><span class="line">            <span class="keyword">if</span> (lastvp-&gt;serial != vp-&gt;serial)</span><br><span class="line">                is-&gt;frame_timer = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">                <span class="keyword">goto</span> display;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* compute nominal last_duration */</span></span><br><span class="line">            <span class="comment">//计算上⼀帧lastvp应显示的时⻓</span></span><br><span class="line">            last_duration = vp_duration(is, lastvp, vp);</span><br><span class="line">            <span class="comment">//计算上⼀帧lastvp还要播放的时间</span></span><br><span class="line">            delay = compute_target_delay(last_duration, is);</span><br><span class="line"></span><br><span class="line">            time = av_gettime_relative()/<span class="number">1000000.0</span>;</span><br><span class="line">            <span class="comment">//还没有到播放时间</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            frame_timer 可以理解为帧显示时刻，</span></span><br><span class="line"><span class="comment">            对于更新前，可以理解为上⼀帧的显示时刻；</span></span><br><span class="line"><span class="comment">            对于更新后，可以理解为当前帧显示时刻。</span></span><br><span class="line"><span class="comment">            time &lt; is-&gt;frame_timer + delay，</span></span><br><span class="line"><span class="comment">            如果当前系统时刻还未到达上⼀帧 的结束时刻，</span></span><br><span class="line"><span class="comment">            那么还应该继续显示上⼀帧。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (time &lt; is-&gt;frame_timer + delay) &#123;</span><br><span class="line">                *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">                <span class="keyword">goto</span> display;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)</span><br><span class="line">                is-&gt;frame_timer = time;</span><br><span class="line"></span><br><span class="line">            SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">            <span class="keyword">if</span> (!isnan(vp-&gt;pts))</span><br><span class="line">                update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有nextvp才会检测是否该丢帧</span></span><br><span class="line">            <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">                duration = vp_duration(is, vp, nextvp);</span><br><span class="line">                <span class="keyword">if</span>(!is-&gt;step &amp;&amp; </span><br><span class="line">                   (framedrop&gt;<span class="number">0</span> || </span><br><span class="line">                    (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; <span class="comment">//⾮视频同步⽅式</span></span><br><span class="line">                   time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">                    is-&gt;frame_drops_late++;</span><br><span class="line">                    frame_queue_next(&amp;is-&gt;pictq);    <span class="comment">//这⾥实现真正的丢帧</span></span><br><span class="line">                    <span class="keyword">goto</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">            is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused)</span><br><span class="line">                stream_toggle_pause(is);</span><br><span class="line">    display:</span><br><span class="line">        <span class="comment">/* display picture */</span></span><br><span class="line">        <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">            video_display(is);</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;force_refresh = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* display the current picture, if any */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_display</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;width)</span><br><span class="line">        video_open(is);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_st &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">        video_audio_display(is);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;video_st)</span><br><span class="line">        video_image_display(is);</span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SDL设置窗口标题，大小相关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_open</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w,h;</span><br><span class="line"></span><br><span class="line">    w = screen_width ? screen_width : default_width;</span><br><span class="line">    h = screen_height ? screen_height : default_height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window_title)</span><br><span class="line">        window_title = input_filename;</span><br><span class="line">    SDL_SetWindowTitle(window, window_title);</span><br><span class="line"></span><br><span class="line">    SDL_SetWindowSize(window, w, h);</span><br><span class="line">    SDL_SetWindowPosition(window, screen_left, screen_top);</span><br><span class="line">    <span class="keyword">if</span> (is_full_screen)</span><br><span class="line">        SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN_DESKTOP);</span><br><span class="line">    SDL_ShowWindow(window);</span><br><span class="line"></span><br><span class="line">    is-&gt;width  = w;</span><br><span class="line">    is-&gt;height = h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FrameQueue中取得要显示帧，然后更新SDL_Texture，最后通过SDL_RenderCopyEx拷⻉纹理给render显示。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_image_display</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    Frame *vp;</span><br><span class="line">    Frame *sp = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line"></span><br><span class="line">    vp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">    calculate_display_rect(&amp;rect, is-&gt;xleft, is-&gt;ytop, is-&gt;width, is-&gt;height, vp-&gt;width, vp-&gt;height, vp-&gt;sar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是重复显示上⼀帧，那么uploaded就是1</span></span><br><span class="line">    <span class="keyword">if</span> (!vp-&gt;uploaded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (upload_texture(&amp;is-&gt;vid_texture, vp-&gt;frame, &amp;is-&gt;img_convert_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vp-&gt;uploaded = <span class="number">1</span>;</span><br><span class="line">        vp-&gt;flip_v = vp-&gt;frame-&gt;linesize[<span class="number">0</span>] &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_sdl_yuv_conversion_mode(vp-&gt;frame);</span><br><span class="line">    SDL_RenderCopyEx(renderer, is-&gt;vid_texture, <span class="literal">NULL</span>, &amp;rect, <span class="number">0</span>, <span class="literal">NULL</span>, vp-&gt;flip_v ? SDL_FLIP_VERTICAL : <span class="number">0</span>);</span><br><span class="line">    set_sdl_yuv_conversion_mode(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AVFormat的图像数据传给sdl的纹理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">upload_texture</span><span class="params">(SDL_Texture **tex, AVFrame *frame, <span class="keyword">struct</span> SwsContext **img_convert_ctx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    Uint32 sdl_pix_fmt;</span><br><span class="line">    SDL_BlendMode sdl_blendmode;</span><br><span class="line">    <span class="comment">//根据frame中的图像格式(FFmpeg像素格式)，获取对应的SDL像素格式</span></span><br><span class="line">    get_sdl_pix_fmt_and_blendmode(frame-&gt;format, &amp;sdl_pix_fmt, &amp;sdl_blendmode);</span><br><span class="line">    <span class="comment">//重新分配vid_texture</span></span><br><span class="line">    <span class="comment">/*什么情况下realloc_texture：</span></span><br><span class="line"><span class="comment">    1.⽤于显示的texture 还没有分配；</span></span><br><span class="line"><span class="comment">    2.SDL_QueryTexture⽆效；</span></span><br><span class="line"><span class="comment">    3.⽬前texture的width，height、format和新要显示的Frame不⼀致</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (realloc_texture(tex, </span><br><span class="line">                        sdl_pix_fmt == SDL_PIXELFORMAT_UNKNOWN ? SDL_PIXELFORMAT_ARGB8888 : </span><br><span class="line">                        sdl_pix_fmt, frame-&gt;width, frame-&gt;height, sdl_blendmode, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//frame格式是SDL不⽀持的格式，则需要进⾏图像格式转换</span></span><br><span class="line">    <span class="keyword">switch</span> (sdl_pix_fmt) &#123;</span><br><span class="line">    <span class="keyword">case</span> SDL_PIXELFORMAT_UNKNOWN:</span><br><span class="line">        <span class="comment">/* This should only happen if we are not using avfilter... */</span></span><br><span class="line">        *img_convert_ctx = sws_getCachedContext(*img_convert_ctx,</span><br><span class="line">                                                frame-&gt;width, frame-&gt;height, </span><br><span class="line">                                                frame-&gt;format, frame-&gt;width, </span><br><span class="line">                                                frame-&gt;height, AV_PIX_FMT_BGRA, </span><br><span class="line">                                                sws_flags, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (*img_convert_ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> *pixels[<span class="number">4</span>];</span><br><span class="line">            <span class="type">int</span> pitch[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">if</span> (!SDL_LockTexture(*tex, <span class="literal">NULL</span>, (<span class="type">void</span> **)pixels, pitch)) &#123;</span><br><span class="line">                sws_scale(*img_convert_ctx, (<span class="type">const</span> <span class="type">uint8_t</span> * <span class="type">const</span> *)frame-&gt;data, frame-&gt;linesize,</span><br><span class="line">                          <span class="number">0</span>, frame-&gt;height, pixels, pitch);</span><br><span class="line">                SDL_UnlockTexture(*tex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Cannot initialize the conversion context\n&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SDL_PIXELFORMAT_IYUV:</span><br><span class="line">        <span class="comment">//frame格式对应SDL_PIXELFORMAT_IYUV，不⽤进⾏图像格式转换，调⽤SDL_UpdateYUVTexture()更新SDL texture</span></span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;linesize[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; frame-&gt;linesize[<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; frame-&gt;linesize[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = SDL_UpdateYUVTexture(*tex, <span class="literal">NULL</span>, frame-&gt;data[<span class="number">0</span>], frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                                       frame-&gt;data[<span class="number">1</span>], frame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                                       frame-&gt;data[<span class="number">2</span>], frame-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame-&gt;linesize[<span class="number">0</span>] &lt; <span class="number">0</span> &amp;&amp; frame-&gt;linesize[<span class="number">1</span>] &lt; <span class="number">0</span> &amp;&amp; frame-&gt;linesize[<span class="number">2</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = SDL_UpdateYUVTexture(*tex, <span class="literal">NULL</span>, </span><br><span class="line">                                       frame-&gt;data[<span class="number">0</span>] + frame-&gt;linesize[<span class="number">0</span>] * </span><br><span class="line">                                       (frame-&gt;height - <span class="number">1</span>), -frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                                       frame-&gt;data[<span class="number">1</span>] + frame-&gt;linesize[<span class="number">1</span>] * </span><br><span class="line">                                       (AV_CEIL_RSHIFT(frame-&gt;height, <span class="number">1</span>) - <span class="number">1</span>), -frame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                                       frame-&gt;data[<span class="number">2</span>] + frame-&gt;linesize[<span class="number">2</span>] * </span><br><span class="line">                                       (AV_CEIL_RSHIFT(frame-&gt;height, <span class="number">1</span>) - <span class="number">1</span>), -frame-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Mixed negative and positive linesizes are not supported.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;linesize[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = SDL_UpdateTexture(*tex, <span class="literal">NULL</span>, </span><br><span class="line">                                    frame-&gt;data[<span class="number">0</span>] + frame-&gt;linesize[<span class="number">0</span>] * (frame-&gt;height - <span class="number">1</span>), </span><br><span class="line">                                    -frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = SDL_UpdateTexture(*tex, <span class="literal">NULL</span>, frame-&gt;data[<span class="number">0</span>], frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图像格式转换"><a href="#图像格式转换" class="headerlink" title="图像格式转换"></a>图像格式转换</h1><p>FFmpeg中的 sws_scale() 函数主要是⽤来做视频像素格式和分辨率的转换，其优势在于：可以在同⼀个函数⾥实现：</p>
<ul>
<li>图像⾊彩空间转换</li>
<li>分辨率缩放</li>
<li>前后图像滤波处理</li>
</ul>
<p>不⾜之处在于：效率相对较低，不如libyuv或shader。</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="sws-getContext"><a href="#sws-getContext" class="headerlink" title="sws_getContext"></a>sws_getContext</h3><p>用于创建和配置用于图像转换的SwsContext结构体，以便在不同图像格式之间进行转换和调整。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SwsContext *<span class="title function_">sws_getContext</span><span class="params">(<span class="type">int</span> srcW, <span class="type">int</span> srcH, <span class="keyword">enum</span> AVPixelFormat srcFormat,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> dstW, <span class="type">int</span> dstH, <span class="keyword">enum</span> AVPixelFormat dstFormat,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> flags, SwsFilter *srcFilter,</span></span><br><span class="line"><span class="params">                                  SwsFilter *dstFilter, <span class="type">const</span> <span class="type">double</span> *param)</span>;</span><br></pre></td></tr></table></figure>

<p><code>srcW</code> 和 <code>srcH</code>：源图像的宽度和高度。</p>
<p><code>srcFormat</code>：源图像的像素格式（例如，RGB、YUV等）。</p>
<p><code>dstW</code> 和 <code>dstH</code>：目标图像的宽度和高度。</p>
<p><code>dstFormat</code>：目标图像的像素格式。</p>
<p><code>flags</code>：附加标志，提供了⼀系列的算法，快速线性，差值，矩阵，不同的算法性能也不同。</p>
<p><code>srcFilter</code> 和 <code>dstFilter</code>：源和目标的滤波器，用于在图像缩放过程中进行滤波。⼀般⽤不到，传NULL。</p>
<p><code>param</code>：可选参数，用于进一步配置图像转换。</p>
<p><code>sws_getContext</code> 返回一个 <code>SwsContext</code> 结构体的指针，你可以使用它来执行实际的图像转换。一旦配置了 <code>SwsContext</code>，你可以使用 <code>sws_scale</code> 函数来执行实际的图像转换操作。</p>
<h3 id="sws-getCachedContext"><a href="#sws-getCachedContext" class="headerlink" title="sws_getCachedContext"></a>sws_getCachedContext</h3><p>与sws_getContext类似，用于创建和配置图像转换的SwsContext结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SwsContext *<span class="title function_">sws_getCachedContext</span><span class="params">(<span class="keyword">struct</span> SwsContext *context,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> srcW, <span class="type">int</span> srcH, <span class="keyword">enum</span> AVPixelFormat srcFormat,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> dstW, <span class="type">int</span> dstH, <span class="keyword">enum</span> AVPixelFormat dstFormat,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> flags, SwsFilter *srcFilter,</span></span><br><span class="line"><span class="params">                                        SwsFilter *dstFilter, <span class="type">const</span> <span class="type">double</span> *param)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sws-scale"><a href="#sws-scale" class="headerlink" title="sws_scale"></a>sws_scale</h3><p>用于将源图像数据转换为目标图像数据，并根据配置信息进行缩放、格式转换等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sws_scale</span><span class="params">(<span class="keyword">struct</span> SwsContext *c, <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> srcSlice[],</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">int</span> srcStride[], <span class="type">int</span> srcSliceY, <span class="type">int</span> srcSliceH,</span></span><br><span class="line"><span class="params">              <span class="type">uint8_t</span> *<span class="type">const</span> dst[], <span class="type">const</span> <span class="type">int</span> dstStride[])</span>;</span><br></pre></td></tr></table></figure>

<p><code>c</code>：<code>SwsContext</code> 结构体，它包含了图像转换的配置信息，通常是使用 <code>sws_getContext</code> 或 <code>sws_getCachedContext</code> 创建的。</p>
<p><code>srcSlice</code>：输⼊图像的每个颜⾊通道的数据指针。其实就是解码后的AVFrame中的data[]数组。</p>
<p><code>srcStride</code>：输⼊图像的每个颜⾊通道的跨度。.也就是每个通道的⾏字节数，对应的是解码后的AVFrame中的linesize[]数组。</p>
<p><code>srcSliceY</code> 和 <code>srcSliceH</code>：表示源图像中要处理的区域的垂直位置和高度。</p>
<p><code>dst</code>：指向目标图像数据的指针数组，通常是一个包含目标图像的平面数组。</p>
<p><code>dstStride</code>：指向目标图像行间距的整数数组，表示每行数据的跨度（以字节为单位）。</p>
<h3 id="sws-freeContext"><a href="#sws-freeContext" class="headerlink" title="sws_freeContext"></a>sws_freeContext</h3><p>用于释放SwsContext结构体的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sws_freeContext</span><span class="params">(<span class="keyword">struct</span> SwsContext *swsContext)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*img_convert_ctx != <span class="literal">NULL</span>) &#123; </span><br><span class="line">    <span class="type">uint8_t</span> *pixels[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> pitch[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">if</span> (!SDL_LockTexture(*tex, <span class="literal">NULL</span>, (<span class="type">void</span> **)pixels, pitch)) &#123;</span><br><span class="line">        sws_scale(*img_convert_ctx, </span><br><span class="line">                  (<span class="type">const</span> <span class="type">uint8_t</span> * <span class="type">const</span> *)frame-&gt;data, </span><br><span class="line">                  frame-&gt;linesize, <span class="number">0</span>, frame-&gt;height, pixels, pitch);</span><br><span class="line">        SDL_UnlockTexture(*tex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/577627433?utm_id=0">https://zhuanlan.zhihu.com/p/577627433?utm_id=0</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/09/FFplay%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E5%92%8C%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/FFplay%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E5%92%8C%E9%9F%B3%E9%A2%91%E9%87%8D%E9%87%87%E6%A0%B7/" class="post-title-link" itemprop="url">FFplay音频输出和音频重采样</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-09 20:01:01" itemprop="dateCreated datePublished" datetime="2023-09-09T20:01:01+08:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:15" itemprop="dateModified" datetime="2023-12-30T22:40:15+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFplay/" itemprop="url" rel="index"><span itemprop="name">FFplay</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="⾳频输出模块"><a href="#⾳频输出模块" class="headerlink" title="⾳频输出模块"></a>⾳频输出模块</h1><p>⾳频输出的主要流程： </p>
<ul>
<li>打开SDL⾳频设备，设置参数。</li>
<li>启动SDL⾳频设备播放。</li>
<li>SDL⾳频回调函数读取数据，即从FrameQueue读取frame填充回调函数提供的buffer空间。</li>
</ul>
<h2 id="打开⾳频设备"><a href="#打开⾳频设备" class="headerlink" title="打开⾳频设备"></a>打开⾳频设备</h2><p>stream_component_open函数中打开音频设备。</p>
<p>audio_src ⼀开始与 audio_tgt 是⼀样的，如果输出设备⽀持⾳轨参数，那么 audio_src 可以⼀直保持与 audio_tgt ⼀致，否则将在后⾯代码中⾃动修正为⾳轨参数，并引⼊重采样机制。 </p>
<p>audio_buf相关的⼏个变量：</p>
<ul>
<li>audio_buf：从要输出的AVFrame中取出的⾳频数据（PCM），如果有必要，则对该数据重采样。</li>
<li>audio_buf_size：audio_buf的总⼤⼩。</li>
<li>audio_buf_index：下⼀次可读的audio_buf的index位置。</li>
<li>audio_write_buf_size：audio_buf剩余的buffer⻓度，即audio_buf_size - audio_buf_index。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从avctx(即AVCodecContext)中获取⾳频格式参数</span></span><br><span class="line">sample_rate    = avctx-&gt;sample_rate;</span><br><span class="line">nb_channels    = avctx-&gt;channels;</span><br><span class="line">channel_layout = avctx-&gt;channel_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prepare audio output */</span></span><br><span class="line"><span class="comment">//调⽤audio_open打开sdl⾳频输出，实际打开的设备参数保存在audio_tgt，返回值表示输出设备的缓冲区⼤⼩</span></span><br><span class="line"><span class="keyword">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">is-&gt;audio_hw_buf_size = ret;</span><br><span class="line">is-&gt;audio_src = is-&gt;audio_tgt;    <span class="comment">//暂时将数据源参数等同于⽬标输出参数</span></span><br><span class="line">is-&gt;audio_buf_size  = <span class="number">0</span>;</span><br><span class="line">is-&gt;audio_buf_index = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>audio_open()函数填⼊期望的⾳频参数，打开⾳频设备后，将实际的⾳频参数存⼊输出参数is-&gt;audio_tgt中，后⾯⾳频播放线程⽤会⽤到此参数，使⽤此参数将原始⾳频数据重采样，转换为⾳频设备⽀持的格式。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_open</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int64_t</span> wanted_channel_layout, <span class="type">int</span> wanted_nb_channels, </span></span><br><span class="line"><span class="params">                      <span class="type">int</span> wanted_sample_rate, <span class="keyword">struct</span> AudioParams *audio_hw_params)</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *env;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line">    <span class="type">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    env = SDL_getenv(<span class="string">&quot;SDL_AUDIO_CHANNELS&quot;</span>);</span><br><span class="line">    <span class="comment">//若环境变量有设置，优先从环境变量取得声道数和声道布局</span></span><br><span class="line">    <span class="keyword">if</span> (env) &#123;</span><br><span class="line">        wanted_nb_channels = atoi(env);</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置wanted_spec期望音频参数</span></span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout || </span><br><span class="line">        wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">        wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">    wanted_spec.channels = wanted_nb_channels;   <span class="comment">//声道数</span></span><br><span class="line">    wanted_spec.freq = wanted_sample_rate;       <span class="comment">//采样率</span></span><br><span class="line">    <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Invalid sample rate or channel count!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp; next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">        next_sample_rate_idx--;</span><br><span class="line">    wanted_spec.format = AUDIO_S16SYS;   <span class="comment">//S表带符号，16是采样深度，SYS表采用系统字节序</span></span><br><span class="line">    wanted_spec.silence = <span class="number">0</span>;  <span class="comment">//静音值</span></span><br><span class="line">    <span class="comment">//⼀次读取多⻓的数据</span></span><br><span class="line">    wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, </span><br><span class="line">                                <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));</span><br><span class="line">    wanted_spec.callback = sdl_audio_callback;    <span class="comment">//SDL以特定的频率调⽤回调函数，在回调函数中取得⾳频数据</span></span><br><span class="line">    wanted_spec.userdata = opaque;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开⾳频设备并创建⾳频处理线程。期望的参数是wanted_spec，实际得到的硬件参数是spec</span></span><br><span class="line">    <span class="keyword">while</span> (!(audio_dev = SDL_OpenAudioDevice(<span class="literal">NULL</span>, </span><br><span class="line">                                             <span class="number">0</span>, </span><br><span class="line">                                             &amp;wanted_spec, </span><br><span class="line">                                             &amp;spec, </span><br><span class="line">                                             SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | </span><br><span class="line">                                             SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;SDL_OpenAudio (%d channels, %d Hz): %s\n&quot;</span>,</span><br><span class="line">               wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">        wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">        <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">            wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">            wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">            <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">                       <span class="string">&quot;No more combinations to try, audio open failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查打开⾳频设备的实际参数</span></span><br><span class="line">    <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;SDL advised audio format %d is not supported!\n&quot;</span>, spec.format);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查打开⾳频设备的实际参数</span></span><br><span class="line">    <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">        <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">                   <span class="string">&quot;SDL advised channel count %d is not supported!\n&quot;</span>, spec.channels);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//audio_hw_params保存的参数，就是在做重采样的时候要转成的格式</span></span><br><span class="line">    audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">    audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">    audio_hw_params-&gt;channels =  spec.channels;   </span><br><span class="line">    <span class="comment">//channels * fmt</span></span><br><span class="line">    audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, </span><br><span class="line">                                                             audio_hw_params-&gt;channels, </span><br><span class="line">                                                             <span class="number">1</span>, </span><br><span class="line">                                                             audio_hw_params-&gt;fmt, </span><br><span class="line">                                                             <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//channels * freq * fmt</span></span><br><span class="line">    audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(<span class="literal">NULL</span>, </span><br><span class="line">                                                                audio_hw_params-&gt;channels, </span><br><span class="line">                                                                audio_hw_params-&gt;freq, </span><br><span class="line">                                                                audio_hw_params-&gt;fmt, </span><br><span class="line">                                                                <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> spec.size;    <span class="comment">//硬件内部缓存的数据字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prepare a new audio buffer */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = opaque;</span><br><span class="line">    <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">    audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果audio_buf消耗完了，则调⽤audio_decode_frame重新填充audio_buf</span></span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            audio_size = audio_decode_frame(is);</span><br><span class="line">            <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* if error, just output silence */</span></span><br><span class="line">                is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">                is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-&gt;audio_tgt.frame_size * </span><br><span class="line">                    is-&gt;audio_tgt.frame_size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">                    update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;   <span class="comment">//缓冲区剩余⼤⼩</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">            <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">            <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">                <span class="comment">//调整⾳量</span></span><br><span class="line">                SDL_MixAudioFormat(stream, </span><br><span class="line">                                   (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, </span><br><span class="line">                                   AUDIO_S16SYS, </span><br><span class="line">                                   len1, </span><br><span class="line">                                   is-&gt;audio_volume);</span><br><span class="line">        &#125;</span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        <span class="comment">//更新is-&gt;audio_buf_index</span></span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">    <span class="comment">//同步相关</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">        set_clock_at(&amp;is-&gt;audclk,</span><br><span class="line">                     is-&gt;audio_clock -</span><br><span class="line">                     (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) /</span><br><span class="line">                     is-&gt;audio_tgt.bytes_per_sec,</span><br><span class="line">                     is-&gt;audio_clock_serial,</span><br><span class="line">                     audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">        </span><br><span class="line">        sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>ffmpeg解码⼀个AVPacket的⾳频到AVFrame后，在AVFrame中存储的⾳频数据⼤⼩与SDL回调所需要的数据不⼀定相等 （回调函数每次要获取的数据量都是固定）；特别是如果要实现声⾳变速播放功能，那每帧AVFrame做变速后的数据⼤⼩⼤概率和SDL回调锁需要的数据⼤⼩不⼀致。这就需要再增加⼀级缓冲区解决问题，即是从FrameQueue队列读取到Frame的数据后，先缓存到⼀个buffer⾥，然后再从该buffer读取数据给到SDL回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data_size, resampled_data_size;</span><br><span class="line">    <span class="type">int64_t</span> dec_channel_layout;</span><br><span class="line">    av_unused <span class="type">double</span> audio_clock0;</span><br><span class="line">    <span class="type">int</span> wanted_nb_samples;</span><br><span class="line">    Frame *af;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(af = frame_queue_peek_readable(&amp;is-&gt;sampq)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        frame_queue_next(&amp;is-&gt;sampq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (af-&gt;serial != is-&gt;audioq.serial);</span><br><span class="line">    <span class="comment">//计算这⼀帧的字节数</span></span><br><span class="line">    data_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, af-&gt;frame-&gt;channels,</span><br><span class="line">                                           af-&gt;frame-&gt;nb_samples,</span><br><span class="line">                                           af-&gt;frame-&gt;format, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    dec_channel_layout =</span><br><span class="line">        (af-&gt;frame-&gt;channel_layout &amp;&amp; af-&gt;frame-&gt;channels == </span><br><span class="line">         av_get_channel_layout_nb_channels(af-&gt;frame-&gt;channel_layout)) ? </span><br><span class="line">        af-&gt;frame-&gt;channel_layout : av_get_default_channel_layout(af-&gt;frame-&gt;channels);</span><br><span class="line">    wanted_nb_samples = synchronize_audio(is, af-&gt;frame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af-&gt;frame-&gt;format        != is-&gt;audio_src.fmt            ||</span><br><span class="line">        dec_channel_layout       != is-&gt;audio_src.channel_layout ||</span><br><span class="line">        af-&gt;frame-&gt;sample_rate   != is-&gt;audio_src.freq           ||</span><br><span class="line">        (wanted_nb_samples       != af-&gt;frame-&gt;nb_samples &amp;&amp; !is-&gt;swr_ctx)) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要重新初始化重采样</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;swr_ctx) &#123;</span><br><span class="line">        <span class="comment">//...重采样相关</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//frame的数据</span></span><br><span class="line">        is-&gt;audio_buf = af-&gt;frame-&gt;data[<span class="number">0</span>];</span><br><span class="line">        resampled_data_size = data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_clock0 = is-&gt;audio_clock;</span><br><span class="line">    <span class="comment">/* update the audio clock with the pts */</span> ??</span><br><span class="line">    <span class="keyword">if</span> (!isnan(af-&gt;pts))</span><br><span class="line">        is-&gt;audio_clock = af-&gt;pts + (<span class="type">double</span>) af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        is-&gt;audio_clock = NAN;</span><br><span class="line">    is-&gt;audio_clock_serial = af-&gt;serial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resampled_data_size;  <span class="comment">//返回audio_buf的数据⼤⼩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="⾳频重采样"><a href="#⾳频重采样" class="headerlink" title="⾳频重采样"></a>⾳频重采样</h1><p>FFmpeg解码得到的⾳频帧的格式未必能被SDL⽀持，在这种情况下，需要进⾏⾳频重采样，即将⾳频帧格式转换为SDL⽀持的⾳频格式，否则是⽆法正常播放的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data_size, resampled_data_size;</span><br><span class="line">    <span class="type">int64_t</span> dec_channel_layout;</span><br><span class="line">    av_unused <span class="type">double</span> audio_clock0;</span><br><span class="line">    <span class="type">int</span> wanted_nb_samples;</span><br><span class="line">    Frame *af;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(af = frame_queue_peek_readable(&amp;is-&gt;sampq)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        frame_queue_next(&amp;is-&gt;sampq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (af-&gt;serial != is-&gt;audioq.serial);</span><br><span class="line"></span><br><span class="line">    data_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, af-&gt;frame-&gt;channels,</span><br><span class="line">                                           af-&gt;frame-&gt;nb_samples,</span><br><span class="line">                                           af-&gt;frame-&gt;format, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取声道布局</span></span><br><span class="line">    dec_channel_layout =</span><br><span class="line">        (af-&gt;frame-&gt;channel_layout &amp;&amp; af-&gt;frame-&gt;channels == </span><br><span class="line">         av_get_channel_layout_nb_channels(af-&gt;frame-&gt;channel_layout)) ?</span><br><span class="line">            af-&gt;frame-&gt;channel_layout : av_get_default_channel_layout(af-&gt;frame-&gt;channels);</span><br><span class="line">    <span class="comment">// 获取样本数校正值：若同步时钟是⾳频，则不调整样本数；否则根据同步需要调整样本数</span></span><br><span class="line">    wanted_nb_samples = synchronize_audio(is, af-&gt;frame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//is-&gt;audio_src第一次由is-&gt;audio_tgt设置 见上面</span></span><br><span class="line">    <span class="keyword">if</span> (af-&gt;frame-&gt;format        != is-&gt;audio_src.fmt            ||</span><br><span class="line">        dec_channel_layout       != is-&gt;audio_src.channel_layout ||</span><br><span class="line">        af-&gt;frame-&gt;sample_rate   != is-&gt;audio_src.freq           ||</span><br><span class="line">        (wanted_nb_samples       != af-&gt;frame-&gt;nb_samples &amp;&amp; !is-&gt;swr_ctx)) &#123;</span><br><span class="line">        swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">        <span class="comment">//分配swr_ctx</span></span><br><span class="line">        is-&gt;swr_ctx = swr_alloc_set_opts(<span class="literal">NULL</span>,</span><br><span class="line">                                         is-&gt;audio_tgt.channel_layout, </span><br><span class="line">                                         is-&gt;audio_tgt.fmt, </span><br><span class="line">                                         is-&gt;audio_tgt.freq,</span><br><span class="line">                                         dec_channel_layout,           </span><br><span class="line">                                         af-&gt;frame-&gt;format, </span><br><span class="line">                                         af-&gt;frame-&gt;sample_rate,</span><br><span class="line">                                         <span class="number">0</span>, </span><br><span class="line">                                         <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;swr_ctx || swr_init(is-&gt;swr_ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">                   <span class="string">&quot;Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n&quot;</span>,</span><br><span class="line">                   af-&gt;frame-&gt;sample_rate, av_get_sample_fmt_name(af-&gt;frame-&gt;format), af-&gt;frame-&gt;channels,</span><br><span class="line">                   is-&gt;audio_tgt.freq, av_get_sample_fmt_name(is-&gt;audio_tgt.fmt), is-&gt;audio_tgt.channels);</span><br><span class="line">            swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        is-&gt;audio_src.channel_layout = dec_channel_layout;</span><br><span class="line">        is-&gt;audio_src.channels       = af-&gt;frame-&gt;channels;</span><br><span class="line">        is-&gt;audio_src.freq = af-&gt;frame-&gt;sample_rate;</span><br><span class="line">        is-&gt;audio_src.fmt = af-&gt;frame-&gt;format;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;swr_ctx) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> **in = (<span class="type">const</span> <span class="type">uint8_t</span> **)af-&gt;frame-&gt;extended_data;</span><br><span class="line">        <span class="type">uint8_t</span> **out = &amp;is-&gt;audio_buf1;</span><br><span class="line">        <span class="type">int</span> out_count = (<span class="type">int64_t</span>)wanted_nb_samples * is-&gt;audio_tgt.freq / af-&gt;frame-&gt;sample_rate + <span class="number">256</span>;</span><br><span class="line">        <span class="type">int</span> out_size  = av_samples_get_buffer_size(<span class="literal">NULL</span>, </span><br><span class="line">                                                   is-&gt;audio_tgt.channels, </span><br><span class="line">                                                   out_count, </span><br><span class="line">                                                   is-&gt;audio_tgt.fmt, </span><br><span class="line">                                                   <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len2;</span><br><span class="line">        <span class="keyword">if</span> (out_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wanted_nb_samples != af-&gt;frame-&gt;nb_samples) &#123;</span><br><span class="line">            <span class="keyword">if</span> (swr_set_compensation(is-&gt;swr_ctx, </span><br><span class="line">                                     (wanted_nb_samples - af-&gt;frame-&gt;nb_samples) * </span><br><span class="line">                                     is-&gt;audio_tgt.freq / af-&gt;frame-&gt;sample_rate,</span><br><span class="line">                                     wanted_nb_samples * is-&gt;audio_tgt.freq / </span><br><span class="line">                                     af-&gt;frame-&gt;sample_rate) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_set_compensation() failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_fast_malloc(&amp;is-&gt;audio_buf1, &amp;is-&gt;audio_buf1_size, out_size);</span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;audio_buf1)</span><br><span class="line">            <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换</span></span><br><span class="line">        len2 = swr_convert(is-&gt;swr_ctx, out, out_count, in, af-&gt;frame-&gt;nb_samples);</span><br><span class="line">        <span class="keyword">if</span> (len2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_convert() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == out_count) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;audio buffer is probably too small\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (swr_init(is-&gt;swr_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">                swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        is-&gt;audio_buf = is-&gt;audio_buf1;</span><br><span class="line">        resampled_data_size = len2 * is-&gt;audio_tgt.channels * av_get_bytes_per_sample(is-&gt;audio_tgt.fmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is-&gt;audio_buf = af-&gt;frame-&gt;data[<span class="number">0</span>];</span><br><span class="line">        resampled_data_size = data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_clock0 = is-&gt;audio_clock;</span><br><span class="line">    <span class="comment">/* update the audio clock with the pts */</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(af-&gt;pts))</span><br><span class="line">        is-&gt;audio_clock = af-&gt;pts + (<span class="type">double</span>) af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        is-&gt;audio_clock = NAN;</span><br><span class="line">    is-&gt;audio_clock_serial = af-&gt;serial;</span><br><span class="line">    <span class="keyword">return</span> resampled_data_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="FFmpeg函数"><a href="#FFmpeg函数" class="headerlink" title="FFmpeg函数"></a>FFmpeg函数</h2><h3 id="av-get-default-channel-layout"><a href="#av-get-default-channel-layout" class="headerlink" title="av_get_default_channel_layout"></a>av_get_default_channel_layout</h3><p>获取默认的音频通道布局。</p>
<p>声道数表示音频流中的声道数量，而音频通道布局定义了这些声道的位置和排列方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">av_get_default_channel_layout</span><span class="params">(<span class="type">int</span> nb_channels)</span>;</span><br></pre></td></tr></table></figure>

<p><code>nb_channels</code>：要获取默认通道布局的声道数。通常，这是音频流的声道数。</p>
<p>返回值是一个 <code>uint64_t</code> 整数，表示默认的音频通道布局。</p>
<h3 id="av-samples-get-buffer-size"><a href="#av-samples-get-buffer-size" class="headerlink" title="av_samples_get_buffer_size"></a>av_samples_get_buffer_size</h3><p>用于计算音频样本数据的缓冲区大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">av_samples_get_buffer_size</span><span class="params">(<span class="type">int</span> *linesize, <span class="type">int</span> nb_channels, <span class="type">int</span> nb_samples,</span></span><br><span class="line"><span class="params">                               <span class="keyword">enum</span> AVSampleFormat sample_fmt, <span class="type">int</span> align)</span>;</span><br></pre></td></tr></table></figure>

<p><code>linesize</code>：这个值有函数内部填充，计算一行所占字节数，可以设置为NULL。</p>
<p><code>nb_channels</code>：音频数据的声道数。</p>
<p><code>nb_samples</code>：音频数据的样本数量。</p>
<p><code>sample_fmt</code>：音频数据的采样格式，使用枚举类型 <code>enum AVSampleFormat</code> 表示。</p>
<p><code>align</code>：对齐要求，通常为0，表示不需要特定的对齐。如果非零，表示要求按指定的字节对齐。</p>
<p>该函数计算并返回所需缓冲区的大小（以字节为单位），并将结果存储在 <code>linesize</code> 指针指向的位置。</p>
<h3 id="av-gettime-relative"><a href="#av-gettime-relative" class="headerlink" title="av_gettime_relative"></a>av_gettime_relative</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">av_gettime_relative</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>用于获取相对时间（relative time）。它返回一个 <code>int64_t</code> 类型的整数，表示当前系统时钟的相对时间，通常以微秒（μs）为单位。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://ffmpeg.xianwaizhiyin.net/ffplay/video_sync.html">https://ffmpeg.xianwaizhiyin.net/ffplay/video_sync.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/09/FFplay%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/09/FFplay%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">FFplay音视频解码线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-09 15:25:21" itemprop="dateCreated datePublished" datetime="2023-09-09T15:25:21+08:00">2023-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:11" itemprop="dateModified" datetime="2023-12-30T22:40:11+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFplay/" itemprop="url" rel="index"><span itemprop="name">FFplay</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="视频解码线程"><a href="#视频解码线程" class="headerlink" title="视频解码线程"></a>视频解码线程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = arg;</span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    <span class="type">double</span> pts;</span><br><span class="line">    <span class="comment">//帧持续时间</span></span><br><span class="line">    <span class="type">double</span> duration;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    AVRational tb = is-&gt;video_st-&gt;time_base;</span><br><span class="line">    <span class="comment">//获取帧率</span></span><br><span class="line">    AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取解码后的视频帧</span></span><br><span class="line">        ret = get_video_frame(is, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> the_end;</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 1/帧率 = duration 单位秒, 没有帧率时则设置为0, 有帧率帧计算出帧间隔</span></span><br><span class="line">            duration = (frame_rate.num &amp;&amp; frame_rate.den ? </span><br><span class="line">                        av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//根据AVStream timebase计算出pts值, 单位为秒</span></span><br><span class="line">            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">            <span class="comment">//将解码后的视频帧插⼊队列</span></span><br><span class="line">            ret = queue_picture(is, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);</span><br><span class="line">            av_frame_unref(frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> the_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">the_end:</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取解码后的视频帧"><a href="#获取解码后的视频帧" class="headerlink" title="获取解码后的视频帧"></a>获取解码后的视频帧</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_video_frame</span><span class="params">(VideoState *is, AVFrame *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> got_picture;</span><br><span class="line">    <span class="comment">//解码</span></span><br><span class="line">    <span class="keyword">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//丢帧逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">        <span class="type">double</span> dpts = NAN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">            dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;</span><br><span class="line"></span><br><span class="line">        frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">                <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">                    diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">                    is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">                    is-&gt;frame_drops_early++;</span><br><span class="line">                    av_frame_unref(frame);</span><br><span class="line">                    got_picture = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> got_picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>调用decoder_decode_frame处理音视频帧解码。</p>
<h4 id="获取解码后的帧"><a href="#获取解码后的帧" class="headerlink" title="获取解码后的帧"></a>获取解码后的帧</h4><p>同⼀播放序列流连续的情况下，不断调⽤avcodec_receive_frame获取解码后的frame。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                decoder_reorder_pts：让ffmpeg排序pts 0=off 1=on -1=auto，默认为-1 </span></span><br><span class="line"><span class="comment">                （ffplay配置 -drp value 进⾏设置）</span></span><br><span class="line"><span class="comment">                0：frame的pts使⽤pkt_dts，这种情况基本不会出现</span></span><br><span class="line"><span class="comment">                1：frame保留⾃⼰的pts</span></span><br><span class="line"><span class="comment">                -1：frame的pts使⽤frame-&gt;best_effort_timestamp，</span></span><br><span class="line"><span class="comment">                    best_effort_timestamp是经过算法计算出来的值，</span></span><br><span class="line"><span class="comment">                    主要是“尝试为可能有错误的时间戳猜测出适当单调的时间戳”，</span></span><br><span class="line"><span class="comment">                    ⼤部分情况下还是frame-&gt;pts，或者就是frame-&gt;pkt_dts。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (decoder_reorder_pts == <span class="number">-1</span>) &#123;</span><br><span class="line">                    frame-&gt;pts = frame-&gt;best_effort_timestamp;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!decoder_reorder_pts) &#123;</span><br><span class="line">                    frame-&gt;pts = frame-&gt;pkt_dts;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">            d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">            <span class="comment">//使⽤flush_pkt冲刷解码器后，如果要再次解码则需要调⽤avcodec_flush_buffers()</span></span><br><span class="line">            avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有取到帧就返回</span></span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != AVERROR(EAGAIN));	<span class="comment">//没帧可读时ret返回EAGAIN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取⼀个packet"><a href="#获取⼀个packet" class="headerlink" title="获取⼀个packet"></a>获取⼀个packet</h4><p>如果播放序列不⼀致（数据不连续）则过滤掉“过时”的packet。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>)</span><br><span class="line">        SDL_CondSignal(d-&gt;empty_queue_cond);	<span class="comment">//通知read_thread产生数据</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;packet_pending) &#123;</span><br><span class="line">        <span class="comment">//如果还有待定的packet则使⽤它</span></span><br><span class="line">        <span class="comment">//如果avcodec_send_packet返回EAGAIN，则把当前pkt存⼊d-&gt;pkt，然后置标志位packet_pending为1。</span></span><br><span class="line">        av_packet_move_ref(&amp;pkt, &amp;d-&gt;pkt);</span><br><span class="line">        d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (packet_queue_get(d-&gt;<span class="built_in">queue</span>, &amp;pkt, <span class="number">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial != d-&gt;pkt_serial);	<span class="comment">//如果不是同⼀播放序列则继续读取</span></span><br></pre></td></tr></table></figure>

<h4 id="将packet送⼊解码器"><a href="#将packet送⼊解码器" class="headerlink" title="将packet送⼊解码器"></a>将packet送⼊解码器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pkt.data == flush_pkt.data) &#123;</span><br><span class="line">    avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">    d-&gt;finished = <span class="number">0</span>;</span><br><span class="line">    d-&gt;next_pts = d-&gt;start_pts;</span><br><span class="line">    d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">        <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">        ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = AVERROR(EAGAIN);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; !pkt.data) &#123;</span><br><span class="line">                d-&gt;packet_pending = <span class="number">1</span>;</span><br><span class="line">                av_packet_move_ref(&amp;d-&gt;pkt, &amp;pkt);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = got_frame ? <span class="number">0</span> : (pkt.data ? AVERROR(EAGAIN) : AVERROR_EOF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (avcodec_send_packet(d-&gt;avctx, &amp;pkt) == AVERROR(EAGAIN)) &#123;</span><br><span class="line">            av_log(d-&gt;avctx, AV_LOG_ERROR, </span><br><span class="line">                   <span class="string">&quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//缓存到了⾃封装的Decoder的pkt（即是d-&gt;pkt），并将d-&gt;packet_pending = 1，以备下次继续使⽤该packet</span></span><br><span class="line">            d-&gt;packet_pending = <span class="number">1</span>;</span><br><span class="line">            av_packet_move_ref(&amp;d-&gt;pkt, &amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_packet_unref(&amp;pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="丢帧"><a href="#丢帧" class="headerlink" title="丢帧"></a>丢帧</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//丢帧逻辑</span></span><br><span class="line"><span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">    <span class="type">double</span> dpts = NAN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">        dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;</span><br><span class="line"></span><br><span class="line">    frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//framedrop &gt; 0 允许drop帧</span></span><br><span class="line">    <span class="keyword">if</span> (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">            <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;	<span class="comment">//差值在可同步范围</span></span><br><span class="line">                diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;	<span class="comment">//同⼀序列的包</span></span><br><span class="line">                is-&gt;videoq.nb_packets) &#123;	<span class="comment">//packet队列⾄少有1帧数据</span></span><br><span class="line">                is-&gt;frame_drops_early++;</span><br><span class="line">                av_frame_unref(frame);</span><br><span class="line">                got_picture = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解码后的视频帧插⼊队列"><a href="#解码后的视频帧插⼊队列" class="headerlink" title="解码后的视频帧插⼊队列"></a>解码后的视频帧插⼊队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">queue_picture</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="type">double</span> pts, <span class="type">double</span> duration, <span class="type">int64_t</span> pos, <span class="type">int</span> serial)</span></span><br><span class="line">&#123;</span><br><span class="line">    Frame *vp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DEBUG_SYNC)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;frame_type=%c pts=%0.3f\n&quot;</span>,</span><br><span class="line">           av_get_picture_type_char(src_frame-&gt;pict_type), pts);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(vp = frame_queue_peek_writable(&amp;is-&gt;pictq)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    vp-&gt;sar = src_frame-&gt;sample_aspect_ratio;</span><br><span class="line">    vp-&gt;uploaded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vp-&gt;width = src_frame-&gt;width;</span><br><span class="line">    vp-&gt;height = src_frame-&gt;height;</span><br><span class="line">    vp-&gt;format = src_frame-&gt;format;</span><br><span class="line"></span><br><span class="line">    vp-&gt;pts = pts;</span><br><span class="line">    vp-&gt;duration = duration;</span><br><span class="line">    vp-&gt;pos = pos;</span><br><span class="line">    vp-&gt;serial = serial;</span><br><span class="line"></span><br><span class="line">    set_default_window_size(vp-&gt;width, vp-&gt;height, vp-&gt;sar);</span><br><span class="line">    <span class="comment">//将src中所有数据拷⻉到dst中，并复位src，src无效</span></span><br><span class="line">    av_frame_move_ref(vp-&gt;frame, src_frame);</span><br><span class="line">    <span class="comment">//更新写索引位置</span></span><br><span class="line">    frame_queue_push(&amp;is-&gt;pictq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="音频解码线程"><a href="#音频解码线程" class="headerlink" title="音频解码线程"></a>音频解码线程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = arg;</span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    Frame *af;</span><br><span class="line">    <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">    AVRational tb;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((got_frame = decoder_decode_frame(&amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">            <span class="comment">//设置sample_rate为timebase</span></span><br><span class="line">            tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq)))</span><br><span class="line">                <span class="keyword">goto</span> the_end;</span><br><span class="line">            <span class="comment">//设置Frame</span></span><br><span class="line">            af-&gt;pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">            af-&gt;pos = frame-&gt;pkt_pos;</span><br><span class="line">            af-&gt;serial = is-&gt;auddec.pkt_serial;</span><br><span class="line">            <span class="comment">//帧播放时间</span></span><br><span class="line">            af-&gt;duration = av_q2d((AVRational)&#123;frame-&gt;nb_samples, frame-&gt;sample_rate&#125;);</span><br><span class="line">            <span class="comment">//转移</span></span><br><span class="line">            av_frame_move_ref(af-&gt;frame, frame);</span><br><span class="line">            frame_queue_push(&amp;is-&gt;sampq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);</span><br><span class="line">    </span><br><span class="line">the_end:</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decoder_decode_frame流程和视频解码类似，对于音频注意时间基变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">    ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AVRational tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">            <span class="comment">//d-&gt;avctx-&gt;pkt_timebase实质是AVStream中的time_base</span></span><br><span class="line">            <span class="comment">//stream_component_open函数中avctx-&gt;pkt_timebase = ic-&gt;streams[stream_index]-&gt;time_base;</span></span><br><span class="line">            <span class="comment">//转换为采样率表示的时间基</span></span><br><span class="line">            frame-&gt;pts = av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)</span><br><span class="line">            <span class="comment">//如果frame-&gt;pts不正常则使⽤上⼀帧更新的next_pts和next_pts_tb</span></span><br><span class="line">            frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="comment">//保存预测的next_pts 预防中间pts无效</span></span><br><span class="line">            d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;</span><br><span class="line">            d-&gt;next_pts_tb = tb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="FFmpeg函数"><a href="#FFmpeg函数" class="headerlink" title="FFmpeg函数"></a>FFmpeg函数</h2><h3 id="av-guess-frame-rate"><a href="#av-guess-frame-rate" class="headerlink" title="av_guess_frame_rate"></a>av_guess_frame_rate</h3><p>用于猜测视频帧率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVRational <span class="title function_">av_guess_frame_rate</span><span class="params">(AVFormatContext *ctx, AVStream *stream, AVFrame *frame)</span>;</span><br></pre></td></tr></table></figure>

<p><code>formatContext</code>：指向包含视频流的格式上下文的指针。</p>
<p><code>stream</code>：指向视频流的指针。</p>
<p><code>frame</code>：指向视频帧的指针，可以为空。</p>
<p>返回一个 <code>AVRational</code> 结构，其中包含猜测出的帧率的分子和分母。</p>
<h3 id="av-guess-sample-aspect-ratio"><a href="#av-guess-sample-aspect-ratio" class="headerlink" title="av_guess_sample_aspect_ratio"></a>av_guess_sample_aspect_ratio</h3><p>用于猜测单个像素的宽高比（aspect ratio）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVRational <span class="title function_">av_guess_sample_aspect_ratio</span><span class="params">(AVFormatContext *format, AVStream *stream, AVFrame *frame)</span>;</span><br></pre></td></tr></table></figure>

<p><code>formatContext</code>：指向包含视频流的格式上下文的指针。</p>
<p><code>stream</code>：指向视频流的指针。</p>
<p><code>frame</code>：指向视频帧的指针。</p>
<p>返回一个 <code>AVRational</code> 结构，其中包含猜测出的宽高比的分子和分母。若没结果，则返回值为0&#x2F;1。</p>
<h3 id="avcodec-flush-buffers"><a href="#avcodec-flush-buffers" class="headerlink" title="avcodec_flush_buffers"></a>avcodec_flush_buffers</h3><p>调用这个函数将丢弃编解码器内部缓冲区中的任何待处理数据，可以从一个干净的状态开始解码或编码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">avcodec_flush_buffers</span><span class="params">(AVCodecContext *avctx)</span>;</span><br></pre></td></tr></table></figure>

<p><code>avctx</code>：指向 <code>AVCodecContext</code> 结构的指针，表示编解码器的上下文。这是要清空缓冲区的目标编解码器上下文。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000042611851">https://segmentfault.com/a/1190000042611851</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fang</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
