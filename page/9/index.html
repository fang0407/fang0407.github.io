<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fang0407.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="NOTE">
<meta property="og:url" content="https://fang0407.github.io/page/9/index.html">
<meta property="og:site_name" content="NOTE">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Fang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fang0407.github.io/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NOTE</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">NOTE</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/08/26/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%B0%81%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/26/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E5%B0%81%E8%A3%85/" class="post-title-link" itemprop="url">音视频解封装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-26 18:00:09" itemprop="dateCreated datePublished" datetime="2023-08-26T18:00:09+08:00">2023-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-15 11:02:11" itemprop="dateModified" datetime="2024-01-15T11:02:11+08:00">2024-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过 FFmpeg API 初步了解音视频解封装流程，以及输出相关音视频参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* default_filename = <span class="string">&quot;test.mp4&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* in_filename = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        in_filename = default_filename;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        in_filename = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVFormatContext* ifmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> video_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> audio_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    ret = avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        av_strerror(ret, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open %s failed:%s\n&quot;</span>, in_filename, buf);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = avformat_find_stream_info(ifmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        av_strerror(ret, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;avformat_find_stream_info :%s failed:%s \n&quot;</span>, in_filename, buf);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;av_dump_format in_filename:%s\n&quot;</span>, in_filename);</span><br><span class="line">    av_dump_format(ifmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//媒体文件路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;media name:%s\n&quot;</span>, ifmt_ctx-&gt;url);</span><br><span class="line">    <span class="comment">//媒体流数量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stream number:%d\n&quot;</span>, ifmt_ctx-&gt;nb_streams);</span><br><span class="line">    <span class="comment">//码率，单位bps</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;media average ratio:%lldkps\n&quot;</span>, (<span class="type">int64_t</span>)ifmt_ctx-&gt;bit_rate/<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//媒体文件时长</span></span><br><span class="line">    <span class="type">int</span> total_seconds, hour, minute, second;</span><br><span class="line">    <span class="comment">//duration：单位微秒 10000us = 1ms, 1000ms = 1s</span></span><br><span class="line">    total_seconds = (ifmt_ctx-&gt;duration) / AV_TIME_BASE;</span><br><span class="line">    hour = total_seconds / <span class="number">3600</span>;</span><br><span class="line">    minute = (total_seconds % <span class="number">3600</span>) / <span class="number">60</span>;</span><br><span class="line">    second = total_seconds % <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total duration:%02d:%02d:%02d\n&quot;</span>, hour, minute, second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旧版本通过遍历方式获取音视频信息，新版本可以通过av_find_best_stream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; ++i) &#123;</span><br><span class="line">        AVStream* in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        <span class="keyword">if</span> (AVMEDIA_TYPE_AUDIO == in_stream-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;audio info:\n&quot;</span>);</span><br><span class="line">            <span class="comment">//唯一标识</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;index:%d\n&quot;</span>, in_stream-&gt;index);</span><br><span class="line">            <span class="comment">//采样率</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sample_rate:%dHZ\n&quot;</span>, in_stream-&gt;codecpar-&gt;sample_rate);</span><br><span class="line">            <span class="comment">//音频采样格式</span></span><br><span class="line">            <span class="keyword">if</span> (AV_SAMPLE_FMT_FLTP == in_stream-&gt;codecpar-&gt;format) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;sample format:AV_SAMPLE_FMT_FLTP\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AV_SAMPLE_FMT_S16P == in_stream-&gt;codecpar-&gt;format) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;sample format:AV_SAMPLE_FMT_S16P\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//音频信道数目</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;channel number:%d\n&quot;</span>, in_stream-&gt;codecpar-&gt;channels);</span><br><span class="line">            <span class="comment">//音频编码格式</span></span><br><span class="line">            <span class="keyword">if</span> (AV_CODEC_ID_AAC == in_stream-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio codec format:AAC\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AV_CODEC_ID_MP3 == in_stream-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio codec format:MP3\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//音频总时长，单位为毫秒或微秒后，音频和视频总时长不一定相等</span></span><br><span class="line">            <span class="keyword">if</span> (in_stream-&gt;duration == AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio duration unknow\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> duration_audio = (in_stream-&gt;duration) * av_q2d(in_stream-&gt;time_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio duration: %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">                       duration_audio / <span class="number">3600</span>, (duration_audio % <span class="number">3600</span>) / <span class="number">60</span>, duration_audio % <span class="number">60</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            audio_index = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AVMEDIA_TYPE_VIDEO == in_stream-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;video info:\n&quot;</span>);</span><br><span class="line">            <span class="comment">//唯一标识</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;index:%d\n&quot;</span>, in_stream-&gt;index);</span><br><span class="line">            <span class="comment">//视频帧率</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fps:%lffps\n&quot;</span>, av_q2d(in_stream-&gt;avg_frame_rate));</span><br><span class="line">            <span class="comment">//视频编码格式</span></span><br><span class="line">            <span class="keyword">if</span> (AV_CODEC_ID_MPEG4 == in_stream-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video codec format:MPEG4\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AV_CODEC_ID_H264 == in_stream-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video codec format:H264\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//视频帧宽高</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;width:%d, height:%d\n&quot;</span>, in_stream-&gt;codecpar-&gt;width, in_stream-&gt;codecpar-&gt;height);</span><br><span class="line">            <span class="comment">//视频总时长，单位为毫秒或微秒后，音频和视频总时长不一定相等</span></span><br><span class="line">            <span class="keyword">if</span> (in_stream-&gt;duration == AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio duration unknow\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> duration_audio = (in_stream-&gt;duration) * av_q2d(in_stream-&gt;time_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio duration: %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">                       duration_audio / <span class="number">3600</span>, (duration_audio % <span class="number">3600</span>) / <span class="number">60</span>, duration_audio % <span class="number">60</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            video_index = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVPacket* pkt = av_packet_alloc();</span><br><span class="line">    <span class="type">int</span> pkt_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> print_max_count = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;av_read_frame start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = av_read_frame(ifmt_ctx, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;av_read_frame end\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt_count++ &lt; print_max_count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pkt-&gt;stream_index == audio_index) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio pts:%lld\n&quot;</span>, pkt-&gt;pts);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio dts:%lld\n&quot;</span>, pkt-&gt;dts);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio size:%d\n&quot;</span>, pkt-&gt;size);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;audio duration:%lf\n\n&quot;</span>, pkt-&gt;duration * av_q2d(ifmt_ctx-&gt;streams[audio_index]-&gt;time_base));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == video_index) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video pts:%lld\n&quot;</span>, pkt-&gt;pts);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video dts:%lld\n&quot;</span>, pkt-&gt;dts);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video size:%d\n&quot;</span>, pkt-&gt;size);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video pos:%lld\n&quot;</span>, pkt-&gt;pos);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;video duration:%lf\n\n&quot;</span>, pkt-&gt;duration * av_q2d(ifmt_ctx-&gt;streams[video_index]-&gt;time_base));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt)</span><br><span class="line">        av_packet_free(&amp;pkt);</span><br><span class="line"></span><br><span class="line"> failed:</span><br><span class="line">    <span class="keyword">if</span> (ifmt_ctx)</span><br><span class="line">        avformat_close_input(&amp;ifmt_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/08/24/FFmpeg%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/24/FFmpeg%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">FFmpeg内存模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-24 21:45:15" itemprop="dateCreated datePublished" datetime="2023-08-24T21:45:15+08:00">2023-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-16 18:36:58" itemprop="dateModified" datetime="2024-01-16T18:36:58+08:00">2024-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="AVPacket内存模型"><a href="#AVPacket内存模型" class="headerlink" title="AVPacket内存模型"></a>AVPacket内存模型</h1><p>AVPacket 可看作一个容器，它本身并不包含压缩的流媒体数据，而是通过 data 指针引用数据的缓存空间。所以将 Packet 作为参数传递的时候，就要根据具体的需求，进而决定对 data 引用的这部分数据缓存空间进行何种处理了。当从一个 Packet 去创建另一个 Packet 的时候，有两种情况：</p>
<ul>
<li><p>两个 Packet 的 buf 引用的是同一数据缓存空间，这时候要注意数据缓存空间的释放问题。</p>
</li>
<li><p>两个 Packet 的 buf 引用不同的数据缓存空间，每个 Packet 都有数据缓存空间的 copy。</p>
</li>
</ul>
<p>对于第一种情况，引入引用计数的概念：</p>
<ul>
<li><p>对于多个 AVPacket 共享同一个缓存空间，FFmpeg 使用的引用计数的机制（reference-count）。</p>
<ul>
<li>初始化引用计数为 0，只有真正分配 AVBuffer 的时候，引用计数初始化为 1。</li>
<li>当有新的 Packet 引用共享的缓存空间时，就将引用计数 +1。</li>
<li>当释放了引用共享空间的 Packet，就将引用计数 -1；引用计数为 0 时，就释放掉引用的缓存空间 AVBuffer。</li>
</ul>
</li>
<li><p>AVFrame 也是采用同样的机制。</p>
</li>
</ul>
<pre class="mermaid">classDiagram
class AVBuffer {
    +uint8_t* data
    +int size
    +atomic_uint refcount
}
class AVBufferRef {
    +AVBuffer* buffer
    +uint8_t* data
    +int size
}

class AVPacket {
    +AVBufferRef* buf
}

class AVFrame {
    +AVBufferRef* buf[AV_NUM_DATA_POINTERS]
}

AVBufferRef *-- AVBuffer
AVPacket *-- AVBufferRef
AVFrame *-- AVBufferRef</pre>

<h1 id="AVPacket函数"><a href="#AVPacket函数" class="headerlink" title="AVPacket函数"></a>AVPacket函数</h1><h2 id="AVPacket相关函数"><a href="#AVPacket相关函数" class="headerlink" title="AVPacket相关函数"></a>AVPacket相关函数</h2><ul>
<li><p>AVPacket *av_packet_alloc(void)：分配 AVPacket 这个时候和 buffer 没有关系。</p>
</li>
<li><p>void av_packet_free(AVPacket **pkt)：释放 AVPacket 和 av_packet_alloc 对应。</p>
</li>
<li><p>void av_init_packet(AVPacket *pkt)：初始化 AVPacket 只是单纯初始化 pkt 字段。</p>
</li>
<li><p>int av_new_packet(AVPacket *pkt, int size)：给 AVPacket 的 buf 分配内存，引用计数初始化为 1。</p>
</li>
<li><p>int av_packet_ref(AVPacket *dst, const AVPacket *src)：将 src 复制到 dst 中，并增加引用计数。</p>
</li>
<li><p>void av_packet_unref(AVPacket *pkt)：减少引用计数。</p>
</li>
<li><p>void av_packet_move_ref(AVPacket *dst, AVPacket *src)：转移引用计数。</p>
</li>
<li><p>AVPacket *av_packet_clone(const AVPacket *src)：等于 av_packet_alloc() + av_packet_ref()。</p>
</li>
</ul>
<h2 id="AVFrame相关函数"><a href="#AVFrame相关函数" class="headerlink" title="AVFrame相关函数"></a>AVFrame相关函数</h2><ul>
<li><p>AVFrame *av_frame_alloc(void)：分配 AVFrame。</p>
</li>
<li><p>void av_frame_free(AVFrame **frame)：释放 AVFrame。</p>
</li>
<li><p>int av_frame_ref(AVFrame *dst, const AVFrame *src)：增加引用计数。</p>
</li>
<li><p>void av_frame_unref(AVFrame *frame)：减少引用计数。</p>
</li>
<li><p>void av_frame_move_ref(AVFrame *dst, AVFrame *src)：转移引用计数。</p>
</li>
<li><p>int av_frame_get_buffer(AVFrame *frame, int align)：根据 AVFrame 分配内存。</p>
</li>
<li><p>AVFrame *av_frame_clone(const AVFrame *src)：等于 av_frame_alloc() + av_frame_ref()。</p>
</li>
</ul>
<h2 id="函数示例"><a href="#函数示例" class="headerlink" title="函数示例"></a>函数示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//av_packet_alloc()和av_packet_free()配对使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    ret = av_new_packet(pkt, <span class="number">1024</span>);</span><br><span class="line">    memccpy(pkt-&gt;data, (<span class="type">void</span>*)&amp;av_packet_test1, <span class="number">1</span>, <span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以不掉用av_packet_unref(), av_packet_free()内部会自动调用</span></span><br><span class="line">    av_packet_unref(pkt);</span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//误用av_init_packet，导致内存泄露</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    ret = av_new_packet(pkt, <span class="number">1024</span>);</span><br><span class="line">    memccpy(pkt-&gt;data, (<span class="type">void</span>*)&amp;av_packet_test1, <span class="number">1</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里init会把pkt-&gt;buf置空，导致内存泄露</span></span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//av_packet_move_ref()后，可以调用av_init_packet()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_test3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket* pkt2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    ret = av_new_packet(pkt, <span class="number">1024</span>);</span><br><span class="line">    memccpy(pkt-&gt;data, (<span class="type">void</span>*)&amp;av_packet_test1, <span class="number">1</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    pkt2 = av_packet_alloc();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//av_packet_move_ref()内部会调用av_init_packet</span></span><br><span class="line">    av_packet_move_ref(pkt2, pkt);</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    </span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    av_packet_free(&amp;pkt2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//av_packet_clone()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_test4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket* pkt2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    ret = av_new_packet(pkt, <span class="number">1024</span>);</span><br><span class="line">    memccpy(pkt-&gt;data, (<span class="type">void</span>*)&amp;av_packet_test1, <span class="number">1</span>, <span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//av_packet_clone() = av_packet_alloc() + av_packet_ref()</span></span><br><span class="line">    pkt2 = av_packet_clone(pkt);</span><br><span class="line">    <span class="comment">//init将pkt-&gt;buf置空，导致av_packet_free()无法释放buf内存</span></span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line">    </span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    av_packet_free(&amp;pkt2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//av_packet_ref()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_test5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket* pkt2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    <span class="comment">//打印reference_counted，必须保证传入的是有效指针</span></span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;buf) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(pkt) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ref_count(pkt-&gt;buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = av_new_packet(pkt, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;buf) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(pkt) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ref_count(pkt-&gt;buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memccpy(pkt-&gt;data, (<span class="type">void</span>*)&amp;av_packet_test5, <span class="number">1</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    pkt2 = av_packet_alloc();</span><br><span class="line">    av_packet_move_ref(pkt2, pkt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多次连续调用ref会导致无法释放</span></span><br><span class="line">    av_packet_ref(pkt, pkt2);</span><br><span class="line">    av_packet_ref(pkt, pkt2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;buf) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(pkt) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ref_count(pkt-&gt;buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt2-&gt;buf) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(pkt) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ref_count(pkt2-&gt;buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_packet_unref(pkt);</span><br><span class="line">    <span class="comment">//第二次后掉用unref无效，因为pkt-&gt;buf已经置空</span></span><br><span class="line">    av_packet_unref(pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;buf)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pkt-&gt;buf没有被置空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pkt-&gt;buf有被置空\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt2-&gt;buf) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(pkt) = %d\n&quot;</span>, </span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ref_count(pkt2-&gt;buf));</span><br><span class="line">    &#125;</span><br><span class="line">    av_packet_unref(pkt2);</span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    av_packet_free(&amp;pkt2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值+init操作类似av_packet_move_ref()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">av_packet_test6</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket* pkt2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pkt = av_packet_alloc();</span><br><span class="line">    ret = av_new_packet(pkt, <span class="number">1024</span>);</span><br><span class="line">    memccpy(pkt-&gt;data, (<span class="type">void</span>*)&amp;av_packet_test6, <span class="number">1</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    pkt2 = av_packet_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值+init操作类似av_packet_move_ref()</span></span><br><span class="line">    *pkt2 = *pkt;</span><br><span class="line">    av_init_packet(pkt);</span><br><span class="line"></span><br><span class="line">    av_packet_free(&amp;pkt);</span><br><span class="line">    av_packet_free(&amp;pkt2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">av_frame_test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AVFrame* frame = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    frame-&gt;nb_samples = <span class="number">1024</span>;</span><br><span class="line">    frame-&gt;format = AV_SAMPLE_FMT_S16;	<span class="comment">//AV_SAMPLE_FMT_S16 AV_SAMPLE_FMT_S16P</span></span><br><span class="line">    frame-&gt;channel_layout = AVA_CH_LAYOUT_MONO;</span><br><span class="line">    ret = av_frame_get_buffer(frame, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;buf &amp;&amp; frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) size(frame) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, frame-&gt;buf[<span class="number">0</span>]-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//AV_SAMPLE_FMT_S16P格式，buf[0]左声道数据，buf[1]右声道数据 </span></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;buf &amp;&amp; frame-&gt;buf[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) size(frame) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, frame-&gt;buf[<span class="number">1</span>]-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;buf &amp;&amp; frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(frame) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ret_count(frame-&gt;buf[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = av_frame_make_writable(frame);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;buf &amp;&amp; frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(frame) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ret_count(frame-&gt;buf[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_frame_unref(frame);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;buf &amp;&amp; frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s(%d) ref_count(frame) = %d\n&quot;</span>,</span><br><span class="line">               __FUNCTION__, __LINE__, av_buffer_get_ret_count(frame-&gt;buf[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/08/24/FFmpeg%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/24/FFmpeg%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">FFmpeg基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-24 21:45:15" itemprop="dateCreated datePublished" datetime="2023-08-24T21:45:15+08:00">2023-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-16 18:36:38" itemprop="dateModified" datetime="2024-01-16T18:36:38+08:00">2024-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="播放器框架"><a href="#播放器框架" class="headerlink" title="播放器框架"></a>播放器框架</h1><pre class="mermaid">graph LR
    媒体文件-->解复用器
    解复用器-->音频包队列
    音频包队列-->音频解码
    音频解码-->采样帧队列
    采样帧队列-->音频处理
    音频处理-->扬声器
    解复用器-->视频包队列
    视频包队列-->视频解码
    视频解码-->图像帧队列
    图像帧队列-->图像处理
    图像处理-->显示器</pre>

<h1 id="常见音视频概念"><a href="#常见音视频概念" class="headerlink" title="常见音视频概念"></a>常见音视频概念</h1><h2 id="常用音视频术语"><a href="#常用音视频术语" class="headerlink" title="常用音视频术语"></a>常用音视频术语</h2><ul>
<li><p>容器／文件（Conainer&#x2F;File）：即特定格式的多媒体文件，比如 mp4、flv、mkv 等。</p>
</li>
<li><p>媒体流（Stream）：表示时间轴上的一段连续数据，如一段声音数据、一段视频数据或一段字幕数据，可以是压缩的，也可以是非压缩的，压缩的数据需要关联特定的编解码器（有些码流音频他是纯 PCM）。</p>
</li>
<li><p>数据帧／数据包（Frame&#x2F;Packet）：通常，一个媒体流是由大量的数据帧组成的，对于压缩数据，帧对应着编解码器的最小处理单元，分属于不同媒体流的数据帧交错存储于容器之中。</p>
</li>
<li><p>编解码器：编解码器是以帧为单位实现压缩数据和原始数据之间的相互转换的。</p>
</li>
</ul>
<h2 id="复用器"><a href="#复用器" class="headerlink" title="复用器"></a>复用器</h2><pre class="mermaid">graph LR
    音频流-->按一定规则组合
    视频流-->按一定规则组合
    字幕流-->按一定规则组合
    其他成分-->按一定规则组合
    按一定规则组合-->视频文件</pre>

<pre class="mermaid">graph LR
    视频文件-->按一定规则拆分
    按一定规则拆分-->音频流
    按一定规则拆分-->视频流
    按一定规则拆分-->字幕流
    按一定规则拆分-->其他成分</pre>

<h2 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h2><pre class="mermaid">graph LR
    图像YUV数据--H264编码器-->H264帧
    H264帧--H264解码器-->图像YUV数据</pre>

<pre class="mermaid">graph LR
    声音PCM数据--AAC编码器-->AAC帧
    AAC帧--AAC解码器-->声音PCM数据</pre>

<h1 id="FFmpeg库简介"><a href="#FFmpeg库简介" class="headerlink" title="FFmpeg库简介"></a>FFmpeg库简介</h1><h2 id="FFmpeg的整体结构"><a href="#FFmpeg的整体结构" class="headerlink" title="FFmpeg的整体结构"></a>FFmpeg的整体结构</h2><ul>
<li>二进制程序：ffplay，ffprobe，ffmpeg</li>
<li>ffmpeg库：libavutil，libavformat，libavcodec，libswscale，libswresample，libavfilter，libpostproc</li>
<li>第三方编解码插件：fdk-aac，voaac_enc，x264</li>
</ul>
<h2 id="FFmpeg常用库"><a href="#FFmpeg常用库" class="headerlink" title="FFmpeg常用库"></a>FFmpeg常用库</h2><ul>
<li><p>AVUtil：核心工具库，下面的许多其他模块都会依赖该库做一些基本的音视频处理操作。</p>
</li>
<li><p>AVFormat：文件格式和协议库，该模块是最重要的模块之一，封装了 Protocol层 和 Demuxer、Muxer 层，使得协议和格式对于开发者来说是透明的。</p>
</li>
<li><p>AVCodec：编解码库，封装了 Codec 层，但是有一些Codec是具备自己的License的，<strong>FFmpeg 是不会默认添加像 libx264、FDK-AAC 等库的</strong>，但是 FFmpeg 就像一个平台一样，可以将其他的第三方的 Codec 以插件的方式添加进来，然后为开发者提供统一的接口。</p>
</li>
<li><p>AVFilter：音视频滤镜库，该模块提供了包括<strong>音频特效和视频特效</strong>的处理，在使用 FFmpeg 的 API 进行编解码的过程中，直接使用该模块为音视频数据做特效处理是非常方便同时也非常高效的一种方式。</p>
</li>
<li><p>AVDevice：输入输出设备库，比如，需要编译出播放声音或者视频的工具ffplay，就需要确保该模块是打开的，同时也需要SDL的预先编译，因为该设备模块播放声音与播放视频使用的都是 SDL 库。</p>
</li>
<li><p>SwrRessample：该模块可用于<strong>音频重采样</strong>，可以对数字音频进行声道数、数据格式、采样率等多种基本信息的转换。</p>
</li>
<li><p>SWScale：该模块是将<strong>图像进行格式转换</strong>的模块，比如，可以将 YUV 的数据转换为 RGB 的数据，缩放尺寸由 1280 * 720 变为 800 * 480。 </p>
</li>
<li><p>PostProc：该模块可用于进行后期处理，当我们使用 AVFilter 的时候需要打开该模块的开关，因为 Filter 中会使用到该模块的一些基础函数。</p>
</li>
</ul>
<h1 id="FFmpeg函数简介"><a href="#FFmpeg函数简介" class="headerlink" title="FFmpeg函数简介"></a>FFmpeg函数简介</h1><h2 id="封装格式函数"><a href="#封装格式函数" class="headerlink" title="封装格式函数"></a>封装格式函数</h2><ul>
<li>avformat_alloc_context()：负责申请一个 AVFormatContext 结构的内存，并进行简单初始化。</li>
<li>avformat_free_context()：释放该结构里的所有东西以及该结构本身。</li>
<li>avformat_open_input()；打开输入视频文件。</li>
<li>avformat_close_input()；关闭解复用器。关闭后就不再需要使用 avformat_free_context 进行释放。</li>
<li>avformat_find_stream_info()：获取音视频文件信息。</li>
<li>av_read_frame()：读取音视频包。</li>
<li>avformat_seek_file()：定位文件。</li>
<li>av_seek_frame()：定位文件。</li>
</ul>
<h2 id="解封装流程"><a href="#解封装流程" class="headerlink" title="解封装流程"></a>解封装流程</h2><pre class="mermaid">graph TB
    A[分配解复用器上下文 avformat_alloc_context]-->B[根据url打开本地文件或网络流 avformat_open_input]
    B-->C[读取媒体的部分数据包以获取码流信息 avformat_find_stream_info]
    C-->D[定位文件 avformat_seek_file 或 av_seek_frame]
    D-->E[从文件中循环读取数据包 av_read_frame]
    E-->F[关闭解复用器 avformat_close_input]</pre>

<h2 id="解码器函数"><a href="#解码器函数" class="headerlink" title="解码器函数"></a>解码器函数</h2><ul>
<li>avcodec_alloc_context3()：分配解码器上下文。</li>
<li>avcodec_find_decoder()：根据 ID 查找解码器。</li>
<li>avcodec_find_decoder_by_name()：根据解码器名字查找解码器。</li>
<li>avcodec_open2()：打开编解码器。</li>
<li><del>avcodec_decode_video2()：解码一帧视频数据。</del></li>
<li><del>avcodec_decode_audio4()：解码一帧音频数据。</del></li>
<li>avcodec_send_packet()：发送编码数据包。</li>
<li>avcodec_receive_frame()：接收解码后数据。</li>
<li>avcodec_free_context()：释放解码器上下文，包含了 avcodec_close()。</li>
<li>avcodec_close()：关闭解码器。</li>
</ul>
<h2 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h2><pre class="mermaid">graph TB
    A[分配编解码器上下文 avcodec_alloc_context3]-->B[将码流中的编解码器信息拷贝到 AVCodecContex avcodec_parameters_to_context]
    B-->C[根据编解码器信息查找相应的解码器或指定解码器 avcodec_find_decoder/avcodec_find_decoder_by_name]
    C-->D[打开编解码器并关联到 AVCodecContex avcodec_open2]
    D-->E[循环向解码器发送数据包 avcodec_send_packet]
    E-->F[循环接收解码后的帧 avcodec_receive_frame]
    F-->G[关闭解码器和释放上下文avcodec_close avcodec_free_context]</pre>

<h1 id="FFmpeg组件注册方式"><a href="#FFmpeg组件注册方式" class="headerlink" title="FFmpeg组件注册方式"></a>FFmpeg组件注册方式</h1><h2 id="FFmpeg3-x组件注册方式"><a href="#FFmpeg3-x组件注册方式" class="headerlink" title="FFmpeg3.x组件注册方式"></a>FFmpeg3.x组件注册方式</h2><p>使用 ffmpeg，首先要执行 av_register_all，把全局的解码器、编码器等结构体注册到<strong>各自全局的对象链表里</strong>，以便后面查找调用。</p>
<h2 id="FFmpeg4-x组件注册方式"><a href="#FFmpeg4-x组件注册方式" class="headerlink" title="FFmpeg4.x组件注册方式"></a>FFmpeg4.x组件注册方式</h2><p>FFmpeg内部去做，不需要用户调用API去注册。</p>
<ul>
<li>以codec编解码器为例：<ul>
<li>在configure的时候生成要注册的组件</li>
<li>.&#x2F;configure:7203:print_enabled_components libavcodec&#x2F;codec_list.c AVCodec codec_list $CODEC_LIST 这里会生成一个codec_list.c 文件，里面只有 static const AVCodec * const codec_list[] 数组。</li>
<li>在libavcodec&#x2F;allcodecs.c 将 static const AVCodec * const codec_list[] 的编解码器用链表的方式组织起来。</li>
</ul>
</li>
</ul>
<h1 id="FFmpeg数据结构"><a href="#FFmpeg数据结构" class="headerlink" title="FFmpeg数据结构"></a>FFmpeg数据结构</h1><h2 id="常见数据结构简介"><a href="#常见数据结构简介" class="headerlink" title="常见数据结构简介"></a>常见数据结构简介</h2><ul>
<li><p>AVFormatContext：封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。</p>
</li>
<li><p>AVInputFormat：demuxer，每种封装格式（例如 FLV, MKV, MP4, AVI）对应一个该结构体。</p>
</li>
<li><p>AVOutputFormat：muxer。</p>
</li>
<li><p>AVStream：视频文件中每个视频（音频）流对应一个该结构体。</p>
</li>
<li><p>AVCodecContext：编解码器上下文结构体，保存了视频（音频）编解码相关信息。</p>
</li>
<li><p>AVCodec：每种视频（音频）编解码器(例如 H.264 解码器)对应一个该结构体。</p>
</li>
<li><p>AVPacket：存储一帧压缩编码数据。</p>
</li>
<li><p>AVFrame：存储一帧解码后像素（采样）数据。</p>
</li>
</ul>
<h2 id="FFmpeg数据结构之间的关系"><a href="#FFmpeg数据结构之间的关系" class="headerlink" title="FFmpeg数据结构之间的关系"></a>FFmpeg数据结构之间的关系</h2><ul>
<li><p>面向对象的思想，包含数据结构和方法的结构体。</p>
</li>
<li><p>AVFormatContext 和 AVInputFormat 之间的关系</p>
<ul>
<li><p>AVFormatContext API 用户调用，AVInputFormat 主要是 FFMPEG 内部调用。</p>
</li>
<li><p>AVFormatContext 封装格式上下文结构体——&gt;数据。</p>
</li>
<li><p>AVInputFormat 每种封装格式（例如 FLV, MKV, MP4）——&gt;方法。</p>
</li>
</ul>
</li>
<li><p>AVCodecContext 和 AVCodec 之间的关系</p>
<ul>
<li>AVCodecContext 编码器上下文结构体——&gt;数据。</li>
<li>AVCodec 每种视频（音频）编解码器——&gt;方法。</li>
</ul>
</li>
<li><p>AVFormatContext，AVStream 和 AVCodecContext 之间的关系</p>
<ul>
<li>AVFormatContext 包含多种 AVStream。</li>
<li>AVStream 包含 AVCodecParameters，通过 avformat_find_stream_info() 查找相应流参数。</li>
<li>通过 avcodec_parameters_to_context() 拷贝 AVCodecParameters 到 AVCodecContext 中。</li>
</ul>
</li>
<li><p>AVPacket 和 AVFrame 之间的关系</p>
<ul>
<li>AVPacket 解码获得 AVFrame。</li>
<li>AVFrame 编码获得 AVPacket。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/08/23/SDL%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/23/SDL%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">SDL音视频渲染</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-23 22:18:07" itemprop="dateCreated datePublished" datetime="2023-08-23T22:18:07+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:37:57" itemprop="dateModified" datetime="2023-12-30T22:37:57+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SDL/" itemprop="url" rel="index"><span itemprop="name">SDL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SDL-音视频渲染"><a href="#SDL-音视频渲染" class="headerlink" title="SDL 音视频渲染"></a>SDL 音视频渲染</h1><h2 id="SDL-介绍"><a href="#SDL-介绍" class="headerlink" title="SDL 介绍"></a>SDL 介绍</h2><p>SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X等）的应用软件。目前SDL多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。</p>
<p><strong>SDL 库分类</strong></p>
<p>SDL库分为 Video、Audio、CD-ROM、Joystick 和 Timer 等若干子系统，除此之外，还有一些单独的官方扩充函数库。</p>
<p>这些库由官方网站提供，并包含在官方文档中，共同组成了SDL的“标准库”：</p>
<ul>
<li>SDL_image ： 支持时下流行的图像格式，如BMP、PPM、XPM、 PCX、GIF、JPEG、PNG、TGA。</li>
<li>SDL_mixer：更多的声音输出函数以及更多的声音格式支持。</li>
<li>SDL_net：网络支持。</li>
<li>SDL_ttf：TrueType字体渲染支持。</li>
<li>SDL_rtf：简单的RTF渲染支持。</li>
</ul>
<p><strong>SDL 子系统分类</strong></p>
<p>SDL 按照功能可以分成下列数个子系统（subsystem）：</p>
<ul>
<li>SDL_INIT_TIMER：定时器</li>
<li>SDL_INIT_AUDIO：音频</li>
<li>SDL_INIT_VIDEO：视频</li>
<li>SDL_INIT_JOYSTICK：摇杆</li>
<li>SDL_INIT_HAPTIC：触摸屏</li>
<li>SDL_INIT_GAMECONTROLLER：游戏控制器</li>
<li>SDL_INIT_EVENTS：事件</li>
<li>SDL_INIT_EVERYTHING：包含上述所有选项</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line">    window = SDL_CreateWindow(<span class="string">&quot;Basic Window&quot;</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE</span><br><span class="line">                              );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        SDL_Log(<span class="string">&quot;Unable to create window: %s&quot;</span>, SDL_GetError());</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> quit = <span class="literal">false</span>;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">        <span class="keyword">while</span> (SDL_PollEvent(&amp;event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class="line">                quit = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SDL-基本API"><a href="#SDL-基本API" class="headerlink" title="SDL 基本API"></a>SDL 基本API</h2><p><strong>SDL 初始化相关方法</strong></p>
<ul>
<li>SDL_Init(): 初始化SDL</li>
<li>SDL_CreateWindow(): 创建窗口（Window）</li>
<li>SDL_CreateRenderer(): 基于窗口创建渲染器（Render）</li>
<li>SDL_CreateTexture(): 创建纹理（Texture）</li>
</ul>
<p><strong>SDL 渲染数据相关方法</strong></p>
<ul>
<li>SDL_UpdateTexture(): 设置纹理的数据</li>
<li>SDL_RenderCopy(): 纹理复制给渲染器</li>
<li>SDL_RenderPresent(): 显示</li>
</ul>
<p><strong>SDL 销毁释放资源相关方法</strong></p>
<ul>
<li>SDL_DestroyTexture(tex) : 释放纹理资源</li>
<li>SDL_DestroyRenderer(ren) : 释放渲染器</li>
<li>SDL_DestroyWindow(win) : 释放窗口 </li>
<li>SDL_Quit() : 关闭所有SDL子系统</li>
</ul>
<h2 id="SDL-绘制图形"><a href="#SDL-绘制图形" class="headerlink" title="SDL 绘制图形"></a>SDL 绘制图形</h2><p>SDL中绘制基本图形的 API主要是 点、线、矩形、填充矩形。其它图形都可以通过 点、线、矩形组合出来。</p>
<p><strong>设置画笔的颜色</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_SetRenderDrawColor</span><span class="params">(SDL_Renderer* renderer,</span></span><br><span class="line"><span class="params">                           Uint8   r,</span></span><br><span class="line"><span class="params">                           Uint8   g, </span></span><br><span class="line"><span class="params">                           Uint8   b,</span></span><br><span class="line"><span class="params">                           Uint8   a)</span></span><br></pre></td></tr></table></figure>

<p>设置好画笔的颜色后，我们就可以开始绘制了我们想要的图形了，如果需要修改绘制颜色的色值，可以再次调用此函数即可。</p>
<p><strong>绘制一个点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderDrawPoint</span><span class="params">(SDL_Renderer* renderer, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br></pre></td></tr></table></figure>

<p>渲染器为参数renderer，绘制的坐标为x，y。</p>
<p><strong>绘制多个点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderDrawPoints</span><span class="params">(SDL_Renderer* renderer, <span class="type">const</span> SDL_Point* points, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>

<p>其中points为绘制的点的数组，count为要绘制的点的个数。</p>
<p><strong>绘制直线</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderDrawLine</span><span class="params">(SDL_Renderer* renderer,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> x1,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> y1,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> x2,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> y2)</span></span><br></pre></td></tr></table></figure>

<p>渲染器为参数renderer，两个端点的坐标为（x1，y1）和（x2，y2）。</p>
<p><strong>绘制多条线</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderDrawLines</span><span class="params">(SDL_Renderer* renderer, <span class="type">const</span> SDL_Point* points, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>

<p>该函数会将使用两个相邻的点之间进行连线。</p>
<p><strong>绘制矩形</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderDrawRect</span><span class="params">(SDL_Renderer* renderer, <span class="type">const</span> SDL_Rect* rect)</span></span><br></pre></td></tr></table></figure>

<p>rect: 是要绘制的一块区域。它包括x,y,w,h这些元素。</p>
<p><strong>填充矩形</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderFillRect</span><span class="params">(SDL_Renderer* renderer, <span class="type">const</span> SDL_Rect* rect)</span></span><br></pre></td></tr></table></figure>

<p>使用指定的色彩填充一块矩形。rect: 是要绘制的一块区域，包括x,y,w,h这些元素。</p>
<p><strong>填充多块矩形</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderDrawRects</span><span class="params">(SDL_Renderer* renderer, <span class="type">const</span> SDL_Rect* rects, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>

<p>其中 rects 为矩形数组，count为矩形个数。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SDL.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POINTS_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> SDL_Point points[POINTS_COUNT] = &#123;</span><br><span class="line">    &#123;<span class="number">320</span>, <span class="number">200</span>&#125;,</span><br><span class="line">    &#123;<span class="number">300</span>, <span class="number">240</span>&#125;,</span><br><span class="line">    &#123;<span class="number">340</span>, <span class="number">240</span>&#125;,</span><br><span class="line">    &#123;<span class="number">320</span>, <span class="number">200</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> SDL_Rect bigrect = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">540</span>, <span class="number">380</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">&quot;Window&quot;</span>,                 </span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_SHOWN);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not create window: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SDL_DestroyWindow(window);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not create renderer: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>); </span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, SDL_ALPHA_OPAQUE);</span><br><span class="line">    SDL_RenderDrawLines(renderer, points, POINTS_COUNT);</span><br><span class="line">    </span><br><span class="line">    SDL_Rect rect = &#123; <span class="number">200</span>, <span class="number">300</span>, <span class="number">100</span>, <span class="number">100</span> &#125;;</span><br><span class="line">    SDL_RenderDrawRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    SDL_RenderFillRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    SDL_RenderFillRect(renderer, &amp;bigrect);</span><br><span class="line"></span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line"></span><br><span class="line">    SDL_Delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    SDL_DestroyRenderer(renderer);</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SDL-纹理渲染"><a href="#SDL-纹理渲染" class="headerlink" title="SDL 纹理渲染"></a>SDL 纹理渲染</h2><p><strong>SDL 渲染相关对象</strong></p>
<ul>
<li>SDL 视频渲染主要涉及到四个对象：SDL_Window、SDL_Render、SDL_Texture和SDL_Surface。</li>
</ul>
<p><strong>SDL_Surface vs SDL_Texture</strong></p>
<ul>
<li><p>SDL_Render对象中有一个视频缓冲区，该缓冲区我们称之为SDL_Surface，它是按照像素存放图像的。我们一般把真彩色的像素称为RGB24数据。也就是说，每一个像素由24位组成，每8位代表一种颜色，像素的最终颜色是由RGB三种颜色混合而成的。</p>
</li>
<li><p>SDL_Texture 与SDL_Surface 相似，也是一种缓冲区。只不过它存放的不是真正的像素数据，而是存放的图像的描述信息。这些描述信息通过OpenGL、D3D 或 Metal等技术操作GPU，从而绘制出与SDL_Surface一样的图形，且效率更高。</p>
</li>
</ul>
<p><strong>SDL_Window vs SDL_Render</strong></p>
<ul>
<li><p>SDL_Window代表的是窗口的逻辑概念，它是存放在主内存中的一个对象。所以当我们调用SDL API 创建窗口后，它并不会被显示出来。</p>
</li>
<li><p>SDL_Render 是渲染器，它也是主存中的一个对象。对Render操作时实际上分为两个阶段：</p>
<ul>
<li>渲染阶段：在该阶段，用户可以画各种图形渲染到SDL_Surface或SDL_Texture 中。</li>
<li>显示阶段：以SDL_Texture为数据，通过OpenGL操作GPU，最终将 SDL_Surfce 或SDL_Texture中的数据输出到显示器上。</li>
</ul>
</li>
</ul>
<p><strong>SDL渲染纹理的步骤和API</strong></p>
<ul>
<li>创建SDL_Texture</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_Texture* <span class="title function_">SDL_CreateTexture</span><span class="params">(SDL_Renderer* renderer,</span></span><br><span class="line"><span class="params">                               Uint32 format, </span></span><br><span class="line"><span class="params">                               <span class="type">int</span> access,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> w,                </span></span><br><span class="line"><span class="params">                               <span class="type">int</span> h)</span></span><br></pre></td></tr></table></figure>

<p>format: 指明像素格式，可以是YUV，也可以是RGB。</p>
<p>access: 指明Texture的类型。可以是 Stream(视频)，也可以是Target一般的类型。</p>
<ul>
<li>渲染SDL_Texture</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_RenderCopy</span><span class="params">(SDL_Renderer* renderer,</span></span><br><span class="line"><span class="params">                   SDL_Texture* texture,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> SDL_Rect* srcrect,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> SDL_Rect* dstrect)</span></span><br></pre></td></tr></table></figure>

<p>srcrect: 指定 Texture 中要渲染的一部分。如果将 Texture全部输出，可以设置它为 NULL。</p>
<p>dstrect: 指定输出的空间大小。</p>
<ul>
<li>销毁SDL_Texture</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_DestroyTexture</span><span class="params">(SDL_Texture* texture)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_Window* window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer* renderer = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Texture* texture = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    rect.w = <span class="number">50</span>;</span><br><span class="line">    rect.h = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">&quot;window&quot;</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于窗口创建渲染器</span></span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        SDL_DestroyWindow(window);</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于渲染器创建纹理</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                 SDL_PIXELFORMAT_RGBA8888,</span><br><span class="line">                                 SDL_TEXTUREACCESS_TARGET,</span><br><span class="line">                                 <span class="number">640</span>,</span><br><span class="line">                                 <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!texture) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">        SDL_DestroyWindow(window);</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_Event e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> quit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (quit != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (SDL_PollEvent(&amp;e)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.type == SDL_QUIT) &#123;</span><br><span class="line">                quit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rect.x = rand() % <span class="number">600</span>;</span><br><span class="line">        rect.y = rand() % <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置渲染目标为纹理</span></span><br><span class="line">        SDL_SetRenderTarget(renderer, texture);</span><br><span class="line">        <span class="comment">//纹理背景为黑色</span></span><br><span class="line">        SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="comment">//设置的颜色把整个渲染器清空</span></span><br><span class="line">        SDL_RenderClear(renderer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制一个矩形</span></span><br><span class="line">        SDL_RenderDrawRect(renderer, &amp;rect);</span><br><span class="line">        <span class="comment">//设置矩形颜色</span></span><br><span class="line">        SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="comment">//填充矩形</span></span><br><span class="line">        SDL_RenderFillRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复默认，渲染目标为窗口</span></span><br><span class="line">        SDL_SetRenderTarget(renderer, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//将纹理数据复制给渲染目标</span></span><br><span class="line">        SDL_RenderCopy(renderer, texture, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出到目标窗口</span></span><br><span class="line">        SDL_RenderPresent(renderer);</span><br><span class="line">        SDL_Delay(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_DestroyTexture(texture);</span><br><span class="line">    SDL_DestroyRenderer(renderer);</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    SDL_Quit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SDL-事件处理"><a href="#SDL-事件处理" class="headerlink" title="SDL 事件处理"></a>SDL 事件处理</h2><p><strong>SDL 事件处理机制原理</strong></p>
<p>SDL事件就是键盘事件，鼠标事件，窗口事件等。SDL将所有事件都存放在一个队列中。所有对事件的操作，其实就是对队列的操作。</p>
<p>而SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。</p>
<p><strong>SDL 操作事件队列的API</strong></p>
<ul>
<li>SDL_PollEvent: 将队列头中的事件抛出来。</li>
<li>SDL_WaitEvent: 当队列中有事件时，抛出事件。否则处于阻塞状态，释放 CPU。</li>
<li>SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。</li>
<li>SDL_PeekEvent: 从队列中取出事件，但该事件不从队列中删除。</li>
<li>SDL_PushEvent: 向队列中插入事件。</li>
</ul>
<p><strong>SDL 处理事件的API</strong></p>
<ul>
<li>SDL_WindowEvent : Window窗口相关的事件。</li>
<li>SDL_KeyboardEvent : 键盘相关的事件。</li>
<li>SDL_MouseMotionEvent : 鼠标移动相关的事件。</li>
<li>SDL_QuitEvent : 退出事件。</li>
<li>SDL_UserEvent : 用户自定义事件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_QUIT_EVENT    (SDL_USEREVENT + 2) <span class="comment">// 用户自定义事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(</span><br><span class="line">        <span class="string">&quot;Basic window&quot;</span>,</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">        <span class="number">640</span>,</span><br><span class="line">        <span class="number">480</span>,</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line"></span><br><span class="line">    SDL_Event event;</span><br><span class="line">    <span class="type">int</span> b_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span> (event.type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> SDL_KEYDOWN:	<span class="comment">/* 键盘事件 */</span></span><br><span class="line">            <span class="keyword">switch</span> (event.key.keysym.sym)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SDLK_a:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key down a\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SDLK_s:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key down s\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SDLK_d:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key down d\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SDLK_q:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key down q and push quit event\n&quot;</span>);</span><br><span class="line">                SDL_Event event_q;</span><br><span class="line">                event_q.type = FF_QUIT_EVENT;</span><br><span class="line">                SDL_PushEvent(&amp;event_q);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key down 0x%x\n&quot;</span>, event.key.keysym.sym);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDL_MOUSEBUTTONDOWN:			<span class="comment">/* 鼠标按下事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (event.button.button == SDL_BUTTON_LEFT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;mouse down left\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(event.button.button == SDL_BUTTON_RIGHT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;mouse down right\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;mouse down %d\n&quot;</span>, event.button.button);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDL_MOUSEMOTION:		<span class="comment">/* 鼠标移动事件 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mouse movie (%d,%d)\n&quot;</span>, event.button.x, event.button.y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;receive quit event\n&quot;</span>);</span><br><span class="line">            b_exit = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b_exit)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_DestroyRenderer(renderer);</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SDL-多线程与锁机制"><a href="#SDL-多线程与锁机制" class="headerlink" title="SDL 多线程与锁机制"></a>SDL 多线程与锁机制</h2><p><strong>SDL 线程与锁API</strong></p>
<ul>
<li><p>线程创建：SDL_CreateThread　</p>
</li>
<li><p>线程等待：SDL_WaitThead</p>
</li>
<li><p>互斥锁：SDL_CreateMutex &#x2F; SDL_DestroyMutex</p>
</li>
<li><p>锁定互斥：SDL_LockMutex &#x2F; SDL_UnlockMutex</p>
</li>
<li><p>条件变量（信号量）：SDL_CreateCond &#x2F; SDL_DestoryCond</p>
</li>
<li><p>条件变量（信号量）等待 &#x2F; 通知 ：SDL_CondWait &#x2F; SDL_CondSingal</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SDL_mutex *s_lock = <span class="literal">NULL</span>;</span><br><span class="line">SDL_cond *s_cond = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">thread_work</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_LockMutex(s_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;	&lt;============thread_work sleep\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来测试获取锁</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;	&lt;============thread_work wait\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放s_lock资源，并等待signal。之所以释放s_lock是让别的线程能够获取到s_lock</span></span><br><span class="line">    SDL_CondWait(s_cond, s_lock); <span class="comment">//另一个线程(1)发送signal和(2)释放lock后，这个函数退出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;	&lt;===========thread_work receive signal, continue to do ~_~!!!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;	&lt;===========thread_work end\n&quot;</span>);</span><br><span class="line">    SDL_UnlockMutex(s_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    s_lock = SDL_CreateMutex();</span><br><span class="line">    s_cond = SDL_CreateCond();</span><br><span class="line">    SDL_Thread *t = SDL_CreateThread(thread_work, <span class="string">&quot;thread_work&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!t) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,SDL_GetError);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main execute =====&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main SDL_LockMutex(s_lock) before ====================&gt;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取锁，但是子线程还拿着锁</span></span><br><span class="line">    SDL_LockMutex(s_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main ready send signal====================&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main SDL_CondSignal(s_cond) before ====================&gt;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送信号，唤醒等待的线程</span></span><br><span class="line">    SDL_CondSignal(s_cond);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main SDL_CondSignal(s_cond) after ====================&gt;\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁，让其他线程可以拿到锁</span></span><br><span class="line">    SDL_UnlockMutex(s_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main SDL_UnlockMutex(s_lock) after ====================&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SDL_WaitThread(t, <span class="literal">NULL</span>);</span><br><span class="line">    SDL_DestroyMutex(s_lock);</span><br><span class="line">    SDL_DestroyCond(s_cond);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SDL-YUV播放"><a href="#SDL-YUV播放" class="headerlink" title="SDL YUV播放"></a>SDL YUV播放</h2><p><strong>视频播放流程</strong></p>
<ul>
<li><p>创建窗口，渲染器和纹理对象</p>
</li>
<li><p>循环读取本地YUV数据</p>
</li>
<li><p>更新纹理</p>
</li>
<li><p>清空屏幕</p>
</li>
<li><p>将纹理拷贝到渲染器</p>
</li>
<li><p>显示</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义消息类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFRESH_EVENT   (SDL_USEREVENT + 1)     <span class="comment">// 请求画面刷新事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUIT_EVENT      (SDL_USEREVENT + 2)     <span class="comment">// 退出事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义分辨率</span></span><br><span class="line"><span class="comment">//YUV像素分辨率</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YUV_WIDTH   320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YUV_HEIGHT  240</span></span><br><span class="line"><span class="comment">//定义YUV格式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YUV_FORMAT  SDL_PIXELFORMAT_IYUV</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出标志 = 1则退出</span></span><br><span class="line"><span class="type">int</span> s_thread_exit = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">refresh_video_timer</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!s_thread_exit) &#123;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        event.type = REFRESH_EVENT;</span><br><span class="line">        SDL_PushEvent(&amp;event);</span><br><span class="line">        SDL_Delay(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_thread_exit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push quit event</span></span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = QUIT_EVENT;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_Event event;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Texture *texture = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Thread *timer_thread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//YUV420P，即是SDL_PIXELFORMAT_IYUV</span></span><br><span class="line">    <span class="type">uint32_t</span> pixformat = YUV_FORMAT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分辨率</span></span><br><span class="line">    <span class="comment">//1. YUV的分辨率</span></span><br><span class="line">    <span class="type">int</span> video_width = YUV_WIDTH;</span><br><span class="line">    <span class="type">int</span> video_height = YUV_HEIGHT;</span><br><span class="line">    <span class="comment">//2.显示窗口的分辨率</span></span><br><span class="line">    <span class="type">int</span> win_width = YUV_WIDTH;</span><br><span class="line">    <span class="type">int</span> win_height = YUV_WIDTH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//YUV文件句柄</span></span><br><span class="line">    FILE *video_fd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *yuv_path = <span class="string">&quot;yuv420p_320x240.yuv&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> video_buff_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *video_buf = <span class="literal">NULL</span>; <span class="comment">//读取数据后先把放到buffer里面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们测试的文件是YUV420P格式</span></span><br><span class="line">    <span class="type">uint32_t</span> y_frame_len = video_width * video_height;</span><br><span class="line">    <span class="type">uint32_t</span> u_frame_len = video_width * video_height / <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint32_t</span> v_frame_len = video_width * video_height / <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint32_t</span> yuv_frame_len = y_frame_len + u_frame_len + v_frame_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">&quot;Simplest YUV Player&quot;</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              video_width, video_height,</span><br><span class="line">                              SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!window) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SDL: could not create window, err:%s\n&quot;</span>,SDL_GetError());</span><br><span class="line">        <span class="keyword">goto</span> _FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基于窗口创建渲染器</span></span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 基于渲染器创建纹理</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                pixformat,</span><br><span class="line">                                SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                video_width,</span><br><span class="line">                                video_height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    video_buf = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(yuv_frame_len);</span><br><span class="line">    <span class="keyword">if</span>(!video_buf) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to alloce yuv frame space!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开YUV文件</span></span><br><span class="line">    video_fd = fopen(yuv_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>( !video_fd ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open yuv file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求刷新线程</span></span><br><span class="line">    timer_thread = SDL_CreateThread(refresh_video_timer,</span><br><span class="line">                                    <span class="literal">NULL</span>,</span><br><span class="line">                                    <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 收取SDL系统里面的事件</span></span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 画面刷新事件</span></span><br><span class="line">        <span class="keyword">if</span>(event.type == REFRESH_EVENT) &#123;</span><br><span class="line">            video_buff_len = fread(video_buf, <span class="number">1</span>, yuv_frame_len, video_fd);</span><br><span class="line">            <span class="keyword">if</span>(video_buff_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Failed to read data from yuv file!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> _FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置纹理的数据 video_width = 320， plane</span></span><br><span class="line">            SDL_UpdateTexture(texture, <span class="literal">NULL</span>, video_buf, video_width);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示区域，可以通过修改w和h进行缩放</span></span><br><span class="line">            rect.x = <span class="number">0</span>;</span><br><span class="line">            rect.y = <span class="number">0</span>;</span><br><span class="line">            <span class="type">float</span> w_ratio = win_width * <span class="number">1.0</span> /video_width;</span><br><span class="line">            <span class="type">float</span> h_ratio = win_height * <span class="number">1.0</span> /video_height;</span><br><span class="line">            rect.w = video_width * w_ratio;</span><br><span class="line">            rect.h = video_height * h_ratio;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除当前显示</span></span><br><span class="line">            SDL_RenderClear(renderer);</span><br><span class="line">            <span class="comment">// 将纹理的数据拷贝给渲染器</span></span><br><span class="line">            SDL_RenderCopy(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">            <span class="comment">// 显示</span></span><br><span class="line">            SDL_RenderPresent(renderer);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.type == SDL_WINDOWEVENT) &#123;</span><br><span class="line">            <span class="comment">//If Resize</span></span><br><span class="line">            SDL_GetWindowSize(window, &amp;win_width, &amp;win_height);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SDL_WINDOWEVENT win_width:%d, win_height:%d\n&quot;</span>, win_width, win_heig);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.type == SDL_QUIT) &#123; </span><br><span class="line">            <span class="comment">//退出事件</span></span><br><span class="line">            s_thread_exit = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.type == QUIT_EVENT) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">_FAIL:</span><br><span class="line">    <span class="comment">// 保证线程能够退出</span></span><br><span class="line">    s_thread_exit = <span class="number">1</span>;      </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span>(timer_thread)</span><br><span class="line">        SDL_WaitThread(timer_thread, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span>(video_buf)</span><br><span class="line">        <span class="built_in">free</span>(video_buf);</span><br><span class="line">    <span class="keyword">if</span>(video_fd)</span><br><span class="line">        fclose(video_fd);</span><br><span class="line">    <span class="keyword">if</span>(texture)</span><br><span class="line">        SDL_DestroyTexture(texture);</span><br><span class="line">    <span class="keyword">if</span>(renderer)</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    <span class="keyword">if</span>(window)</span><br><span class="line">        SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SDL-PCM播放"><a href="#SDL-PCM播放" class="headerlink" title="SDL PCM播放"></a>SDL PCM播放</h2><p><strong>SDL 操作音频API</strong></p>
<ul>
<li>使用SDL_OpenAudio()打开音频设备。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_OpenAudio</span><span class="params">(SDL_AudioSpec * desired, SDL_AudioSpec * obtained)</span></span><br></pre></td></tr></table></figure>

<p>desired：期望的参数。<br>obtained：实际音频设备的参数，一般情况下设置为NULL即可。</p>
<p>其中SDL_AudioSpec结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_AudioSpec</span> &#123;</span></span><br><span class="line">　　<span class="type">int</span> freq; <span class="comment">/**&lt; DSP frequency -- samples per second */</span></span><br><span class="line">　　SDL_AudioFormat format; <span class="comment">/**&lt; Audio data format */</span></span><br><span class="line">　　Uint8 channels; <span class="comment">/**&lt; Number of channels: 1 mono, 2 stereo */</span></span><br><span class="line">　　Uint8 silence; <span class="comment">/**&lt; Audio buffer silence value (calculated) */</span></span><br><span class="line">　　Uint16 samples; <span class="comment">/**&lt; Audio buffer size in samples (power of 2) */</span></span><br><span class="line">　　Uint16 padding; <span class="comment">/**&lt; Necessary for some compile environments */</span></span><br><span class="line">　　Uint32 size; <span class="comment">/**&lt; Audio buffer size in bytes (calculated) */</span></span><br><span class="line">　　SDL_AudioCallback callback;</span><br><span class="line">　　<span class="type">void</span> *userdata;</span><br><span class="line">&#125; SDL_AudioSpec;</span><br></pre></td></tr></table></figure>

<p>其中包含了关于音频各种参数：</p>
<ul>
<li>freq：音频数据的采样率。常用的有48000,44100等。</li>
<li>format：音频数据的格式。举例几种格式：</li>
<li>AUDIO_U16SYS：Unsigned 16-bit samples</li>
<li>AUDIO_S16SYS：Signed 16-bit samples</li>
<li>AUDIO_S32SYS：32-bit integer samples</li>
<li>AUDIO_F32SYS：32-bit floating point samples</li>
<li>channels：声道数。例如单声道取值为1，立体声取值为2。</li>
<li>silence：设置静音的值。</li>
<li>samples：音频缓冲区中的采样个数，要求必须是2的n次方。</li>
<li>padding：考虑到兼容性的一个参数。</li>
<li>size：音频缓冲区的大小，以字节为单位。</li>
<li>callback：填充音频缓冲区的回调函数。</li>
<li>userdata：用户自定义的数据。</li>
</ul>
<p>在这里说明一下填充音频缓冲区的回调函数的作用。当音频设备需要更多数据的时候会调用该回调函数。</p>
<p>回调函数的格式要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (SDLCALL * SDL_AudioCallback) (<span class="type">void</span> *userdata, Uint8 * stream, <span class="type">int</span> len)</span><br></pre></td></tr></table></figure>

<p>回调函数的参数含义如下：</p>
<ul>
<li>userdata：SDL_AudioSpec结构中的用户自定义数据，一般情况下可以不用。</li>
<li>stream：该指针指向需要填充的音频缓冲区。</li>
<li>len：音频缓冲区的大小（以字节为单位）。</li>
</ul>
<p>在回调函数中可以使用SDL_MixAudio()完成混音等工作。注意：SDL2中必须首先使用SDL_memset()将stream中的数据设置为0。</p>
<ul>
<li>播放音频数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> SDLCALL <span class="title function_">SDL_PauseAudio</span><span class="params">(<span class="type">int</span> pause_on)</span></span><br></pre></td></tr></table></figure>

<p>当pause_on设置为0的时候即可开始播放音频数据。设置为1的时候，将会播放静音的值。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次读取2帧数据, 以1024个采样点一帧 2通道 16bit采样点为例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCM_BUFFER_SIZE (1024*2*2*2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频PCM数据缓存</span></span><br><span class="line"><span class="type">static</span> Uint8 *s_audio_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 目前读取的位置</span></span><br><span class="line"><span class="type">static</span> Uint8 *s_audio_pos = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 缓存结束位置</span></span><br><span class="line"><span class="type">static</span> Uint8 *s_audio_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//音频设备回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_audio_pcm</span><span class="params">(<span class="type">void</span> *udata, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="keyword">if</span>(s_audio_pos &gt;= s_audio_end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> remain_buffer_len = s_audio_end - s_audio_pos;</span><br><span class="line">    len = (len &lt; remain_buffer_len) ? len : remain_buffer_len;</span><br><span class="line">    <span class="comment">// 拷贝数据到stream并调整音量</span></span><br><span class="line">    SDL_MixAudio(stream, s_audio_pos, len, SDL_MIX_MAXVOLUME/<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, len);</span><br><span class="line">    s_audio_pos += len;  <span class="comment">// 移动缓存指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取PCM文件</span></span><br><span class="line"><span class="comment">// ffmpeg -i input.mp4 -t 20 -codec:a pcm_s16le -ar 44100 -ac 2 -f s16le 44100_16bit_2ch.pcm</span></span><br><span class="line"><span class="comment">// 测试PCM文件</span></span><br><span class="line"><span class="comment">// ffplay -ar 44100 -ac 2 -f s16le 44100_16bit_2ch.pcm</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    FILE *audio_fd = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_AudioSpec spec;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = <span class="string">&quot;44100_16bit_2ch.pcm&quot;</span>;</span><br><span class="line">    <span class="comment">// 每次缓存的长度</span></span><br><span class="line">    <span class="type">size_t</span> read_buffer_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SDL_Init(SDL_INIT_AUDIO)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开PCM文件</span></span><br><span class="line">    audio_fd = fopen(path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!audio_fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open pcm file!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> _FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_audio_buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(PCM_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 音频参数设置SDL_AudioSpec</span></span><br><span class="line">    spec.freq = <span class="number">44100</span>;          <span class="comment">// 采样频率</span></span><br><span class="line">    spec.format = AUDIO_S16SYS; <span class="comment">// 采样点格式</span></span><br><span class="line">    spec.channels = <span class="number">2</span>;          <span class="comment">// 2通道</span></span><br><span class="line">    spec.silence = <span class="number">0</span>;</span><br><span class="line">    spec.samples = <span class="number">1024</span>;       <span class="comment">// 23.2ms 每次读取的采样数量，多久产生一次回调和 samples</span></span><br><span class="line">    spec.callback = fill_audio_pcm; <span class="comment">// 回调函数</span></span><br><span class="line">    spec.userdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开音频设备</span></span><br><span class="line">    <span class="keyword">if</span>(SDL_OpenAudio(&amp;spec, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">       	<span class="built_in">printf</span>(<span class="string">&quot;Failed to open audio device, %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">goto</span> _FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//play audio</span></span><br><span class="line">    SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//从文件读取PCM数据</span></span><br><span class="line">        read_buffer_len = fread(s_audio_buf, <span class="number">1</span>, PCM_BUFFER_SIZE, audio_fd);</span><br><span class="line">        <span class="keyword">if</span>(read_buffer_len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data_count += read_buffer_len; <span class="comment">//统计读取的数据总字节数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;now playing %10d bytes data.\n&quot;</span>, data_count);</span><br><span class="line">        s_audio_end = s_audio_buf + read_buffer_len;    <span class="comment">//更新buffer的结束位置</span></span><br><span class="line">        s_audio_pos = s_audio_buf;  <span class="comment">//更新buffer的起始位置</span></span><br><span class="line">        <span class="comment">//the main thread wait for a moment</span></span><br><span class="line">        <span class="keyword">while</span>(s_audio_pos &lt; s_audio_end) &#123;</span><br><span class="line">            <span class="comment">//等待PCM数据消耗</span></span><br><span class="line">            SDL_Delay(<span class="number">10</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;play PCM finish\n&quot;</span>);</span><br><span class="line">    <span class="comment">//关闭音频设备</span></span><br><span class="line">    SDL_CloseAudio();</span><br><span class="line"></span><br><span class="line">_FAIL:</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="keyword">if</span>(s_audio_buf)</span><br><span class="line">        <span class="built_in">free</span>(s_audio_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(audio_fd)</span><br><span class="line">        fclose(audio_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出SDL</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/10460512.html">https://www.cnblogs.com/renhui/p/10460512.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/08/20/FFmpeg%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/20/FFmpeg%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">FFmpeg命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-20 22:06:30" itemprop="dateCreated datePublished" datetime="2023-08-20T22:06:30+08:00">2023-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:51" itemprop="dateModified" datetime="2023-12-30T22:40:51+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="FFmpeg帮助文档"><a href="#FFmpeg帮助文档" class="headerlink" title="FFmpeg帮助文档"></a>FFmpeg帮助文档</h1><p><strong>ffmpeg&#x2F;ffplay&#x2F;ffprobe区别</strong></p>
<ul>
<li>ffmpeg：Hyper fast Audio and Video encoder（超快音视频编码器）</li>
<li>ffplay：Simple media player（简单媒体播放器）</li>
<li>ffprobe：Simple multimedia streams analyzer（简单多媒体流分析器）</li>
</ul>
<p><strong>ffmpeg命令查看帮助文档</strong></p>
<ul>
<li>基本信息：ffmpeg -h </li>
<li>高级信息：ffmpeg -h long</li>
<li>所有信息：ffmpeg -h full</li>
</ul>
<p><strong>ffplay命令查看帮助文档</strong></p>
<ul>
<li>所有信息：ffplay -h</li>
</ul>
<p><strong>ffprobe命令查看帮助文档</strong></p>
<ul>
<li>所有信息：ffprobe -h</li>
</ul>
<h1 id="FFplay命令"><a href="#FFplay命令" class="headerlink" title="FFplay命令"></a>FFplay命令</h1><h2 id="FFplay播放控制"><a href="#FFplay播放控制" class="headerlink" title="FFplay播放控制"></a>FFplay播放控制</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>q,ESC</td>
<td>退出播放</td>
</tr>
<tr>
<td>f,鼠标左键双击</td>
<td>全屏切换</td>
</tr>
<tr>
<td>p,SPC</td>
<td>暂停</td>
</tr>
<tr>
<td>m</td>
<td>静音切换</td>
</tr>
<tr>
<td>0,9</td>
<td>0减小音量，9增大音量</td>
</tr>
<tr>
<td>a</td>
<td>循环切换音频流</td>
</tr>
<tr>
<td>v</td>
<td>循环切换视频流</td>
</tr>
<tr>
<td>t</td>
<td>循环切换字幕流</td>
</tr>
<tr>
<td>c</td>
<td>循环切换节目</td>
</tr>
<tr>
<td>w</td>
<td>循环切换过滤器或显示模式</td>
</tr>
<tr>
<td>s</td>
<td>逐帧播放</td>
</tr>
<tr>
<td>left&#x2F;right</td>
<td>向后&#x2F;向前拖动10秒</td>
</tr>
<tr>
<td>down&#x2F;up</td>
<td>向后&#x2F;向前拖动1分钟</td>
</tr>
<tr>
<td>鼠标右键单击</td>
<td>拖动与显示宽度对应百分比的文件进行播放</td>
</tr>
</tbody></table>
<h2 id="FFplay命令选项"><a href="#FFplay命令选项" class="headerlink" title="FFplay命令选项"></a>FFplay命令选项</h2><ul>
<li>-x width 强制显示宽度。</li>
<li>-y height 强制显示高度。</li>
<li>-video_size size 帧尺寸 设置显示帧存储（WxH格），仅适用于类似原始YUV等没有包含帧大小（WxH）的视频。<ul>
<li>ffplay -pixel_format yuv420p <strong>-video_size 320x240</strong> -framerate 5 yuv420p_320x240.yuv</li>
</ul>
</li>
<li>-pixel_format format 格式设置像素格式。</li>
<li>-fs 以全屏模式启动。</li>
<li>-an 禁用音频（不播放声音）。</li>
<li>-vn 禁用视频（不播放视频）。</li>
<li>-sn 禁用字幕（不显示字幕）。</li>
<li>-ss pos 根据设置的秒进行定位拖动，注意时间单位。比如：<ul>
<li>‘55’ 55 seconds</li>
<li>‘12:03:45’ ,12 hours, 03 minutes and 45 seconds</li>
<li>‘23.189’ 23.189 second</li>
</ul>
</li>
<li>-t duration 设置播放视频&#x2F;音频长度，时间单位如 -ss选项。</li>
<li>-bytes 按字节进行定位拖动（0&#x3D;off，1&#x3D;on，**-1&#x3D;auto**）。</li>
<li>-seek_interval interval 自定义左&#x2F;右键定位拖动间隔（以秒为单位），默认值为10秒。</li>
<li>-nodisp 关闭图形化显示窗口，视频将不显示。</li>
<li>-noborder 无边框窗口。</li>
<li>-volume vol 设置起始音量。音量范围[0 ~100]。</li>
<li>-f fmt 强制使用设置的格式进行解析，比如：<ul>
<li>-f s16le</li>
</ul>
</li>
<li>-window_title title 设置窗口标题（默认为输入文件名）。</li>
<li>-loop number 设置播放循环次数。</li>
<li>-showmode mode 设置显示模式，可用的模式值：<ul>
<li>0 显示视频</li>
<li>1 显示音频波形</li>
<li>2 显示音频频谱</li>
<li>缺省为0，如果视频不存在则自动选择2</li>
</ul>
</li>
<li>-vf filtergraph 设置视频滤镜。</li>
<li>-af filtergraph 设置音频滤镜。</li>
<li>-stats 打印多个回放统计信息，包括显示流持续时间，编解码器参数，流中的当前位置，以及音频&#x2F;视频同步差值。<strong>默认情况下处于启用状态</strong>，要显式禁用它则需要指定-nostats。</li>
<li>-fast 非标准化规范的多媒体兼容优化。</li>
<li>-genpts 生成pts。</li>
<li>-sync type 同步类型 将主时钟设置为audio（type&#x3D;audio），video（type&#x3D;video）或external（type&#x3D;ext），<strong>默认是audio为主时钟</strong>。</li>
<li>-ast audio_stream_specifier 指定音频流索引，比如-ast 3，播放流索引为3的音频流。</li>
<li>-vst video_stream_specifier指定视频流索引，比如-vst 4，播放流索引为4的视频流。</li>
<li>-sst subtitle_stream_specifier 指定字幕流索引，比如-sst 5，播放流索引为5的字幕流。</li>
<li>-autoexit 视频播放完毕后退出。</li>
<li>-exitonkeydown 键盘按下任何键退出播放。</li>
<li>-exitonmousedown 鼠标按下任何键退出播放。</li>
<li>-codec:media_specifier codec_name 强制使用设置的多媒体解码器，media_specifier可用值为a（音频）， v（视频）和s字幕。比如-codec:v h264_qsv 强制视频采用h264_qsv解码。</li>
<li>-acodec codec_name 强制使用设置的音频解码器进行音频解码。</li>
<li>-vcodec codec_name 强制使用设置的视频解码器进行视频解码。</li>
<li>-scodec codec_name 强制使用设置的字幕解码器进行字幕解码。</li>
<li>-autorotate <strong>根据文件元数据自动旋转视频</strong>。值为0或1 ，默认为1。 </li>
<li>-framedrop 如果视频不同步则丢弃视频帧。当主时钟非视频时钟时默认开启。若需禁用则使用 -noframedrop。</li>
<li>-infbuf 不限制输入缓冲区大小。尽可能快地从输入中读取尽可能多的数据。播放实时流时默认启用，如果未及时读取数据，则可能会丢弃数据。此选项将不限制缓冲区的大小。若需禁用则使用-noinfbuf。</li>
</ul>
<h2 id="FFplay命令播放媒体"><a href="#FFplay命令播放媒体" class="headerlink" title="FFplay命令播放媒体"></a>FFplay命令播放媒体</h2><p><strong>播放本地文件</strong></p>
<ul>
<li>ffplay -window_title “test time” -ss 2 -t 10 -autoexit test.mp4</li>
<li>ffplay buweishui.mp3</li>
</ul>
<p><strong>播放网络流</strong></p>
<ul>
<li>ffplay -window_title “rtmp stream” rtmp:&#x2F;&#x2F;202.69.69.180:443&#x2F;webcast&#x2F;bshdlive-pc</li>
</ul>
<p><strong>强制解码器</strong></p>
<ul>
<li>mpeg4解码器：ffplay -vcodec mpeg4 test.mp4</li>
<li>h264解码器：ffplay -vcodec h264 test.mp4</li>
</ul>
<p><strong>禁用音频或视频</strong></p>
<ul>
<li>禁用音频：ffplay test.mp4 -an</li>
<li>禁用视频：ffplay test.mp4 -vn</li>
</ul>
<p><strong>播放YUV数据</strong></p>
<ul>
<li>ffplay <strong>-pixel_format</strong> <strong>yuv420p</strong> <strong>-video_size</strong> 320x240 <strong>-framerate</strong> 5 yuv420p_320x240.yuv</li>
</ul>
<p><strong>播放RGB数据</strong></p>
<ul>
<li>ffplay -pixel_format rgb24 -video_size 320x240 -i rgb24_320x240.rgb</li>
<li>ffplay -pixel_format rgb24 -video_size 320x240 -framerate 5 -i rgb24_320x240.rgb</li>
</ul>
<p><strong>播放PCM数据</strong></p>
<ul>
<li>ffplay <strong>-ar</strong> 48000 <strong>-ac</strong> 2 <strong>-f</strong> f32le 48000_2_f32le.pcm</li>
</ul>
<h2 id="FFplay简单过滤器"><a href="#FFplay简单过滤器" class="headerlink" title="FFplay简单过滤器"></a>FFplay简单过滤器</h2><p><strong>视频旋转</strong></p>
<ul>
<li>ffplay -i test.mp4 -vf transpose&#x3D;1</li>
</ul>
<p><strong>视频反转</strong></p>
<ul>
<li>ffplay test.mp4 -vf hflip</li>
<li>ffplay test.mp4 -vf vflip</li>
</ul>
<p><strong>视频旋转和反转</strong></p>
<ul>
<li>ffplay test.mp4 -vf hflip,transpose&#x3D;1</li>
</ul>
<p><strong>音频变速播放</strong></p>
<ul>
<li>ffplay -i test.mp4 -af atempo&#x3D;2</li>
</ul>
<p><strong>视频变速播放</strong></p>
<ul>
<li>ffplay -i test.mp4 -vf setpts&#x3D;PTS&#x2F;2</li>
</ul>
<p><strong>音视频同时变速</strong></p>
<ul>
<li>ffplay -i test.mp4 -vf setpts&#x3D;PTS&#x2F;2 -af atempo&#x3D;2</li>
</ul>
<h1 id="FFmpeg命令"><a href="#FFmpeg命令" class="headerlink" title="FFmpeg命令"></a>FFmpeg命令</h1><h2 id="FFmpeg命令分类查询"><a href="#FFmpeg命令分类查询" class="headerlink" title="FFmpeg命令分类查询"></a>FFmpeg命令分类查询</h2><table>
<thead>
<tr>
<th>命令参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-version</td>
<td>显示版本</td>
</tr>
<tr>
<td>-buildconf</td>
<td>显示编译配置</td>
</tr>
<tr>
<td>-formats</td>
<td>显示可用格式（muxers+demuxers）</td>
</tr>
<tr>
<td>-muxers</td>
<td>显示可用复用器</td>
</tr>
<tr>
<td>-demuxers</td>
<td>显示可用解复用器</td>
</tr>
<tr>
<td>-codecs</td>
<td>显示可用编解码器（decoders+encoders）</td>
</tr>
<tr>
<td>-decoders</td>
<td>显示可用解码器</td>
</tr>
<tr>
<td>-encoders</td>
<td>显示可用编码器</td>
</tr>
<tr>
<td>-bsfs</td>
<td>显示可用比特流filter</td>
</tr>
<tr>
<td>-protocols</td>
<td>显示可用协议</td>
</tr>
<tr>
<td>-filters</td>
<td>显示可用过滤器</td>
</tr>
<tr>
<td>-pix_fmts</td>
<td>显示可用像素格式</td>
</tr>
<tr>
<td>-layouts</td>
<td>显示标准声音名称</td>
</tr>
<tr>
<td>-sample_fmts</td>
<td>显示可用音频采样格式</td>
</tr>
<tr>
<td>-colors</td>
<td>显示可用颜色名称</td>
</tr>
</tbody></table>
<p><strong>查看具体分类所支持的参数</strong></p>
<ul>
<li>语法：ffmepg -h type&#x3D;name</li>
<li>例子：<ul>
<li>ffmpeg -h muxer&#x3D;flv</li>
<li>ffmpeg -h filter&#x3D;atempo （atempo调整音频播放速率）</li>
<li>ffmpeg -h encoder&#x3D;libx264</li>
</ul>
</li>
</ul>
<h2 id="FFmpeg命令参数说明"><a href="#FFmpeg命令参数说明" class="headerlink" title="FFmpeg命令参数说明"></a>FFmpeg命令参数说明</h2><p><strong>主要参数</strong></p>
<ul>
<li>-i 设定输入流</li>
<li>-f 设定输出格式(format)</li>
<li>-ss 开始时间</li>
<li>-t 时间长度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -codec copy -ss 1:00:00 -t 20 -f mp4 out.mp4</span><br></pre></td></tr></table></figure>

<p><strong>音频参数</strong></p>
<ul>
<li>-aframes 设置要输出的音频帧数</li>
<li>-b:a 音频码率</li>
<li>-ar 设定采样率</li>
<li>-ac 设定声音的Channel数 </li>
<li>-acodec 设定声音编解码器，如果用copy表示原始编解码数据必须被拷贝。</li>
<li>-an 不处理音频</li>
<li>-af 音频过滤器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -encoders | grep mp3</span><br><span class="line">ffmpeg -i test.mp4 -aframes 200 -b:a 192k -ar 48000 -ac 2 -acodec aac out.aac</span><br><span class="line">ffmpeg -i test.mp4 -aframes 200 -b:a 192k -ar 48000 -ac 2 -acodec mp3 out.mp3</span><br></pre></td></tr></table></figure>

<p><strong>视频参数</strong></p>
<ul>
<li>-vframes 设置要输出的视频帧数</li>
<li>-b 设定视频码率</li>
<li>-b:v 视频码率</li>
<li>-r 设定帧速率</li>
<li>-s 设定画面的宽与高</li>
<li>-vn 不处理视频</li>
<li>-aspect aspect 设置横纵比 4:3  16:9 或 1.3333 1.7777</li>
<li>-vcodec 设定视频编解码器，如果用copy表示原始编解码数据必须被拷贝。</li>
<li>-vf 视频过滤器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -encoders | grep 264</span><br><span class="line">ffmpeg -i test.mp4 -vframes 300 -b:v 300k -r 30 -s 640x480 -aspect 4:3 -vcodec h264_videotoolbox out.h264</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg命令提取音视频数据"><a href="#FFmpeg命令提取音视频数据" class="headerlink" title="FFmpeg命令提取音视频数据"></a>FFmpeg命令提取音视频数据</h2><p><strong>保留封装格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -acodec copy -vn audio.mp4</span><br><span class="line">ffmpeg -i test.mp4 -vcodec copy -an video.mp4</span><br></pre></td></tr></table></figure>

<p><strong>提取视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 保留编码格式</span><br><span class="line">ffmpeg -i test.mp4 -acodec copy -an test.h264</span><br></pre></td></tr></table></figure>

<p><strong>提取音频</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 保留编码格式</span><br><span class="line">ffmpeg -i test.mp4 -vcodec copy -an test.aac</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg命令提取像素格式"><a href="#FFmpeg命令提取像素格式" class="headerlink" title="FFmpeg命令提取像素格式"></a>FFmpeg命令提取像素格式</h2><p><strong>提取YUV</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 提取3秒数据，分辨率和源视频一样</span><br><span class="line">ffmpeg -i test.mp4 -t 3 -pix_fmt yuv420p yuv420p_orig.yuv</span><br><span class="line"># 提取3秒数据，分辨率转320x240</span><br><span class="line">ffmpeg -i test.mp4 -t 3 -s 320x240 -pix_fmt yuv420p yuv420p_320x240.yuv</span><br></pre></td></tr></table></figure>

<p><strong>提取RGB</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提取3秒数据，分辨率转320x240</span><br><span class="line">ffmpeg -i test.mp4 -t 3 -s 320x240 -pix_fmt rgb240 rgb24_320x240.rgb</span><br></pre></td></tr></table></figure>

<p><strong>RGB和YUV之间的转换</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -s 320x240 -pix_fmt 420p -i yuv420p_320x240.yuv -pix_fmt rgb24 rgb24_320x240_2.rgb</span><br></pre></td></tr></table></figure>

<p><strong>提取PCM数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># PCM封装格式</span><br><span class="line">ffmpeg -muxers | grep PCM</span><br><span class="line">ffmpeg -i test.mp4 -ar 48000 -ac 2 -f s16le 48000_2_s16le.pcm #后缀无关</span><br><span class="line"></span><br><span class="line"># 采样格式</span><br><span class="line">ffmpeg -sample_fmts</span><br><span class="line">ffmpeg -i test.mp4 -ar 48000 -ac 2 -sample_fmt s16 out_s16.wav</span><br><span class="line"></span><br><span class="line"># 解码格式</span><br><span class="line">ffmpeg -encoders | grep PCM</span><br><span class="line">ffmpeg -i test.mp4 -ar 48000 -ac 2 -codec:a pcm_s16le out_s16.wav</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg命令转封装"><a href="#FFmpeg命令转封装" class="headerlink" title="FFmpeg命令转封装"></a>FFmpeg命令转封装</h2><p><strong>保持编码格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -acodec copy -vcodec copy test_copy.ts</span><br><span class="line">ffmpeg -i test.mp4 -codec copy test_copy.ts</span><br></pre></td></tr></table></figure>

<p><strong>改变编码格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -vcodec h264_videotoolbox -acodec aac out_h264_aac.mkv</span><br></pre></td></tr></table></figure>

<p><strong>改变帧率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -r 15 -codec copy out_r15.mp4 #错误命令,改变帧率过程中有转码不能使用-codec copy</span><br><span class="line">ffmpeg -i test.mp4 -r 15 out_r15.mp4   </span><br></pre></td></tr></table></figure>

<p><strong>修改视频码率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -b 400k out_400k.mkv</span><br><span class="line">ffmpeg -i test.mp4 -b:v 400k out_400k.mkv</span><br></pre></td></tr></table></figure>

<p><strong>修改音频码率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -b:a 192k out_192k.mp4 #如果不想重新编码video，需要加上-vcodec copy</span><br></pre></td></tr></table></figure>

<p><strong>修改音视频码率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -b:v 300k -b:a 192k out_300_192k.mp4</span><br></pre></td></tr></table></figure>

<p><strong>修改视频分辨率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -s 480x720 out_480x720.mp4</span><br></pre></td></tr></table></figure>

<p><strong>修改音频采样率</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -ar 41000 out_41000.mp4</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg命令裁剪和合并视频"><a href="#FFmpeg命令裁剪和合并视频" class="headerlink" title="FFmpeg命令裁剪和合并视频"></a>FFmpeg命令裁剪和合并视频</h2><p><strong>裁剪视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mp4格式</span><br><span class="line">ffmpeg -i test1.mp4 -t 5 -codec copy out1.mp4</span><br><span class="line">ffmpeg -i test2.mp4 -t 5 -codec copy out2.mp4</span><br><span class="line"></span><br><span class="line"># ts格式</span><br><span class="line">ffmpeg -i test1.mp4 -t 5 -codec copy -vbsf h264_mp4toannexb out1.ts</span><br><span class="line">ffmpeg -i test2.mp4 -t 5 -codec copy -vbsf h264_mp4toannexb out2.ts</span><br><span class="line"></span><br><span class="line"># flv格式</span><br><span class="line">ffmpeg -i test1.mp4 -t 5 -codec copy out1.flv</span><br><span class="line">ffmpeg -i test2.mp4 -t 5 -codec copy out2.flv</span><br></pre></td></tr></table></figure>

<ul>
<li>分离某些封装格式（例如MP4&#x2F;FLV&#x2F;MKV等）中的H.264的时候，需要首先写入SPS和PPS，否则会导致分离出来的数据没有SPS、PPS而无法播放。H.264码流的SPS和PPS信息存储在AVCodecContext结构体的extradata中。需要使用ffmpeg中名称为“<strong>h264_mp4toannexb</strong>”的bitstream filter处理。</li>
</ul>
<p><strong>拼接视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mp4格式</span><br><span class="line">ffmpeg -i &#x27;concat:out1.mp4|out2.mp4&#x27; -codec copy out_merge1.mp4</span><br><span class="line">ffmpeg -f concat -i mp4list.txt -codec copy out_merge2.mp4</span><br><span class="line"></span><br><span class="line"># ts格式</span><br><span class="line">ffmpeg -i &#x27;concat:out1.ts|out2.ts&#x27; -codec copy out_merge1.ts</span><br><span class="line">ffmpeg -f concat -i tslist.txt -codec copy out_merge2.ts</span><br><span class="line"></span><br><span class="line"># flv格式</span><br><span class="line">ffmpeg -i &#x27;concat:out1.flv|out2.flv&#x27; -codec copy out_merge1.flv</span><br><span class="line">ffmpeg -f concat -i flvlist.txt -codec copy out_merge2.flv</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注：</p>
<ul>
<li><p>方法1只适用部分封装格式，比如TS。</p>
</li>
<li><p>方法2中文件列表内容格式：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file &#x27;out1.mp4&#x27;</span><br><span class="line">file &#x27;out2.mp4&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>测试不同编码拼接</strong></p>
<ul>
<li>修改<strong>音频编码</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.ts -vcodec copy -acodec aac test_acodec.ts</span><br><span class="line">ffmpeg -i &#x27;concat:test_acodec.ts|out2.ts&#x27; -codec copy test_acodec_merge.ts</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<strong>音频采样率</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.ts -vcodec copy -ar 24000 test_ar.ts</span><br><span class="line">ffmpeg -i &#x27;concat:test_ar.ts|out2.ts&#x27; -codec copy test_ar_merge.ts</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<strong>视频编码</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.ts -acodec copy -vcodec hevc_videotoolbox test_vcodec.ts</span><br><span class="line">ffmpeg -i &#x27;concat:test_vcodec.ts|out2.ts&#x27; -codec copy test_vcodec_merge.ts</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<strong>视频分辨率</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out1.ts -codec copy -s 800x472 test_size.ts</span><br><span class="line">ffmpeg -i &#x27;concat:test_size.ts|out2.ts&#x27; -codec copy test_size_merge.ts</span><br></pre></td></tr></table></figure>

<ul>
<li>注：<ul>
<li>视频分辨率可以不同，但是编码格式需要统一。</li>
<li>音频编码格式需要统一，音频参数(采样率&#x2F;声道等)也需要统一。</li>
</ul>
</li>
</ul>
<h2 id="FFmpeg命令图片和视频互转"><a href="#FFmpeg命令图片和视频互转" class="headerlink" title="FFmpeg命令图片和视频互转"></a>FFmpeg命令图片和视频互转</h2><p><strong>截取一张图片</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -y -f image2 -ss 0:00:02 -vframes 1 -s 640x320 test.jpg</span><br><span class="line">ffmpeg -i test.mp4 -f image2 -ss 0:00:02 -vframes 1 -s 640x320 test.bmp</span><br><span class="line"># -y 强制覆盖</span><br><span class="line"># -vframes 如果大于1输出需要加%03d 03为位数 </span><br></pre></td></tr></table></figure>

<p><strong>视频转每帧图片</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -t 5 -s 640x320 -r 15 frame%03d.jpg</span><br></pre></td></tr></table></figure>

<p><strong>图片转视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f image2 -i frame%03d.jpg -r 25 video.mp4</span><br></pre></td></tr></table></figure>

<p><strong>视频转GIF图片</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -t 5 -r 25 test.gif</span><br></pre></td></tr></table></figure>

<p><strong>GIF图片转视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f gif -i test.gif git_video.mp4</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg命令视频录制"><a href="#FFmpeg命令视频录制" class="headerlink" title="FFmpeg命令视频录制"></a>FFmpeg命令视频录制</h2><p><strong>查看可用的音视频设备名称</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个命令会列出可用的音视频设备信息，包括设备名称、设备类型等。输出会显示类似下面的内容：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AVFoundation input device @ 0x7fa37660d8c0] AVFoundation video devices:</span><br><span class="line">[AVFoundation input device @ 0x7fa37660d8c0] [0] FaceTime HD Camera (Built-in)</span><br><span class="line">[AVFoundation input device @ 0x7fa37660d8c0] [1] Capture screen 0</span><br><span class="line">[AVFoundation input device @ 0x7fa37660d8c0] AVFoundation audio devices:</span><br><span class="line">[AVFoundation input device @ 0x7fa37660d8c0] [0] MacBook Pro Microphone</span><br></pre></td></tr></table></figure>

<p><strong>录制音视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -r 30 -i &quot;0:0&quot; -c:a aac -c:v h264_videotoolbox -s 1280x720 output.mkv</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://www.lmlphp.com/user/259/article/item/24620/">ffmpeg采集设备</a></p>
<h2 id="FFmpeg命令直播"><a href="#FFmpeg命令直播" class="headerlink" title="FFmpeg命令直播"></a>FFmpeg命令直播</h2><p><strong>拉流</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffplay rtmp://server/live/streamName </span><br><span class="line">ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</span><br><span class="line"># 对于不是rtmp的协议 -c copy要谨慎使用</span><br></pre></td></tr></table></figure>

<p><strong>推流</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</span><br><span class="line"># -re: 表示按时间戳读取文件</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/16741e363a77">nginx搭建rtmp流媒体服务器(Ubuntu 16.04)</a></p>
<h2 id="FFmpeg过滤器-裁剪"><a href="#FFmpeg过滤器-裁剪" class="headerlink" title="FFmpeg过滤器-裁剪"></a>FFmpeg过滤器-裁剪</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 裁剪图片</span><br><span class="line">ffmpeg -i test.jpg -vf crop=iw/3:ih:0:0 out.jpg</span><br><span class="line">ffplay -i test.jpg -vf crop=iw/3:ih:0:0</span><br><span class="line"></span><br><span class="line"># 裁剪视频</span><br><span class="line">ffmpeg -i test.mp4 -vf crop=iw/3:ih:0:0 out.mp4</span><br><span class="line">ffplay -i test.mp4 -vf crop=iw/3:ih:0:0</span><br></pre></td></tr></table></figure>

<p><strong>裁剪</strong></p>
<ul>
<li>描述：将输入视频帧的宽度和高度从x和y值表示的位置裁剪到指定的宽度和高度x和y是输出的左上角坐标，协调系统的中心是输入视频帧的左上角。如果使用了可选的keep_aspect参数，将会改变输出SAR(样本宽比)以补偿新的DAR(显示长宽比)。</li>
<li>语法：<code>crop=ow[:oh[:x[:y[:keep_aspect]]]]</code></li>
</ul>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>x,   y</strong></td>
<td>对x的计算值(从左上角水平方向的像素个数)和y(垂直像素的数量)，对每个帧进行评估，x的默认值为(iw - ow)&#x2F;2, y的默认值为(ih - oh)&#x2F;2</td>
</tr>
<tr>
<td><strong>in_w, iw</strong></td>
<td>输入的宽度</td>
</tr>
<tr>
<td><strong>in_h, ih</strong></td>
<td>输入的高度</td>
</tr>
<tr>
<td><strong>out_w, ow</strong></td>
<td>输出(裁剪)宽度，默认值&#x3D; iw</td>
</tr>
<tr>
<td><strong>out_h, oh</strong></td>
<td>输出(裁剪)高度，默认值&#x3D; ih</td>
</tr>
<tr>
<td><strong>a</strong></td>
<td>纵横比，与iw&#x2F;ih相同</td>
</tr>
<tr>
<td><strong>sar</strong></td>
<td>输入样本比例</td>
</tr>
<tr>
<td><strong>dar</strong></td>
<td>输入显示宽比，等于表达式a*sar</td>
</tr>
<tr>
<td><strong>hsub, vsub</strong></td>
<td>水平和垂直的色度子样本值，对于像素格式yuv422p, hsub的值为2,vsub为1</td>
</tr>
<tr>
<td><strong>n</strong></td>
<td>输入帧的数目，从0开始</td>
</tr>
<tr>
<td><strong>pos</strong></td>
<td>位置在输入框的文件中，如果不知道NAN</td>
</tr>
<tr>
<td><strong>t</strong></td>
<td>时间戳以秒表示，如果输入时间戳未知</td>
</tr>
</tbody></table>
<p><strong>举例</strong></p>
<ul>
<li>裁剪100x100的区域，起点为(12,34)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crop=100:100:12:34</span><br><span class="line"></span><br><span class="line">相同效果:</span><br><span class="line">crop=w=100:h=100:x=12:y=34</span><br></pre></td></tr></table></figure>

<ul>
<li>裁剪中心区域，大小为100x100</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop=100:100</span><br></pre></td></tr></table></figure>

<ul>
<li>裁剪中心区域，大小为输入视频的2&#x2F;3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop=2/3*in_w:2/3*in_h</span><br></pre></td></tr></table></figure>

<ul>
<li>裁剪中心区域的正方形，高度为输入视频的高</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop=in_h:in_h</span><br></pre></td></tr></table></figure>

<ul>
<li>裁剪偏移左上角100像素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop=in_w-100:in_h-100:100:100</span><br></pre></td></tr></table></figure>

<ul>
<li>裁剪掉左右10像素，上下20像素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop=in_w-2*10:in_h-2*20</span><br></pre></td></tr></table></figure>

<ul>
<li>裁剪右下角区域</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop=in_w/2:in_h/2:in_w/2:in_h/2</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg过滤器-文字水印"><a href="#FFmpeg过滤器-文字水印" class="headerlink" title="FFmpeg过滤器-文字水印"></a>FFmpeg过滤器-文字水印</h2><p><strong>文字水印</strong></p>
<p>​	在视频中增加文字水印需要准备的条件比较多，需要有文字字库处理的相关文件，在编译FFmpeg时需要支持FreeType、FontConfig、iconv，系统中需要有相关的字库，在FFmpeg中增加纯字母水印可以使用<strong>drawtext</strong>滤镜进行支持，下面就来看一下<strong>drawtext</strong>的滤镜参数，具体见表。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>字符串</td>
<td>文字</td>
</tr>
<tr>
<td>textfile</td>
<td>字符串</td>
<td>文字文件</td>
</tr>
<tr>
<td>box</td>
<td>布尔</td>
<td>文字区域背景框(缺省false)</td>
</tr>
<tr>
<td>boxcolor</td>
<td>色彩</td>
<td>展示字体区域块的颜色</td>
</tr>
<tr>
<td>font</td>
<td>字符串</td>
<td>字体名称（默认为Sans字体）</td>
</tr>
<tr>
<td>fontsize</td>
<td>整数</td>
<td>显示字体的大小</td>
</tr>
<tr>
<td>x</td>
<td>字符串</td>
<td>横坐标，缺省为0</td>
</tr>
<tr>
<td>y</td>
<td>字符串</td>
<td>纵坐标，缺省为0</td>
</tr>
<tr>
<td>alpha</td>
<td>浮点数</td>
<td>透明度(默认为1)，值从0~1</td>
</tr>
</tbody></table>
<p><strong>内置变量</strong></p>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>以秒表示的时间戳，如果输入的时间是未知的则是NAN</td>
</tr>
<tr>
<td>n</td>
<td>输入帧的顺序编号，从0开始</td>
</tr>
<tr>
<td>pos</td>
<td>输入帧的位置，如果未知的则是NAN</td>
</tr>
<tr>
<td>w</td>
<td>输入视频帧的宽度</td>
</tr>
<tr>
<td>h</td>
<td>输入视频帧的高度</td>
</tr>
</tbody></table>
<p><strong>举例</strong></p>
<ul>
<li>显示水印</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将文字的水印加在视频的左上角</span><br><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=100:fontfile=FreeSerif.ttf:text=&#x27;hello world&#x27;:x=20:y=20&quot;</span><br><span class="line"></span><br><span class="line"># 将字体的颜色设置为绿色</span><br><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=100:fontfile=FreeSerif.ttf:text=&#x27;hello world&#x27;:fontcolor=green&quot;</span><br><span class="line"></span><br><span class="line"># 如果想调整文字水印显示的位置，调整x与y参数的数值即可</span><br><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=100:fontfile=FreeSerif.ttf:text=&#x27;hello world&#x27;:fontcolor=green:x=400:y=200&quot;</span><br><span class="line"></span><br><span class="line"># 修改透明度</span><br><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=100:fontfile=FreeSerif.ttf:text=&#x27;hello world&#x27;:fontcolor=green:x=400:y=200:alpha=0.5&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>背景框</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=100:fontfile=FreeSerif.ttf:text=&#x27;hello world&#x27;:fontcolor=green:box=1:boxcolor=yellow&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>本地时间作为水印内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffplay  -i input.mp4 -vf &quot;drawtext=fontsize=60:fontfile=FreeSerif.ttf:text=&#x27;%&#123;localtime\:%Y\-%m\-%d %H-%M-%S&#125;&#x27;:fontcolor=green:box=1:boxcolor=yellow&quot;</span><br><span class="line"></span><br><span class="line"># 在使用ffmpeg转码存储到文件时需要加上-re，否则时间不对</span><br><span class="line">ffmpeg -re -i input.mp4 -vf &quot;drawtext=fontsize=60:fontfile=FreeSerif.ttf:text=&#x27;%&#123;localtime\:%Y\-%m\-%d %H-%M-%S&#125;&#x27;:fontcolor=green:box=1:boxcolor=yellow&quot; out.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li>定时显示水印</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每3秒钟显示一次文字水印</span><br><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=60:fontfile=FreeSerif.ttf:text=&#x27;test&#x27;:fontcolor=green:box=1:boxcolor=yellow:enable=lt(mod(t\,3)\,1)&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>表达式相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lt(x, y)  Return 1 if x is lesser than y, 0 otherwise.</span><br><span class="line">mod(x, y) Compute the remainder of division of x by y.</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://www.ffmpeg.org/ffmpeg-utils.html">1.ffmpeg官网</a>	<a target="_blank" rel="noopener" href="http://www.ffmpeg.org/ffmpeg-utils.html#toc-Expression-Evaluation">2. 3 Expression Evaluation</a></p>
<ul>
<li>跑马灯效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=100:fontfile=FreeSerif.ttf:text=&#x27;helloworld&#x27;:x=mod(100*t\,w):y=abs(sin(t))*h*0.7&quot;</span><br><span class="line"></span><br><span class="line"># 修改字体透明度，修改字体颜色</span><br><span class="line">ffplay -i input.mp4 -vf &quot;drawtext=fontsize=40:fontfile=FreeSerif.ttf:text=&#x27;liaoqingfu&#x27;:x=mod(50*t\,w):y=abs(sin(t))*h*0.7:alpha=0.5:fontcolor=white:enable=lt(mod(t\,3)\,1)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg过滤器-图片水印"><a href="#FFmpeg过滤器-图片水印" class="headerlink" title="FFmpeg过滤器-图片水印"></a>FFmpeg过滤器-图片水印</h2><p><strong>图片水印</strong></p>
<p>​	在FFmpeg中加入图片水印有两种方式，一种是通过movie指定水印文件路径，另外一种方式是通过filter读取输入文件的流并指定为水印，这里重点介绍如何读取movie图片文件作为水印。</p>
<p>​	FFmpeg除了可以向视频添加文字水印之外，还可以向视频添加图片水印、视频跑马灯等，本节将重点介绍如何为视频添加图片水印；为视频添加图片水印可以使用movie滤镜，下面就来熟悉一下<strong>movie</strong>滤镜的参数，如表所示。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>filename</td>
<td>字符串</td>
<td>输入的文件名，可以是文件，协议，设备</td>
</tr>
<tr>
<td>format_name, f</td>
<td>字符串</td>
<td>输入的封装格式</td>
</tr>
<tr>
<td>stream_index,   si</td>
<td>整数</td>
<td>输入的流索引编号</td>
</tr>
<tr>
<td>seek_point,   sp</td>
<td>浮点数</td>
<td>Seek输入流的时间位置</td>
</tr>
<tr>
<td>streams,   s</td>
<td>字符串</td>
<td>输入的多个流的流信息</td>
</tr>
<tr>
<td>loop</td>
<td>整数</td>
<td>循环次数</td>
</tr>
<tr>
<td>discontinuity</td>
<td>时间差值</td>
<td>支持跳动的时间戳差值</td>
</tr>
</tbody></table>
<p><strong>内置变量</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>main_w 或 W</td>
<td>视频单帧图像宽度</td>
</tr>
<tr>
<td>main_h 或 H</td>
<td>视频单帧图像高度</td>
</tr>
<tr>
<td>overlay_w</td>
<td>水印图片的宽度</td>
</tr>
<tr>
<td>overlay_h</td>
<td>水印图片的高度</td>
</tr>
</tbody></table>
<p><strong>overlay过滤器</strong></p>
<ul>
<li><p>描述：前景窗口(第二输入)覆盖在背景窗口(第一输入)的指定位置。</p>
</li>
<li><p>语法：<code>overlay[=x:y[[:rgb=&#123;0, 1&#125;]]</code></p>
<ul>
<li>参数 x 和 y 是可选的，默认为 0。</li>
<li>参数 rgb 参数也是可选的，其值为 0 或 1，默认为 0。</li>
</ul>
</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf &quot;movie=logo.png[watermark];[in][watermark]overlay=x=10:y=10[out]&quot; output.mp4</span><br><span class="line"></span><br><span class="line"># 原始视频文件路径：input.mp4</span><br><span class="line"># 水印图片路径：logo.png</span><br><span class="line"># 水印位置：(x,y)=(10,10)&lt;=(left,top)距离左侧、顶部各10像素</span><br><span class="line"># 输出文件路径：output.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li>显示位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;movie=logo.png[watermark];[in][watermark]overlay=10:10[out]&quot;</span><br><span class="line"> </span><br><span class="line">ffplay -i input.mp4 -vf &quot;movie=logo.png[watermark];[in][watermark]overlay=main_w-overlay_w-10:10[out]&quot;</span><br><span class="line"> </span><br><span class="line">ffplay -i input.mp4 -vf &quot;movie=logo.png[watermark];[in][watermark]overlay=10:main_h-overlay_h-10[out]&quot;</span><br><span class="line"> </span><br><span class="line">ffplay -i input.mp4 -vf &quot;movie=logo.png[watermark];[in][watermark]overlay=main_w-overlay_w-10:main_h-overlay_h-10[out]&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>跑马灯效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;movie=logo.png[watermark];[in][watermark]overlay=x=mod(50*t\,main_w):y=abs(sin(t))*h*0.7[out]&quot;</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg生成画中画"><a href="#FFmpeg生成画中画" class="headerlink" title="FFmpeg生成画中画"></a>FFmpeg生成画中画</h2><p><strong>画中画</strong></p>
<p>​	在使用FFmpeg处理流媒体文件时，有时需要使用画中画的效果。在FFmpeg中，可以通过overlay将多个视频流、多个多媒体采集设备、多个视频文件合并到一个界面中，生成画中画的效果。在前面的滤镜使用中，以至于以后的滤镜使用中，与视频操作相关的处理，大多数都会与overlay滤镜配合使用，尤其是用在图层处理与合并场景中，下面就来了解一下overlay的参数，具体见表。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>字符串</td>
<td>X坐标</td>
</tr>
<tr>
<td>y</td>
<td>字符串</td>
<td>Y坐标</td>
</tr>
<tr>
<td>eof_action</td>
<td>整数</td>
<td>遇到eof表示时的处理方式，默认为重复Ø repeat(值为0)：重复前一帧Ø endcall(值为1)：停止所有的流Ø pass(值为2)：保留主图层</td>
</tr>
<tr>
<td>shortest</td>
<td>布尔</td>
<td>终止最短的视频时全部终止（默认false）</td>
</tr>
<tr>
<td>format</td>
<td>整数</td>
<td>设置output的像素格式，默认为yuv420。 yuv420 (值为0)；yuv422 (值为1)；yuv444 (值为2)；rgb (值为3)</td>
</tr>
</tbody></table>
<p><strong>举例</strong></p>
<ul>
<li>显示画中画效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;movie=sub_320x240.mp4[sub];[in][sub]overlay=x=20:y=20[out]&quot;</span><br><span class="line"> </span><br><span class="line">ffplay -i input.mp4 -vf &quot;movie=sub_320x240.mp4[sub];[in][sub]overlay=x=20:y=20:eof_action=1[out]&quot;</span><br><span class="line"> </span><br><span class="line">ffplay -i input.mp4 -vf &quot;movie=sub_320x240.mp4[sub];[in][sub]overlay=x=20:y=20:shortest =1[out]&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>缩放子画面</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;movie=sub_320x240.mp4,scale=640x480[sub];[in][sub]overlay=x=20:y=20[out]&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>跑马灯</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i input.mp4 -vf &quot;movie=sub_320x240.mp4[test];[in][test]overlay= x=mod(50*t\,main_w):y=abs(sin(t))*main_h*0.7[out]&quot;</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg视频多宫格处理"><a href="#FFmpeg视频多宫格处理" class="headerlink" title="FFmpeg视频多宫格处理"></a>FFmpeg视频多宫格处理</h2><p><strong>视频多宫格</strong></p>
<p>​	视频除了画中画显示，还有一种场景为以多宫格的方式呈现出来，除了可以输入视频文件，还可以输入视频流、采集设备等。从前文中可以看出进行视频图像处理时，overlay滤镜为关键画布，可以通过FFmpeg建立一个画布，也可以使用默认的画布。如果想以多宫格的方式展现，则可以自己建立一个足够大的画布，下面就来看一下多宫格展示的例子。</p>
<p><strong>举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 1.mp4 -i 2.mp4 -i 3.mp4 -i 4.mp4 -filter_complex &quot;nullsrc=size=640x480[base];[0:v] setpts=PTS-STARTPTS,scale=320x240[upperleft];[1:v]setpts=PTS-STARTPTS,scale=320x240[upperright];[2:v]setpts=PTS-STARTPTS, scale=320x240[lowerleft];[3:v]setpts=PTS-STARTPTS,scale=320x240[lowerright];[base][upperleft]overlay=shortest=1[tmp1];[tmp1][upperright]overlay=shortest=1:x=320[tmp2];[tmp2][lowerleft]overlay=shortest=1:y=240[tmp3];[tmp3][lowerright]overlay=shortest=1:x=320:y=240&quot; out.mp4</span><br><span class="line"></span><br><span class="line"># 1.2.3.4.mp4为文件路径</span><br><span class="line"># out.MP4为输出文件路径</span><br><span class="line"># 通过nullsrc创建overlay画布，画布大小640:480</span><br><span class="line"># 使用[0:v][1:v][2:v][3:v]将输入的4个视频流去除，分别进行缩放处理</span><br><span class="line"># 然后基于nullsrc生成的画布进行视频平铺，命令中自定义upperleft,upperright,lowerleft,lowerright进行不同位置平铺</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/06/10/EffectiveModernCPP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/EffectiveModernCPP/" class="post-title-link" itemprop="url">EffectiveModernCPP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-10 21:54:15" itemprop="dateCreated datePublished" datetime="2023-06-10T21:54:15+08:00">2023-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:41:05" itemprop="dateModified" datetime="2023-12-30T22:41:05+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章-类型推导"><a href="#第一章-类型推导" class="headerlink" title="第一章 类型推导"></a>第一章 类型推导</h1><h2 id="条款1-理解模板类型推导"><a href="#条款1-理解模板类型推导" class="headerlink" title="条款1 理解模板类型推导"></a>条款1 理解模板类型推导</h2><p>以一个最常见的模板作为例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在调用如下函数的时候：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(expr);     <span class="comment">//以某表达式调用f</span></span><br></pre></td></tr></table></figure>

<p>编译器会推导上述例子中的 <strong>T</strong> 的类型和 <strong>ParamType</strong> 的类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;      <span class="comment">//ParamType 是 constT&amp;</span></span><br></pre></td></tr></table></figure>

<p>以下调用的时候：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(x);        <span class="comment">//以一个int调用f</span></span><br></pre></td></tr></table></figure>

<p><strong>T</strong> 推导为int，而 <strong>ParamType</strong> 被推导为const int&amp;</p>
<p>也许我们会很自然的认为，T的类型推导结果和传递给函数的实参类型是同样的。 但实际上并非如此。<br><strong>T</strong> 的类型推导结果，不仅仅依赖于expr的类型，还依赖ParamType的形式。具体需要分三种情况进行讨论：</p>
<ol>
<li>ParamType具有指针或引用类型，但不是个万能引用；</li>
<li>ParamType是一个万能引用；</li>
<li>ParamType既不是指针也不是引用。</li>
</ol>
<p>我们以下的分析均以如下模板进行展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);            <span class="comment">//从expr来推导T和ParamType的类型</span></span><br></pre></td></tr></table></figure>

<h3 id="1-情况1：ParamType是个指针或者引用，但不是一个万能引用"><a href="#1-情况1：ParamType是个指针或者引用，但不是一个万能引用" class="headerlink" title="1. 情况1：ParamType是个指针或者引用，但不是一个万能引用"></a>1. 情况1：ParamType是个指针或者引用，但不是一个万能引用</h3><blockquote>
<p>这种情况下，推导满足如下原理：</p>
<ol>
<li>若expr具有引用类型，先将引用部分忽略；</li>
<li>然后对expr的类型和<strong>ParamType</strong>的类型执行模式匹配，来决定 <strong>T</strong> 的类型。</li>
</ol>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;           <span class="comment">//param是个引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                 <span class="comment">//x的类型是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;           <span class="comment">//cx的类型是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;          <span class="comment">//rx是x的类型为const int的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                       <span class="comment">//T的类型是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                      <span class="comment">//T的类型是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                      <span class="comment">//T的类型是const int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>再举个栗子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;     <span class="comment">//param是个const引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                 <span class="comment">//x的类型是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;           <span class="comment">//cx的类型是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;          <span class="comment">//rx是x的类型为const int的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                       <span class="comment">//T的类型是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                      <span class="comment">//T的类型是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                      <span class="comment">//T的类型是int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>最后一个栗子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;           <span class="comment">//param是个指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x =<span class="number">27</span>;                  <span class="comment">//x的类型是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;         <span class="comment">//px是指到x的指针，类型为const int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                      <span class="comment">//T的类型是int，param的类型是int*</span></span><br><span class="line"><span class="built_in">f</span>(px);                      <span class="comment">//T的类型是const int，param的类型是const int*</span></span><br></pre></td></tr></table></figure>

<p>以上一切都很正常，和普通的理解毫无差别。</p>
<h3 id="2-情况2：ParamType是个万能引用"><a href="#2-情况2：ParamType是个万能引用" class="headerlink" title="2. 情况2：ParamType是个万能引用"></a>2. 情况2：ParamType是个万能引用</h3><blockquote>
<p>这种情况下，推导满足如下原理：</p>
<ol>
<li>如果expr是个左值，<strong>T</strong>和<strong>Param</strong>都会被推导为左值引用；</li>
<li>如果expr是个右值，则应用情况1的规则。</li>
</ol>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">//param是个万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                 <span class="comment">//x的类型是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;           <span class="comment">//cx的类型是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;          <span class="comment">//rx是x的类型为const int的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                       <span class="comment">//x是个左值，所以T的类型是int&amp;，param的类型也是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                      <span class="comment">//cx是个左值，所以T的类型是const int&amp;，</span></span><br><span class="line">                            <span class="comment">//param的类型也是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                      <span class="comment">//rx是个左值，所以T的类型是const int&amp;，</span></span><br><span class="line">                            <span class="comment">//param的类型也是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                      <span class="comment">//27是个右值，所以T的类型是int</span></span><br><span class="line">                            <span class="comment">//这么一来，param的类型就成了int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-情况3：ParamType既不是指针也不是引用"><a href="#3-情况3：ParamType既不是指针也不是引用" class="headerlink" title="3. 情况3：ParamType既不是指针也不是引用"></a>3. 情况3：ParamType既不是指针也不是引用</h3><blockquote>
<p>这种情况下，推导满足如下原理：</p>
<ol>
<li>若expr具有引用类型，先将引用部分忽略；</li>
<li>忽略expr引用性之后，若expr是个<strong>const</strong> &#x2F; <strong>volatile</strong>对象，也忽略之。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;            <span class="comment">//param是按值传递</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;                 <span class="comment">//x的类型是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;           <span class="comment">//cx的类型是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;          <span class="comment">//rx是x的类型为const int的引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                       <span class="comment">//T和param的类型是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                      <span class="comment">//T和param的类型是int</span></span><br><span class="line"><span class="built_in">f</span>(rx);                      <span class="comment">//T和param的类型是int</span></span><br></pre></td></tr></table></figure>

<p><strong>需要重点说明的是，cv属性仅仅只在按值形参处被忽略。</strong></p>
<p>除了以上三种普遍情况外，有两种特例需要额外小心，以下列举两种特例：</p>
<h3 id="4-两种特例"><a href="#4-两种特例" class="headerlink" title="4. 两种特例"></a>4. 两种特例</h3><h4 id="4-1-数组实参"><a href="#4-1-数组实参" class="headerlink" title="4.1 数组实参"></a>4.1 数组实参</h4><p>由于在很多语境下，数组类型会退化成指涉到首元素的指针。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;Adam Xiao&quot;</span>;    <span class="comment">//name的类型是const char[10]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptrToName = name;       <span class="comment">//数组退化成指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                    <span class="comment">//持有按值形参的模板</span></span><br><span class="line"><span class="built_in">f</span>(name);                            <span class="comment">//name实际上是个数组，但T和param的类型推导为const char*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;                   <span class="comment">//按引用的方式传递形参</span></span><br><span class="line"><span class="built_in">f</span>(name);                            <span class="comment">//T的类型推导结果是const char[10],param的推导结果为//const char(&amp;)[10]</span></span><br></pre></td></tr></table></figure>

<p>根据这个奇怪的特性，可以创造一个模板，来推导出数组含有的元素个数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>constexpr</strong>能够使得返回值在编译期就可用。</p>
<h4 id="4-2-函数实参"><a href="#4-2-函数实参" class="headerlink" title="4.2 函数实参"></a>4.2 函数实参</h4><p>函数类型同样可以退化为指针，所以有类似于上述数组实参的相似点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;         <span class="comment">//someFunc是个函数，其类型为void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;                    <span class="comment">//f1中，param按值传递</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;                   <span class="comment">//f2中，param按引用传递</span></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                        <span class="comment">//param被推导为函数指针，具体类型为void(*)(int,double)</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                        <span class="comment">//param被推导为函数引用，具体类型为void(&amp;)(int,double)</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 在模板类型推导过程中，具有引用类型的实参会被当成非引用类型来处理。换而言之，其引用类型会被忽略。</td>
</tr>
<tr>
<td>2. 对万能引用形参进行推导时，左值实参会进行特殊处理。</td>
</tr>
<tr>
<td>3. 对按值传递的形参进行推导时，若实参类型中带有const或者volatile修饰，则cv修饰符会被去除。</td>
</tr>
<tr>
<td>4. 在模板类型推导过程中，数组或者函数类型的实参会退化成对应的指针，除非他们被用来引用传递。</td>
</tr>
</tbody></table>
<h2 id="条款2-理解auto类型推导"><a href="#条款2-理解auto类型推导" class="headerlink" title="条款2 理解auto类型推导"></a>条款2 理解auto类型推导</h2><h3 id="1-需要记住：除了一个奇特的情况例外以外，auto类型推导就是模板类型推导"><a href="#1-需要记住：除了一个奇特的情况例外以外，auto类型推导就是模板类型推导" class="headerlink" title="1. 需要记住：除了一个奇特的情况例外以外，auto类型推导就是模板类型推导"></a>1. 需要记住：除了一个奇特的情况例外以外，auto类型推导就是模板类型推导</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(expr);                <span class="comment">//以某表达式调用f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;            <span class="comment">//auto扮演了上述T的角色，变量的类型修饰词则扮演了ParamType的角色，</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br><span class="line"><span class="comment">// 对于以上三条，可以模拟出一个概念模板去理解auto的推导过程</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//为推导x的类型而生成的概念性模板</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>;</span><br><span class="line">    <span class="built_in">func_for_x</span>(<span class="number">27</span>);         <span class="comment">//概念性调用语句：推导得出的param的类型就是x的类型</span></span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//为推导cx的类型而生成的概念性模板</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="type">const</span> T param)</span></span>;</span><br><span class="line">    <span class="built_in">func_for_cx</span>(x);         <span class="comment">//概念性调用语句：推导得出的param的类型就是cx的类型</span></span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//为推导rx的类型而生成的概念性模板</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line">    <span class="built_in">func_for_rx</span>(x);         <span class="comment">//概念性调用语句：推导得出的param的类型就是rx的类型</span></span><br></pre></td></tr></table></figure>

<p>和条款1类似，也分为三种情况处理auto类型推导：</p>
<blockquote>
<p>情况1. 类型饰词是指针或引用，但不是万能引用<br>情况2. 类型饰词是万能引用<br>情况3. 类型饰词既不是指针又不是引用</p>
</blockquote>
<p>上述情况1和情况3已经讨论过，重点说一下情况2，如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;           <span class="comment">//x的类型是int，且是左值，所以uref1的类型类型是int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx;          <span class="comment">//cx的类型是const int，且是左值，所以uref2的类型类型是const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;          <span class="comment">//27的类型是int，且是右值，所以uref3的类型类型是int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>对于数组和函数而言：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;Adam Xiao&quot;</span>;        <span class="comment">//name的类型是const char[13]</span></span><br><span class="line"><span class="keyword">auto</span> arr1 = name;                       <span class="comment">//arr1的类型是const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name;                      <span class="comment">//arr2的类型是const char(&amp;)[13]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;             <span class="comment">//someFunc是个函数，类型是void(int, double)</span></span><br><span class="line"><span class="keyword">auto</span> func1 = someFunc;                  <span class="comment">//func1的类型是void(*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2 = someFunc;                 <span class="comment">//func2的类型是void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-auto的特例"><a href="#2-auto的特例" class="headerlink" title="2. auto的特例"></a>2. auto的特例</h3><p>对于赋值构造的时候，会出现一些不一样的情况。对于C++98的时候，可以选择如下方式进行变量初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>而在C++11中，为了支持统一初始化 <code>uniform initialization</code>，新增了下面的语法选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x3 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="type">int</span> x4&#123;<span class="number">27</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>一共有四种语法，然而结果却殊途同归，得到一个值为27的int。<br>将这四种初始化语法换成<code>auto</code>情况则会出现一些不同点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;       <span class="comment">//类型是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;        <span class="comment">//类型是int，值是27</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;     <span class="comment">//类型是std::initializer_list&lt;int&gt;，值是&#123;27&#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;        <span class="comment">//类型是std::initializer_list&lt;int&gt;，值是&#123;27&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里出现奇特的原因是因为以下规定：</p>
<blockquote>
<p>当用于auto声明变量的初始化表达式是使用大括号括起时，推导所得的类型就属于<code>std::initializer_list</code></p>
</blockquote>
<p>在以上奇特规定的限制下，如下报错就不奇怪了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;;       <span class="comment">//错误！ 推导不出std::initializer_list&lt;T&gt;中的T</span></span><br></pre></td></tr></table></figure>

<p>对比Item1去看，上述这个奇特的规定就是<code>auto类型推导和模板类型推导的唯一不同之处</code>。而这个不同之处存在的根因，实际上是因为<code>auto会假定用大括号括起的初始化表达式代表一个std::initializer_list，但模板类型推导却不会</code>。代码例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>&#125;;       <span class="comment">//x的类型是std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">//带有形参的模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;            <span class="comment">//与x的声明等价的声明式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>&#125;);             <span class="comment">//错误！无法推导T的类型</span></span><br></pre></td></tr></table></figure>

<p>要使得模板推导能够正常工作，那么必须写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>&#125;);             <span class="comment">//T的类型推导为int，从而initList的类型是std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于以上情况，会得出一个常见的很多程序猿的习惯：</p>
<p>很多程序猿都只在必要的时候才会使用大括号括起的初始化表达式</p>
<p>对于C++14来说，额外有几点要说明，C++14比C++11额外支持了<code>auto</code>可以当做返回值。那么根据上述特例的以下代码是无法通过编译的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大括号作为返回值的时候，auto无法推导</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">creatInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;         <span class="comment">//错误，无法为&#123;1,2,3&#125;完成类型推导</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大括号作为入参的时候，auto无法推导</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue)&#123;v = newValue;&#125;; <span class="comment">//C++14</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">resetV</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);             <span class="comment">//错误，无法为&#123;1,2,3&#125;完成类型推导</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 在一般情况下，auto类型推导和模板类型推导是一模一样的。但是auto类型推导会将大括号括起的初始化表达式理解为std::initializer_list，但模板类型推导却不会有这样的理解。</td>
</tr>
<tr>
<td>2. 在函数返回值或lambda表达式中的形参使用auto，意思是用模板类型推导而非auto类型推导。</td>
</tr>
</tbody></table>
<h2 id="条款3-理解decltype"><a href="#条款3-理解decltype" class="headerlink" title="条款3 理解decltype"></a>条款3 理解decltype</h2><h3 id="1-常规用法"><a href="#1-常规用法" class="headerlink" title="1. 常规用法"></a>1. 常规用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;                <span class="comment">//decltype(i) 是 const int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;        <span class="comment">//decltype(w) 是 const Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;                   <span class="comment">//decltype(Point::x)是int</span></span><br><span class="line">&#125;;                              <span class="comment">//decltype(Point::y)是int</span></span><br><span class="line"></span><br><span class="line">Widget w;                       <span class="comment">//decltype(w) 是 Widget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(w))  ...                  <span class="comment">//decltype(f(w))是bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//std::vector简化版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;                  <span class="comment">//decltype(v)是vector&lt;int&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>) ...              <span class="comment">//decltype(v[0])是int&amp;</span></span><br></pre></td></tr></table></figure>

<p>一般来说<code>operator[]</code>会返回T&amp;，只有<code>std::vector&lt;bool&gt;</code> ，并不返回bool&amp;，而返回一个全新对象。这一点需要注意，同时在<code>vector&lt;bool&gt;</code>中有解释。这一点特殊在后续一样会引起很多奇怪的问题，需要格外小心。Item 6中会对此现象进一步详细讲解。</p>
<p>举个使用的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;                <span class="comment">//能运作，但亟需改进</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>-&gt;<span class="title">decltype</span><span class="params">(c[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了一个C++11的特性，<code>返回值类型尾序语法</code>，C++11允许对单表达式的lambda返回值类型进行推导，C++14把这个规则扩张到允许了一切lambda和一切函数，包括多表达式的。那么上述代码段在C++14中展现的形式会是如下这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;                <span class="comment">//C++14，不太正确</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];                                            <span class="comment">//返回值类型是根据c[i]推导出来的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么说这里不太正确呢，考虑这样一种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;           <span class="comment">//验证用户，并返回d[5]，</span></span><br><span class="line">                                    <span class="comment">//然后将其值赋值为10，但是这段代码无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>这是因为<code>authAndAccess(d, 5)</code>的返回值被推导为int，推导过程是<code>d[5]</code>的返回值是<code>int&amp;</code>，但是在返回值中的auto采用的推导方式会剥离引用，这样一来返回值类型就成了<code>int</code>。而作为函数的返回值，这是一个右值，将10赋值给一个右值int，这是被禁止的行为，所以代码没有办法通过编译了。</p>
<p>为了解决这个问题，那么就出现了最为困惑的表达方式了<code>decltype(auto)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;                <span class="comment">//C++14，能够运行，但还是可以优化</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里应该这么理解，这里看上去自相矛盾，但是其实合情合理：</p>
<blockquote>
<p>auto指定的了欲实施推导的类型，而推导过程中采用的是decltype的规则。</p>
</blockquote>
<p>类似的<code>decltype(auto)</code>的用法，在下面的情况下也挺好用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw;            <span class="comment">//auto类型推导：myWidget1的类型是Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw;  <span class="comment">//decltype类型推导：myWidget2的类型是const Widget&amp;</span></span><br></pre></td></tr></table></figure>

<p>那么回到刚刚的问题，为什么说这个模板还可以优化呢，因为这个模板目前无法在下面的用法中使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::deque&lt;std::string&gt; <span class="title">makeStringDeque</span><span class="params">()</span></span>;   <span class="comment">//工厂函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//制作工厂函数makeStringDeque返回的deque的第5个元素的副本</span></span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">authAndAccess</span>(<span class="built_in">makeStringDeque</span>(), <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>这里<code>authAndAccess</code>第一个传参接受了一个右值，但是接受的是一个非常量的左值引用。如果需要这个模板既能接受左值和右值，有两种方式。一种是重载，写一个左值引用形参版本，写一个右值引用形参版本。另一种方法是使用万能引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;            <span class="comment">//c现在是万能引用</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是由于对模板中操作的容器类型不清楚，对未知类型按照值传递会存在诸多风险：</p>
<ol>
<li>非必要的复制操作带来性能隐患。</li>
<li>对象切割<code>slicing</code>问题带来的行为异常。</li>
<li>同行的嘲笑(这里是作者的玩笑，而且Soctt这家伙很喜欢写这个，本着原味，还是保留下来吧。)</li>
</ol>
<p>那么完美的解决方案，还是有的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;                <span class="comment">//C++14，最终版本</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;                <span class="comment">//C++11，最终版本</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span>-&gt;<span class="title">decltype</span><span class="params">(std::forward&lt;Container&gt;(c)[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-特例用法"><a href="#2-特例用法" class="headerlink" title="2. 特例用法"></a>2. 特例用法</h3><p>说说另外会吓人的情况，对于吓人的情况，不多举例，只用一个栗子略见一斑。</p>
<p>说特例之前，要讲解一下decltype的一个推导规则：</p>
<blockquote>
<ol>
<li>decltype应用于一个名字之上，就会得出该名字的声明类型。名字其实是左值表达式。</li>
<li>如果仅有一个名字，decltype的行为保持不变。如果是比仅有名字更复杂的左值表达式的话，decltype就保证得出的类型总是左值引用。</li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//decltype(x) 的结果是int</span></span><br><span class="line"><span class="comment">//decltype((x)) 的结果是int&amp;，因为要满足上述第二条规则。</span></span><br></pre></td></tr></table></figure>

<p>这一点在C++14中更容易不小心触发，原因是有<code>decltype(auto)</code>的场景中。<br>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;           <span class="comment">//decltype(x)是int，所以f1返回的是int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (x);           <span class="comment">//decltype((x))是int&amp;，所以f2返回的是int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里f2函数会返回一个函数局部变量的引用传给函数外部调用者。这是一件多么可怕的事情。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 绝大多数情况下，decltype会得出变量或者表达式的类型而不做任何修改</td>
</tr>
<tr>
<td>2. 对于类型为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出类型T&amp;</td>
</tr>
<tr>
<td>3. C++14支持decltype(auto)，和auto一样，它会从其初始化表达式出发来推导类型，但是它的类型推导使用的是decltype的规则。</td>
</tr>
</tbody></table>
<h2 id="条款4-掌握查看类型推导结果的方法"><a href="#条款4-掌握查看类型推导结果的方法" class="headerlink" title="条款4 掌握查看类型推导结果的方法"></a>条款4 掌握查看类型推导结果的方法</h2><p>对于我们需要查看类型推导结果的时候，主要分为三个阶段：写代码阶段，编译阶段，运行时阶段。</p>
<h3 id="1-IDE编辑器"><a href="#1-IDE编辑器" class="headerlink" title="1. IDE编辑器"></a>1. IDE编辑器</h3><p>IDE编辑器基本上都具有在鼠标悬停在变量或者<code>auto</code> 等字段上会自动推导类型的功能。如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> theAnswer = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> x = theAnswer;</span><br><span class="line"><span class="keyword">auto</span> y = &amp;theAnswer;</span><br></pre></td></tr></table></figure>

<p>IDE编辑器会显示出，x的类型推导结果是int，y的是 const int *。</p>
<h3 id="2-编译器诊断信息"><a href="#2-编译器诊断信息" class="headerlink" title="2. 编译器诊断信息"></a>2. 编译器诊断信息</h3><p>一种另辟蹊径的方式，是故意诱发一个错误，然后让报错提示出类型信息。常用的手法如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//只声明TD而不定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;               <span class="comment">//TD是&quot;类型显示类&quot;的缩写(Type Display)</span></span><br></pre></td></tr></table></figure>

<p>有了这个工具，只要试图具象化该模板，就会诱发一个错误，从而达到让编译器告知类型推导结果的作用，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType;  <span class="comment">//诱发包括x和y的类型错误信息</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(y)&gt; yType;</span><br></pre></td></tr></table></figure>

<p>这段代码编译的时候，会报告如下问题：</p>
<blockquote>
<p>error: aggregate “TD&lt; int &gt; xType” has incomplete type and cannot be defined<br>error: aggregate “TD&lt; const int *&gt; yType” has incomplete type and cannot be defined</p>
</blockquote>
<h3 id="3-运行时输出"><a href="#3-运行时输出" class="headerlink" title="3. 运行时输出"></a>3. 运行时输出</h3><p>C++提供了这样的方式，可以输出某个变量的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>但这种方式有一个弊端，输出的字符不是那么好理解，并且每家编译器的格式都不一样，源于C++委员会并未强制定义需要输出什么样的格式。具体不好理解的字符就不展示了，大家有兴趣可以自己尝试，这里只讲要点</p>
<p>看下面一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;             <span class="comment">//这里GNU和Clang，VS都会显示出Widget const *的类型输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;     <span class="comment">//这里GNU和Clang，VS都会显示出Widget const *的类型输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;Widget&gt; <span class="title">createVec</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> vw = <span class="built_in">createVec</span>();</span><br><span class="line"><span class="keyword">if</span> (!vw.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     <span class="built_in">f</span>(&amp;vw[<span class="number">0</span>]);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的输出看似一致，但实际上却是<strong>错误</strong>的。回忆一下之前的模板类型推导，在模板f中，param被声明称类型const T&amp;。那么如果T是int，param的类型应该就是const int&amp;才对。</p>
<blockquote>
<p>很不幸的是，std::type_info::name并不可靠，更加可怕的是，这种不正确的输出结果是符合标准的。</p>
</blockquote>
<p>而且更加不幸的是，IDE显示的类型信息也并不可靠。还是上面那份代码，某IDE把T显示为：</p>
<blockquote>
<p>const std::_Simple_types&lt; std::_Wrap_alloc&lt; std::_Vec_base_types&lt; Widget, std::allocator&lt; Widget&gt;&gt;::_Alloc&gt;::value_type&gt;::value_type *</p>
</blockquote>
<p>param的类型显示成这样：</p>
<blockquote>
<p>const std::_Simple_types&lt;…&gt;::value_type *const &amp;</p>
</blockquote>
<p>显然冗长的T类型不易理解，param的类型虽然很短，但是有让人困惑的 <code>...</code>存在，其实<code>...</code>就是T的类型的意思。</p>
<p><strong>那么,std::type_info不好用，IDE也不好用，到底有什么好用的呢，其实是有的——<code>Boost的TypeIndex库</code></strong><br><code>Boost.TypeIndex</code>不仅仅是跨平台的，开源的，并且不受编译器解析限制的稳定。上述代码例子用<code>Boost.TypeIndex</code>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; type_id_with_cvr&lt;T&gt;.<span class="built_in">pretty_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param = &quot;</span> &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;.<span class="built_in">pretty_name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;Widget&gt; <span class="title">createVec</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> vw = <span class="built_in">createVec</span>();</span><br><span class="line"><span class="keyword">if</span> (!vw.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">     <span class="built_in">f</span>(&amp;vw[<span class="number">0</span>]);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，无论GNU，Clang，还是VS，均会输出</p>
<blockquote>
<p>T &#x3D; Widget const *<br>param &#x3D; Widget const* const &amp;</p>
</blockquote>
<p>无论IDE，编译器错误消息，还是Boost.TypeIndex库，都只是理解类型推导的辅助工具。他们十分有用，但还是需要写代码者自己对<code>Item1</code> ~ <code>Item3</code>有深入理解的前提下。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 利用IDE编辑器，编译器错误消息，Boost.TypeIndex库常常能够辅助获得类型推导结果。</td>
</tr>
<tr>
<td>2. 上述工具有时候并不完全正确，自身能理解C++类型推导是非常重要的。</td>
</tr>
</tbody></table>
<h1 id="第二章-auto"><a href="#第二章-auto" class="headerlink" title="第二章 auto"></a>第二章 auto</h1><h2 id="条款5-优先选用auto，而非显示类型声明"><a href="#条款5-优先选用auto，而非显示类型声明" class="headerlink" title="条款5 优先选用auto，而非显示类型声明"></a>条款5 优先选用auto，而非显示类型声明</h2><p>auto的优势可不仅仅是让你少打几个类型字符，在有些时候，可以防止手动指定类型带来的错误和性能问题。但这武器也有弊端，在没有IDE的时候，过度auto使用会影响代码的可读性，甚至在极端情况，会有一些意想不到的事情发生。</p>
<h3 id="1-auto的优势"><a href="#1-auto的优势" class="headerlink" title="1. auto的优势"></a>1. auto的优势</h3><h4 id="1-1-优势1：auto语句定义变量在无初始化值的时候无法通过编译"><a href="#1-1-优势1：auto语句定义变量在无初始化值的时候无法通过编译" class="headerlink" title="1. 1 优势1：auto语句定义变量在无初始化值的时候无法通过编译"></a>1. 1 优势1：auto语句定义变量在无初始化值的时候无法通过编译</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1;             <span class="comment">//有潜在的为初始化风险</span></span><br><span class="line"><span class="keyword">auto</span> x2;            <span class="comment">//编译错误！必须要初始化</span></span><br><span class="line"><span class="keyword">auto</span> x3 = <span class="number">0</span>;        <span class="comment">//没有问题，x的值有合适的定义</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-优势2：auto表示可以少打几个字，看起来更加简洁"><a href="#1-2-优势2：auto表示可以少打几个字，看起来更加简洁" class="headerlink" title="1.2 优势2：auto表示可以少打几个字，看起来更加简洁"></a>1.2 优势2：auto表示可以少打几个字，看起来更加简洁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">        <span class="keyword">typename</span> std::iterator_traits&lt;It&gt;::value_type currValue = *b;</span><br><span class="line">        <span class="keyword">auto</span> currValue = *b;            <span class="comment">//采用auto的写法</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-优势3：闭包的类型类型只能用auto表示"><a href="#1-3-优势3：闭包的类型类型只能用auto表示" class="headerlink" title="1.3 优势3：闭包的类型类型只能用auto表示"></a>1.3 优势3：闭包的类型类型只能用auto表示</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11版本</span></span><br><span class="line"><span class="keyword">auto</span> derefUPLess =</span><br><span class="line">    [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1,</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)</span><br><span class="line">    &#123;<span class="keyword">return</span> *p1 &lt; *p2;&#125;;</span><br><span class="line"><span class="comment">// C++14版本，这个版本可用于任何类似指针之物的比较</span></span><br><span class="line"><span class="keyword">auto</span> derefUPLess =</span><br><span class="line">    [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1,</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)</span><br><span class="line">    &#123;<span class="keyword">return</span> *p1 &lt; *p2;&#125;;</span><br></pre></td></tr></table></figure>

<p>也许有人说，用<code>std::function</code>可以表示闭包的类型，这个优势有问题，那么对于这一点，细究一下。其实对于下面的写法，还是有区别的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto版本</span></span><br><span class="line"><span class="keyword">auto</span> derefUPLess =</span><br><span class="line">    [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1,</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)</span><br><span class="line">    &#123;<span class="keyword">return</span> *p1 &lt; *p2;&#125;;</span><br><span class="line"><span class="comment">// std::function版本</span></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;,</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt;</span><br><span class="line">        derefUPLess = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1,</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)</span><br><span class="line">    &#123;<span class="keyword">return</span> *p1 &lt; *p2;&#125;;</span><br></pre></td></tr></table></figure>

<p>撇开function版本的啰嗦不说，性能上同样存在区别。</p>
<ul>
<li><p><code>auto</code>声明的、存储一个闭包的变量，和这个闭包类型相同，所以消耗的存储空间一致。而<code>std::function</code>声明的、存储一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定尺寸的内存。</p>
</li>
<li><p>更糟糕的情况是，上述固定尺寸的内存并不一定够用，在不够的情况下，<code>std::function</code>构造函数会分配堆上的内存来存储该闭包。</p>
</li>
<li><p>再考虑到编译器实现细节会限制内联产生间接函数调用，此时<code>std::function</code>开销会变得更大。</p>
</li>
</ul>
<p>综上对比，在闭包声明的时候，<code>auto</code>是<strong>完胜</strong><code>std::function</code>的。</p>
<h4 id="1-4-优势4：避免不小心造成的类型隐身转换"><a href="#1-4-优势4：避免不小心造成的类型隐身转换" class="headerlink" title="1.4 优势4：避免不小心造成的类型隐身转换"></a>1.4 优势4：避免不小心造成的类型隐身转换</h4><p>用例子说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="type">unsigned</span> sz = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">auto</span> sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>上述两种定义中，sz的类型其实是不同的，<code>v.size()</code>在不同平台下，会产生不同的类型，他的真正类型为<code>std::vector&lt;int&gt;::size_type</code>。在32位的系统里是第一种写法是一致的，但是64位系统里，则会出现类型缩窄。但使用auto的写法则能避免这样的问题。如果这种区别不足以让你觉得满足，那么看看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : m)</span><br><span class="line">&#123;</span><br><span class="line">    ...                 <span class="comment">//在p上实施某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来合理，但是会有极大隐藏的性能损失，<code>std::unordered_map</code>的键值部分是const，所以哈希表中的std::pair的类型不是<code>std::pair&lt;std::string, int&gt;</code>而是<code>std::pair&lt;const std::string, int&gt;</code>。所以编译器会想办法让类型匹配起来，从而将每一个遍历的对象都复制一遍来满足类型匹配。而这个过程无疑调用了数不清次数的拷贝函数和析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : m)</span><br><span class="line">&#123;</span><br><span class="line">    ...                 <span class="comment">//在p上实施某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这样写，一切都没问题了，而且代码也更容易理解了。</p>
<h3 id="2-auto的劣势"><a href="#2-auto的劣势" class="headerlink" title="2. auto的劣势"></a>2. auto的劣势</h3><h4 id="2-1-劣势-1：auto在某些特殊环境下，推导出来的结果不正常"><a href="#2-1-劣势-1：auto在某些特殊环境下，推导出来的结果不正常" class="headerlink" title="2.1 劣势 1：auto在某些特殊环境下，推导出来的结果不正常"></a>2.1 劣势 1：auto在某些特殊环境下，推导出来的结果不正常</h4><blockquote>
<p>详见 item2和 item6</p>
</blockquote>
<h4 id="2-2-劣势-2：auto使用过多会导致代码可读性降低"><a href="#2-2-劣势-2：auto使用过多会导致代码可读性降低" class="headerlink" title="2.2 劣势 2：auto使用过多会导致代码可读性降低"></a>2.2 劣势 2：auto使用过多会导致代码可读性降低</h4><blockquote>
<p>满篇的<code>auto</code>必定让你看不清变量的类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. auto变量必须初始化，基本上对会导致兼容性和效率问题的类型不匹配现象免疫，还可以简化重构流程，通常也比显示指定类型少打一些字。</td>
</tr>
<tr>
<td>2. auto类型变量都有item2和 item6的毛病。</td>
</tr>
</tbody></table>
<h2 id="条款6-当auto推导的类型不符合要求时，使用带显示类型的初始化习惯用法"><a href="#条款6-当auto推导的类型不符合要求时，使用带显示类型的初始化习惯用法" class="headerlink" title="条款6 当auto推导的类型不符合要求时，使用带显示类型的初始化习惯用法"></a>条款6 当auto推导的类型不符合要求时，使用带显示类型的初始化习惯用法</h2><h3 id="1-auto错误场景"><a href="#1-auto错误场景" class="headerlink" title="1. auto错误场景"></a>1. auto错误场景</h3><p>这里列举一个auto会出现推导错误的典型场景，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"><span class="type">bool</span> highPriortiy = <span class="built_in">features</span>(w)[<span class="number">5</span>];     <span class="comment">//w具有高优先级吗？</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">processWidget</span>(w, highPriortiy);         <span class="comment">//按照w的优先级来处理之</span></span><br></pre></td></tr></table></figure>

<p>这上面的代码运行起来都很正常，但是将<code>highPriortiy</code>类型声明的时候换成<code>auto</code>，则后面就会出现未定义的行为了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> highPriortiy = <span class="built_in">features</span>(w)[<span class="number">5</span>];     <span class="comment">//w具有高优先级吗？</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">processWidget</span>(w, highPriortiy);         <span class="comment">//未定义行为！</span></span><br></pre></td></tr></table></figure>

<p>这里<code>auto</code>推导出来的类型不再是<code>bool</code>，而是<code>std::vector&lt;bool&gt;::reference</code>。之所以要弄出一个<code>std::vector&lt;bool&gt;::reference</code> 是因为<code>std::vector&lt;bool&gt;</code>在存储的时候，采用了压缩形式的表示方法，每个bool元素有用一个比特来表示。这种优化方式给<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>带来了一个问题。因为按照<code>std::vector&lt;T&gt;</code>的<code>operator[]</code>应该返回一个<code>T&amp;</code>，但<strong>C++禁止比特的引用</strong>。</p>
<p>那么解决方案是这样的，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>返回了一个<strong>表现的像bool&amp;的对象</strong>，即<code>std::vector&lt;bool&gt;::reference</code>。这里不做细究，大概就是把<code>std::vector&lt;bool&gt;::reference</code>做了一个向<code>bool</code>的隐式类型转换。</p>
<p>我们来分析这两节代码的背后逻辑：</p>
<ul>
<li>对于正常情况<code>非auto</code>下，features返回了一个<code>std::vector&lt;bool&gt;</code>对象，然后针对该对象执行<code>operator[]</code>，返回一个<code>std::vector&lt;bool&gt;::reference</code>对象。然后此对象隐式转换为初始化highPriority所需的bool对象。</li>
<li>对于<code>auto</code>情况下，features返回了一个<code>std::vector&lt;bool&gt;</code>对象，然后针对该对象执行<code>operator[]</code>，返回一个<code>std::vector&lt;bool&gt;::reference</code>对象。<strong>从这里就不一样了</strong>，<code>auto</code>会把<code>highPriority</code>的类型推导成<code>std::vector&lt;bool&gt;::reference</code>。这么一来，后续的路就完全跑偏了，而且这个跑偏后的结果取决于<code>std::vector&lt;bool&gt;::reference</code>的实现方式。</li>
</ul>
<p>如果基于第二条继续延伸一下，则有这样的可能性。有一种<code>std::vector&lt;bool&gt;::reference</code>的实现方式是让对象含有一个指针，指涉到一个机器字（word），该及其子持有的那个被引用的比特，在加上基于那个比特对应的字的偏移量。在这种实现框架下，我们继续探讨。</p>
<p>对features的调用会返回一个<code>std::vector&lt;bool&gt;</code>类型的临时对象，该对象没有名字，但是我们为讨论方便暂且称呼它为<code>temp</code>。针对<code>temp</code>执行<code>operator[]</code>，返回一个<code>std::vector&lt;bool&gt;::reference</code>的对象，此对象含有一个指涉到机器字的指针，该机器字在一个持有<code>temp</code>所管理的那样比特的数据结构中，还要加上在第5个比特所对应的机器字偏移量。由于<code>highPriority</code>是<code>temp</code>的一个副本，所以<code>highPriority</code>也含有一个指涉到<code>temp</code>中的机器字的指针说了那么多屁话，其实就是浅拷贝啦。但是在表达式结尾处<code>temp</code>被<strong>析构</strong>了，因为它是个临时对象！这个时候要命的<code>highPriority</code>里就有悬空指针啦。</p>
<h3 id="2-总结：auto在什么时候会出错"><a href="#2-总结：auto在什么时候会出错" class="headerlink" title="2. 总结：auto在什么时候会出错"></a>2. 总结：auto在什么时候会出错</h3><blockquote>
<p>auto和 “隐形”代理类无法和平共处</p>
</blockquote>
<p>代理类，就是为了模拟或增广其他类型的类。</p>
<ul>
<li>模拟：例如<code>std::vector&lt;bool&gt;::reference</code>就是为了制造<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>返回了一个比特引用的假象。这个同样的例子在<code>std::bitset</code>对应的<code>std::bitset::reference</code>里也一样.</li>
<li>增广： 表达式模板技术，提高数值计算代码的效率。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix sum = m1 + m2 + m3 + m4;</span><br></pre></td></tr></table></figure>

<p>这里Matrix对象的<code>operator+</code>返回的是结果的代理而不是结果本身，则上述计算会高效很多。</p>
<p>总体说来，我们需要避免如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> someVar = <span class="string">&quot;隐形&quot;</span>代理类型表达式;</span><br></pre></td></tr></table></figure>

<h3 id="3-如何发现“隐形”代理类"><a href="#3-如何发现“隐形”代理类" class="headerlink" title="3. 如何发现“隐形”代理类"></a>3. 如何发现“隐形”代理类</h3><p>因为隐形代理类的设计就是为了隐藏细节，所以一般来说使用过程中设计者是尽可能让人不察觉到。这个时候一般只能从源码&#x2F;说明文档里找到端倪。</p>
<ul>
<li>文档：使用的库往往会在文档中写明这一点。</li>
<li>头文件：假设已经知道<code>std::vector&lt;T&gt;</code>的<code>operator[]</code>返回值是T&amp;，但是看到了返回值不是这样，而是定义了一个新的类型。那么应该是代理类。</li>
</ul>
<h3 id="4-对于“隐形”代理类的处理方式"><a href="#4-对于“隐形”代理类的处理方式" class="headerlink" title="4. 对于“隐形”代理类的处理方式"></a>4. 对于“隐形”代理类的处理方式</h3><p>即便发现有隐形代理类的时候，<code>auto</code>可能不太好用，但也可以用别的方式让<code>auto</code>继续起效。例如下述方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>这种方式必定能能够让代码稳妥的运行，也能使<code>auto</code>继续起效。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. “隐形”的代理类型可以导致auto根据初始化表达式推导出“错误的”类型。</td>
</tr>
<tr>
<td>2. 带显示类型的初始化习惯用法强制auto推导出你想要的类型。</td>
</tr>
</tbody></table>
<h2 id="条款7-在创建对象时注意区分-和"><a href="#条款7-在创建对象时注意区分-和" class="headerlink" title="条款7 在创建对象时注意区分()和{}"></a>条款7 在创建对象时注意区分()和{}</h2><p>在C++11中，一个变量初始化的表达方式有太多种，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;           <span class="comment">//初始化值在小括号内</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;          <span class="comment">//初始化值在等号后</span></span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;           <span class="comment">//初始化值在大括号内</span></span><br><span class="line"><span class="type">int</span> z = &#123;<span class="number">0</span>&#125;;        <span class="comment">//使用等号和大括号来指定初始化值，被视作只有大括号</span></span><br><span class="line">                    <span class="comment">//但由于有等号的存在，往往会让人误以为赋值了，实际没有。</span></span><br></pre></td></tr></table></figure>

<p>像<code>int</code>这样的<code>内置类型</code>，初始化和赋值只是学术之争，没太多区别。但是自定义对象差别就很大了，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;          <span class="comment">//调用的是默认构造函数</span></span><br><span class="line">Widget w2 = w1;     <span class="comment">//并非赋值，调用的是复制构造函数</span></span><br><span class="line">w1 = w2;            <span class="comment">//并非赋值，调用的是复制赋值运算符</span></span><br></pre></td></tr></table></figure>

<h3 id="1-大括号初始化的特点"><a href="#1-大括号初始化的特点" class="headerlink" title="1. 大括号初始化的特点"></a>1. 大括号初始化的特点</h3><blockquote>
<p>C++11引入了统一初始化：单一的、至少从概念上可以用于一切场合、表达 一切意思的初始化。</p>
</blockquote>
<p>“统一初始化”是目的，“大括号初始化”是表象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以办到之前不能办到的事情</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;  v&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;         <span class="comment">//v的初始内容为1,3,5</span></span><br><span class="line"><span class="comment">//可以在非静态成员指定默认初始化值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x &#123;<span class="number">0</span>&#125;;                      <span class="comment">//可行，x的默认值为0</span></span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;                      <span class="comment">//也可行</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;                       <span class="comment">//不行!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不可复制的对象也可以用大括号和小括号初始化</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;;            <span class="comment">//可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai2</span><span class="params">(<span class="number">0</span>)</span></span>;            <span class="comment">//可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; ai3 = <span class="number">0</span>;           <span class="comment">//不行！</span></span><br></pre></td></tr></table></figure>

<p>由上可知，只有大括号初始化的方式能用于各种场景，所以又被称之为<code>统一初始化</code>。</p>
<h3 id="2-大括号初始化的规则"><a href="#2-大括号初始化的规则" class="headerlink" title="2. 大括号初始化的规则"></a>2. 大括号初始化的规则</h3><ul>
<li>大括号初始化禁止内建类型之间进行隐式窄化类型转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> sum1&#123;x + y + z&#125;;                <span class="comment">//错误！double类型之和无法使用int表达</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(x + y + z)</span></span>;                <span class="comment">//没问题，表达式被截断为int</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z;               <span class="comment">//没问题，表达式被截断为int</span></span><br></pre></td></tr></table></figure>

<ul>
<li>大括号初始化可以避开最令人苦恼的解析语法。</li>
</ul>
<p>这个规则源于C++的一个规定：</p>
<blockquote>
<p>任何能够解析为声明的都要解析为声明</p>
</blockquote>
<p>这会带来一个副作用，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;                  <span class="comment">//调用Widget的构造函数，传入形参10</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;                    <span class="comment">//最令人苦恼的解析语法！</span></span><br><span class="line">                                <span class="comment">//这个语句声明了一个名为w2、返回了Widget类型对象的函数！</span></span><br><span class="line">Widget w3&#123;&#125;;                    <span class="comment">//调用没有形参的Widget构造函数！对解析为声明的陷阱免疫！</span></span><br></pre></td></tr></table></figure>

<h3 id="3-大括号初始化不合适的场景"><a href="#3-大括号初始化不合适的场景" class="headerlink" title="3. 大括号初始化不合适的场景"></a>3. 大括号初始化不合适的场景</h3><p>大括号初始化不合适的场景主要体现在<code>大括号</code>、<code>std::initializer_list</code>、<code>构造函数重载</code>之间的纠葛。这三者之间在解析的时候，容易出现<strong>不是你觉得而是编译器觉得的问题</strong>。</p>
<p>而且从结果上来看，很容易引起越喜欢使用<code>auto</code>，恐怕就会越来越对大括号初始化排斥。</p>
<ul>
<li>构造函数不具备<code>std::initializer_list</code>类型的时候，大括号和小括号是等价的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);          <span class="comment">//构造函数不具备任何一个std::initializer_list类型</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;                <span class="comment">//调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;                <span class="comment">//调用第一个构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;                 <span class="comment">//调用第二个构造函数</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;;                 <span class="comment">//调用第二个构造函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>但是如果构造函数里生命了任何一个具备<code>std::initializer_list</code>的形参，那么编译器会<strong>特别强烈</strong>的优先选用带有<code>std::initializer_list</code>形参的版本，甚至平常的复制和移动构造函数会<strong>被劫持</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);          </span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il);  <span class="comment">//增加的版本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span>;                         <span class="comment">//强制转换为float类型</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;                <span class="comment">//调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;                <span class="comment">//调用第三个构造函数，10，true强转为long double</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;                 <span class="comment">//调用第二个构造函数</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;;                 <span class="comment">//调用第三个构造函数，10，5.0强转为long double</span></span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>;                      <span class="comment">//调用复制构造函数</span></span><br><span class="line">Widget w6&#123;w4&#125;;                      <span class="comment">//调用第三个构造函数，w4的返回值被强转成float，</span></span><br><span class="line">                                    <span class="comment">//然后再被强转成long double，再去匹配</span></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(std::move(w4))</span></span>;           <span class="comment">//调用移动构造函数</span></span><br><span class="line">Widget w8&#123;std::<span class="built_in">move</span>(w4)&#125;;           <span class="comment">//调用第三个构造函数，和w6一样的结果</span></span><br></pre></td></tr></table></figure>

<p>更有甚者，在无法进行强转的时候，编译器会拒绝能够匹配上的构造函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);          </span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">bool</span>&gt; il);     <span class="comment">//容器元素类型现在是bool</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w&#123;<span class="number">10</span>， <span class="number">5.0</span>&#125;;           <span class="comment">//错误！要求窄化类型转换</span></span><br></pre></td></tr></table></figure>

<p>编译器依旧会选择第三个带有<code>std::initializer_list</code>的构造函数，但是由于10和5.0转化成bool会造成窄化类型转换，这一点不符合大括号初始化的规则，所以<strong>编译通不过</strong>！</p>
<p>但如果把上述<code>std::initializer_list&lt;bool&gt;</code>换成<code>std::initializer_list&lt;std::string&gt;</code>的时候，一切会正常。因为只有在找不到任何办法把大括号初始化物中实参转换成模板类型的时候，编译器才会放弃使用<code>std::initializer_list</code>的初始化。</p>
<ul>
<li>边界情况讨论：空大括号和默认构造函数</li>
</ul>
<blockquote>
<p>结论：空大括号表示没有实参，调用默认构造函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">int</span>&gt; il);     <span class="comment">//容器元素类型现在是int</span></span><br><span class="line">    ...                                        <span class="comment">//并没有隐式强制类型转换函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1;              <span class="comment">//调用默认构造函数</span></span><br><span class="line">Widget w2&#123;&#125;;            <span class="comment">//调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>;            <span class="comment">//最令人苦恼的语法，这里变成了声明</span></span><br><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>;          <span class="comment">//带有std::initializer_list类型的构造函数，传入空的initializer_list</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;;          <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<p>以上介绍完所有规则，下面介绍一个日常编码中会遇到的常见问题：</p>
<h3 id="4-介绍常见例子以及使用场景"><a href="#4-介绍常见例子以及使用场景" class="headerlink" title="4. 介绍常见例子以及使用场景"></a>4. 介绍常见例子以及使用场景</h3><p>STL中的<code>std::vector&lt;T&gt;</code>就会遇到这种问题。<br>在C++11中，<code>std::vector&lt;T&gt;</code>就拥有<code>std::initializer_list</code>作为构造参数的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先来看std::vector构造函数声明</span></span><br><span class="line"><span class="comment">// ******************</span></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="comment">// Constructs an empty container, with no elements.</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(<span class="type">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill constructor</span></span><br><span class="line"><span class="comment">// Constructs a container with n elements. Each element is a copy of val (if provided).</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line">         <span class="built_in">vector</span> (size_type n, <span class="type">const</span> value_type&amp; val,</span><br><span class="line">                 <span class="type">const</span> allocator_type&amp; alloc = <span class="built_in">allocator_type</span>());</span><br><span class="line">......</span><br><span class="line"><span class="comment">// initializer list constructor</span></span><br><span class="line"><span class="comment">// Constructs a container with a copy of each of the elements in il, in the same order.</span></span><br><span class="line"><span class="built_in">vector</span> (initializer_list&lt;value_type&gt; il,</span><br><span class="line">       <span class="type">const</span> allocator_type&amp; alloc = <span class="built_in">allocator_type</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// *****************</span></span><br><span class="line"><span class="comment">// 调用了fill constructor</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; </span><br><span class="line"><span class="comment">// 调用了initializer list constructor</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这里{}和()不一致的地方值得注意。</p>
<ul>
<li>当你是一个类作者，需要避免将构造函数中声明了<code>std::initializer_list</code>类型的形参。最好把构造函数设计成()和{}的体现一致的情况。从这个角度看来，<strong>一般把<code>std::vector</code>的接口设计视为败笔，应该从中汲取教训，避免同类行为。</strong></li>
</ul>
<p>所以当你在一个类中新增构造函数为<code>std::initializer_list</code>类型的时候，心中需要格外小心，避免<code>std::initializer_list</code>覆盖其他构造函数的情况。</p>
<p>当你是一个开发模板的程序猿，那么创建对象的时候，选用小括号还是大括号的问题，会变得非常的头疼。<strong>总体来说，选用什么都不好。</strong></p>
<p>具体例子介绍如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span></span><br><span class="line"><span class="function">        <span class="keyword">typename</span>... TS&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(TS&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用params创建局部对象T</span></span><br><span class="line">    <span class="function">T <span class="title">localObject</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>;     <span class="comment">//选择小括号</span></span><br><span class="line">    T localObject&#123;std::forward&lt;Ts&gt;(params)...&#125;;     <span class="comment">//选择大括号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑一下调用代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>如果采用小括号的方式，那么最终这个对象会包含10个元素的vector，如果采用大括号的方式，会得到一个2个元素的vector。那么究竟谁对谁错呢。其实只有调用者才有决定权。</p>
<p>而这种情况其实在标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>中就有这样的考量。他们的做法是在内部使用了小括号，并且用文档的形式广而告知。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 大括号初始化可以应用的语境最为广泛，可以阻止隐式窄化类型转换，还对最令人苦恼的解析语法免疫。</td>
</tr>
<tr>
<td>2. 在构造函数重载决议期间，只要有任何可能性，大括号初始化就会与带有std::initializer_list类型的形参相匹配，即使其他重载版本有着更加匹配的形参表。</td>
</tr>
<tr>
<td>3. 使用小括号还是大括号，会造成结果大相径庭的例子：使用两个实参来创建一个std::vector&lt;数值类型&gt;对象。</td>
</tr>
<tr>
<td>4. 在模板内容进行对象创建时，到底应该用小括号还是大括号会成为一个棘手问题。</td>
</tr>
</tbody></table>
<h1 id="第三章-迁移到现代C"><a href="#第三章-迁移到现代C" class="headerlink" title="第三章 迁移到现代C++"></a>第三章 迁移到现代C++</h1><h2 id="条款8-优先选用nullptr，而非0或NULL"><a href="#条款8-优先选用nullptr，而非0或NULL" class="headerlink" title="条款8 优先选用nullptr，而非0或NULL"></a>条款8 优先选用nullptr，而非0或NULL</h2><p>字面常量是0的类型是int，而非指针。而NULL的类型不确定，但不具有指针类型。</p>
<p>这样的问题可以会出现在以下代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);               <span class="comment">//调用的是f(int)，而不是f(void*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);            <span class="comment">//可能通不过编译，一般也会调用f(int)，从不会调用f(void*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);         <span class="comment">//调用的是f(void*)</span></span><br></pre></td></tr></table></figure>

<p>实际上，指导原则是<strong>不要在指针类型和整型之间做重载</strong>。但如果有这样的重载，那么只有<code>nullptr</code>是可以匹配上的。</p>
<blockquote>
<p><code>nullptr</code> 不具备整型类型，实际上，它也不具备指针类型，但它可以隐式转换到所有裸指针类型。</p>
</blockquote>
<p>以上优点还并不是<code>nullptr</code>的唯一优点，它还可以让代码更加清晰：</p>
<p><strong>nullptr使代码更清晰</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">findRecord</span>(<span class="comment">/* 实参 */</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">findRecord</span>(<span class="comment">/* 实参 */</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述第一种写法会有多义性，导致无法明了result的类型，但是第二种写法一眼可以看出result是个指针。</p>
<p><strong>更大的优势在于nullptr用于模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(std::unique_ptr&lt;Widget&gt; upw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;</span><br><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">std::mutex f1m, f2m, f3m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> MuxGurad = std::lock_guard&lt;std::mutex&gt;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f1m)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">f1</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f2m)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">f2</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f3m)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">f3</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上代码就能运作，这时候，看到重复的代码流程，我们想写模板的思想就产生出来了，一定要泛化一个呗。于是乎，来了如下的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> MuxType, <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lockAndCall</span><span class="params">(FuncType func, MuxType&amp; mutex, PtrType ptr)</span>-&gt;<span class="title">decltype</span><span class="params">(func(ptr))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span> MuxType, <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">lockAndCall</span><span class="params">(FuncType func, MuxType&amp; mutex, PtrType ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用示例：</span></span><br><span class="line"><span class="keyword">auto</span> result1 = <span class="built_in">lockAndCall</span>(f1, f1m, <span class="number">0</span>);         <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">lockAndCall</span>(f2, f2m, <span class="literal">NULL</span>);      <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">auto</span> result3 = <span class="built_in">lockAndCall</span>(f3, f3m, <span class="literal">nullptr</span>);   <span class="comment">//没问题！</span></span><br></pre></td></tr></table></figure>

<p><code>result1</code>无法编译的问题是因为<code>0</code>将<code>PtrType</code>推导为<code>int</code>，那么func对应的传入就为int，与f1期望的<code>std::shared_ptr</code>不兼容。而<code>result2</code>的错误与<code>result1</code>类似。而由于<code>nullptr</code>由于肯定不会被解析为<code>int</code>从而免疫了这种问题。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 相对于0或NULL，优先选用nullptr。</td>
</tr>
<tr>
<td>2. 避免在整型和指针类型之间重载。</td>
</tr>
</tbody></table>
<h2 id="条款9-优先选用别名声明，而非typedef"><a href="#条款9-优先选用别名声明，而非typedef" class="headerlink" title="条款9 优先选用别名声明，而非typedef"></a>条款9 优先选用别名声明，而非typedef</h2><p>先看个代码显示差别：</p>
<h3 id="1-优势1：容易理解"><a href="#1-优势1：容易理解" class="headerlink" title="1. 优势1：容易理解"></a>1. 优势1：容易理解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见用法差别，可能不明显</span></span><br><span class="line"><span class="keyword">typedef</span> std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS;</span><br><span class="line"><span class="keyword">using</span> UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span><br><span class="line"><span class="comment">// 在涉及函数指针的时候，更容易理解</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> std::string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">using</span> FP = <span class="built_in">void</span>(*)(<span class="type">int</span>, <span class="type">const</span> std::string&amp;);</span><br></pre></td></tr></table></figure>

<h3 id="2-优势2：可以在模板化（typedef无法直接做到）"><a href="#2-优势2：可以在模板化（typedef无法直接做到）" class="headerlink" title="2. 优势2：可以在模板化（typedef无法直接做到）"></a>2. 优势2：可以在模板化（typedef无法直接做到）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure>

<p><code>typedef</code>在上述情况下，只能通过一个嵌套在struct里的typedef才能曲折的达到这种效果。并且使用这种曲折方式带来的弊端会在继续使用<code>MyAllocList</code>这个模板的时候体现出来，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;         <span class="comment">//这里必须要用typename</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//using版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyAllocList&lt;T&gt; list;                        <span class="comment">//这里和普通写法没什么太大区别了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>造成这个现象的原因是，C++有一个规则是这样的：</p>
<blockquote>
<p>带依赖类型必须前面加一个typename</p>
</blockquote>
<p>这里的<code>MyAllocList&lt;T&gt;::type</code>代表一个依赖于模板类型形参（T）的类型。而用using版本的时候，即别名模板的时候，编译器就知道了<code>MyAllocList&lt;T&gt;</code>是个模板的名字，那么就是一个非依赖类型。由于编译器看到<code>MyAllocList&lt;T&gt;::type</code>的时候，无法断定这个就是一个类型命名，这东西说不定是一个变量，例如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wine</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocList</span>&lt;Wine&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">WineType</span> &#123;White, Red, Rose&#125;;</span><br><span class="line">    WineType type;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>MyAllocList&lt;T&gt;::type</code>真真切切就成了一个数据成员，而并不是一个类型。也就是说的确是会存在二义性，所以编译器坚持需要通过在前面加一个<code>typename</code>的方式断定这个是一个类型。</p>
<p>而如果接触过模板元编程(<code>template metaprogramming</code>，<code>TMP</code>)，那么肯定有需求需要从模板类型形参触发来修正类型的需求。C++11中以(<code>type trait</code>)的形式给了程序猿执行此类变量的工具。在头文件<code>type_traits</code>中给出了一整套模板，其中给出了转换类型的接口如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line">std::remove_const&lt;T&gt;::type              <span class="comment">//由const T生成T</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type          <span class="comment">//由T&amp;或者T&amp;&amp;生成T</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type      <span class="comment">//由T生成T&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上注释只是给出变换结论，请勿抠字眼，具体使用请具体查明。</span></span><br></pre></td></tr></table></figure>

<p>可以看到C++11中这些<code>type_traits</code>里的实现依旧不符合现代C++编程风格，但是这是有历史原因的（由于是一篇枯燥的长篇大论，这里不展开，总之委员会里的人后知后觉了。）所以，对我们使用者来说，C++11里<code>type_traits</code>用于模板编程的时候，一样要用<code>typename</code>。因为底层实现也是<code>typedef</code> + <code>struct</code>的方式。那么C++14中有这样的模板了，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type          <span class="comment">// C++11：const T -&gt;   T</span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt;              <span class="comment">// C++14：const T -&gt;   T</span></span><br><span class="line"></span><br><span class="line">std::remove_reference&lt;T&gt;::type          <span class="comment">// C++11：T&amp;/T&amp;&amp; -&gt;   T</span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt;              <span class="comment">// C++14：T&amp;/T&amp;&amp; -&gt;   T</span></span><br><span class="line"></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type      <span class="comment">// C++11：T  -&gt;   T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt;          <span class="comment">// C++14：T  -&gt;   T&amp;</span></span><br></pre></td></tr></table></figure>

<p>即便是在C++11中，想要实现这个C++14中的功能，其实也非常容易，只需要加两行定义一下即可，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">add_lvalue_reference_t</span> = <span class="keyword">typename</span> add_lvalue_reference&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. typedef 不支持模板化，但别名声明支持。</td>
</tr>
<tr>
<td>2. 别名模板可以让人不用写<code>::type</code>后缀，并且在模板内不用像内嵌<code>typedef</code>一样加<code>typename</code>前缀。</td>
</tr>
</tbody></table>
<h2 id="条款10-优先选用限定作用于的枚举类型，而非不限作用于的枚举类型"><a href="#条款10-优先选用限定作用于的枚举类型，而非不限作用于的枚举类型" class="headerlink" title="条款10 优先选用限定作用于的枚举类型，而非不限作用于的枚举类型"></a>条款10 优先选用限定作用于的枚举类型，而非不限作用于的枚举类型</h2><p>先来一个通用规则：</p>
<blockquote>
<p>如果在一对大括号里声明一个名字，则该名字的可见性 限定在括号括起来的作用域内。</p>
</blockquote>
<p>但这个规则有个例外 <em><strong>C++98风格的枚举类型不受此限制</strong></em>。</p>
<p>这个例外导致一下代码会有错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;black, white, red&#125;;     <span class="comment">//black, white, red所在的作用域和Color相同</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                 <span class="comment">//错误！white已经在范围内被声明过了</span></span><br></pre></td></tr></table></figure>

<h3 id="1-优势1：不会造成命名污染"><a href="#1-优势1：不会造成命名污染" class="headerlink" title="1. 优势1：不会造成命名污染"></a>1. 优势1：不会造成命名污染</h3><p>这种枚举量名字泄露会带来很多弊端，有时候一不小心就发现名字被使用了，官方将这种枚举称之为<code>不限范围的枚举类型</code>，有时也被称作<code>枚举类</code>。而在C++11中，它的对等物，限定作用域枚举类型，将修复这种弊端。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;black, white, red&#125;;       <span class="comment">//限定所在作用域的枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                         <span class="comment">//没问题，white被限定在Color内</span></span><br><span class="line"></span><br><span class="line">Color c = white;                            <span class="comment">//错误，范围内没有white的枚举量</span></span><br><span class="line"></span><br><span class="line">Color c = Color::white;                     <span class="comment">//没问题！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;                      <span class="comment">//同样没问题！</span></span><br></pre></td></tr></table></figure>

<h3 id="2-优势2：限定作用域的枚举量是强类型的"><a href="#2-优势2：限定作用域的枚举量是强类型的" class="headerlink" title="2. 优势2：限定作用域的枚举量是强类型的"></a>2. 优势2：限定作用域的枚举量是强类型的</h3><p>看以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;black, white, red&#125;;         <span class="comment">//不限定范围的枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::<span class="type">size_t</span>&gt; </span></span><br><span class="line"><span class="function">    <span class="title">primeFactors</span><span class="params">(std::<span class="type">size_t</span> x)</span></span>;        <span class="comment">//函数，返回x的质因数</span></span><br><span class="line"></span><br><span class="line">Color c = red;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123;                         <span class="comment">//将Color类型和double类型值比较！</span></span><br><span class="line">    <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c);     <span class="comment">//计算一个Color类型的质因数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是把一个简单的<code>class</code>加入到<code>enum</code>之后，语义就完全不同了，限定作用域的枚举类型不存在任何隐式转换路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;black, white, red&#125;;   <span class="comment">//不限定作用域的枚举类型</span></span><br><span class="line"></span><br><span class="line">Color c = Color::red;                   <span class="comment">//同前，但要加范围限定饰词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>)&#123;                          <span class="comment">//错误！不能将Color和double比较</span></span><br><span class="line">    <span class="keyword">auto</span> factors =                      <span class="comment">//错误！不支持隐式转换</span></span><br><span class="line">        <span class="built_in">primeFactors</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果真的要比较，那么只用 <code>static_cast&lt;double&gt;(c)</code>即可。</p>
<h3 id="3-优势3：限定作用域的枚举类型可以前置声明"><a href="#3-优势3：限定作用域的枚举类型可以前置声明" class="headerlink" title="3. 优势3：限定作用域的枚举类型可以前置声明"></a>3. 优势3：限定作用域的枚举类型可以前置声明</h3><p>实例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>;             <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>;       <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>其实这种限制并非因为枚举的原因不能前置声明，而是基于以下这个事实导致必须在前置声明中定义好：</p>
<blockquote>
<p>一切枚举类型在C++里都会由编译器来选择一个整数类型作为其底层类型。</p>
</blockquote>
<p>类似如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;black, white, red&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器会选择<code>char</code>作为底层类型，因为只有3个值要表示。有些枚举类型取值范围就大得多，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; good = <span class="number">0</span>,</span><br><span class="line">              failed = <span class="number">1</span>,</span><br><span class="line">              incomplete = <span class="number">100</span>,</span><br><span class="line">              corrupt = <span class="number">200</span>,</span><br><span class="line">              indeterminate = <span class="number">0xFFFFFFFF</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码需要表示的范围从 <code>0</code> ~ <code>0xFFFFFFFF</code>，那么对于这种类型就不是用char来存储了。一般来说编译器会选择满足范围的最小底层类型。但在某种情况下，编译器会用空间换时间，所以无限制枚举类型就没有一个固定的规则，要求必须在声明的时候，逐个确认底层类型选择哪一种。</p>
<p>不过以上前置声明能力的缺失还是会造成一些弊端。最大弊端是它会增加编译依赖性。考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; good = <span class="number">0</span>,</span><br><span class="line">              failed = <span class="number">1</span>,</span><br><span class="line">              incomplete = <span class="number">100</span>,</span><br><span class="line">              corrupt = <span class="number">200</span>,</span><br><span class="line">              audited = <span class="number">500</span>,        <span class="comment">//由于新需求加入了新的枚举</span></span><br><span class="line">              indeterminate = <span class="number">0xFFFFFFFF</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这种新需求会带来整个项目可能都需要重新编译。这是一个令人讨厌的情况，但如果使用C++11的前置声明则可以免疫这种弊端。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>;                  <span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">continueProcessing</span><span class="params">(Status s)</span></span>;  <span class="comment">//取用前置声明的枚举类型</span></span><br></pre></td></tr></table></figure>

<p>如果采用上述方式，则在Status定义发生改变的时候，不需要重新编译，并且continueProccessing由于并未用到上述新增定义的时候，也同样无需重新编译。</p>
<p>造成这种现象的原因其实是由于以下规则：</p>
<blockquote>
<p>限定作用域的枚举类型的底层类型是 <em><strong>int</strong></em>。</p>
</blockquote>
<p>正是由于这种特点，所以不限定类型的枚举可以前置声明，因为底层类型是确定的。更有甚者，不限定类型的枚举通过这种方式也可以前置声明。例如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>: std::<span class="type">uint8_t</span>;               <span class="comment">//不限定范围的枚举也能前置声明了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span> &#123;      <span class="comment">//在定义中指定也是可以的</span></span><br><span class="line">    good = <span class="number">0</span>,</span><br><span class="line">    failed = <span class="number">1</span>,</span><br><span class="line">    incomplete = <span class="number">100</span>,</span><br><span class="line">    corrupt = <span class="number">200</span>,</span><br><span class="line">    audited = <span class="number">500</span>,        </span><br><span class="line">    indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-特例：在有些情况下，不限定范围枚举还是有意义的"><a href="#4-特例：在有些情况下，不限定范围枚举还是有意义的" class="headerlink" title="4. 特例：在有些情况下，不限定范围枚举还是有意义的"></a>4. 特例：在有些情况下，不限定范围枚举还是有意义的</h3><blockquote>
<p>当C++11中使用std::tuple类型的各个域时候，不限定范围枚举比较方便。</p>
</blockquote>
<p>实例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo                      <span class="comment">//类型别名，参见Item 9</span></span><br><span class="line">        = std::tuple&lt;std::string,   <span class="comment">//名字</span></span><br><span class="line">                     std::string,   <span class="comment">//电子邮件</span></span><br><span class="line">                     std::<span class="type">size_t</span>&gt;;  <span class="comment">//声望值</span></span><br><span class="line"><span class="comment">//用法</span></span><br><span class="line">UserInfo uInfo;                     <span class="comment">//std::tuple类型对象</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(uInfo);      <span class="comment">//取用域1的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用1来表示则显得十分不清晰了，而采用一个不限范围的</span></span><br><span class="line"><span class="comment">//枚举类型则会好很多</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123;uiName, uiEmail, uiReputation&#125;;</span><br><span class="line">UserInfo uInfo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo);    <span class="comment">//多么直观，取用的电子邮件</span></span><br></pre></td></tr></table></figure>

<p>但是如果要使用限定作用域的枚举类型版本的对应代码，就啰嗦很多，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfoFields</span> &#123;uiName, uiEmail, uiReputation&#125;;</span><br><span class="line">UserInfo uInfo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> val = </span><br><span class="line">   std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;</span><br><span class="line">    (uInfo);</span><br></pre></td></tr></table></figure>

<p>如果想不这么啰嗦，则需要些一个函数，以枚举量为形参并返回其对应的<code>std::size_t</code>类型的值，这样不太容易，因为<code>std::get</code>是个模板，而传入的值是个模板形参，所以这个将枚举量变换成<code>std::size_t</code>类型值的函数必须在编译期就计算出来。那么必须用<code>constexpr</code>，并且返回值还需要泛化，不能返回<code>std::size_t</code>而需要返回枚举底层类型，而这个类型需要用<code>std::underlying_type</code>类型特征取得。最后还需要声明为<code>noexcept</code>。那么最终的形式差不多是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::underlying_type&lt;E&gt;::<span class="function">type </span></span><br><span class="line"><span class="function">    <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span></span><br><span class="line">                    std::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C++14，复杂写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">underlying_type_t</span>&lt;E&gt; </span></span><br><span class="line"><span class="function">    <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C++14，简单写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在我们有这个函数的基础上，终于可以这样访问：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>

<p>可以发现，即便这样写依旧很复杂，这个时候无限定作用域的枚举会好一些。但除此之外，绝大多数情况还是不要用这种技术，毕竟它<code>无限定作用域枚举</code>发明的时候，最高端的数据通信还是用的2400波特率的调制解调器。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. C++98风格的枚举类型，现在称为不限定范围枚举。</td>
</tr>
<tr>
<td>2. 限定作用域范围枚举仅在枚举类型内可见。他们只能通过强转进行转换。</td>
</tr>
<tr>
<td>3. 限定作用域&#x2F;不限定作用域枚举都支持底层类型指定。限定作用域枚举底层类型默认是int，不限定作用域没有默认。</td>
</tr>
<tr>
<td>4. 限定作用域枚举总是可以前置声明，不限定作用域枚举只有指定了默认类型才能前置声明。</td>
</tr>
</tbody></table>
<h2 id="条款11-优先选用删除函数，而非private未定义函数"><a href="#条款11-优先选用删除函数，而非private未定义函数" class="headerlink" title="条款11 优先选用删除函数，而非private未定义函数"></a>条款11 优先选用删除函数，而非private未定义函数</h2><p>有时候，你写了代码给其他程序员用，并且你想组织他们调用某个特定函数的话，你只需不要声明该函数即可。函数未经声明，不可调用，易如反掌。但是有些特定函数编译器会帮你生成，那么这个时候C++98里的一种常用处理方式是将其声明为私有函数，并且不去定义他们。例如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;);            <span class="comment">//not defined</span></span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;); <span class="comment">//not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过设置私有，阻止客户调用他们</li>
<li>通过不定义他们，组织成员函数，友元使用他们</li>
</ul>
<p>而在C++11中，有更好的途径达到上述效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>; </span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11中这样简单的改动，其实彻底断绝了这些被禁止的函数的调用。声明私有不定义的方式，在编译阶段友元函数一样可以调用他们，在链接阶段才会因为未定义报错，而C++11中连编译阶段都无法进行下去。</p>
<p><em><strong>习惯上，把<code>delete</code>函数定为public</strong></em></p>
<p>编译器一般会先校验可访问性，然后校验删除状态。如果设置为private则编译器报错的时候，不会告知其为删除函数，而报告private属性。<em><strong>在修改遗留代码的时候切记将<code>private</code>换为<code>public</code>。</strong></em></p>
<h3 id="1-优势1：任何函数均可设置为delete，但只有成员函数可以private"><a href="#1-优势1：任何函数均可设置为delete，但只有成员函数可以private" class="headerlink" title="1. 优势1：任何函数均可设置为delete，但只有成员函数可以private"></a>1. 优势1：任何函数均可设置为delete，但只有成员函数可以private</h3><p>看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>)) ...   <span class="comment">//&#x27;a&#x27;是个幸运数字么</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="literal">true</span>)) ...  <span class="comment">//true又如何</span></span><br><span class="line"><span class="keyword">if</span> (isLucky（<span class="number">3.5</span>)) ...  <span class="comment">//是不是应该先截断为3，再检查是否幸运</span></span><br></pre></td></tr></table></figure>

<p>如果幸运数字必须是整数，那么我们想要阻止上面这样的调用通过编译，而delete这个时候有个这样的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;      <span class="comment">//原始版本</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span></span>;            <span class="comment">//拒绝char类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span></span>;            <span class="comment">//拒绝bool类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span></span>;          <span class="comment">//拒绝double和float类型</span></span><br></pre></td></tr></table></figure>

<p>以上有个特殊点在于，删除了double但是float也禁止了。因为float面临转入int还是double的时候，会使用double类型。然后发现double类型函数被删除了，所以也被禁止了。所以这里禁止函数的机制，是</p>
<blockquote>
<p>尽管删除函数不可使用，但它们还是程序的一部分，在重载的时候还是会被纳入考量，如果发现被删除，则拒绝编译。</p>
</blockquote>
<h3 id="2-优势2：阻止不应该具现的模板"><a href="#2-优势2：阻止不应该具现的模板" class="headerlink" title="2. 优势2：阻止不应该具现的模板"></a>2. 优势2：阻止不应该具现的模板</h3><p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果这个函数的业务是，对指针对象进行处理。那么这个函数需要排除两类指针以防错误，<code>void*</code>类型指针和<code>char*</code>类型指针。他们一个无法指到具体对象，一个一般用来指向C风格的字符串。那么这两类传入应该拒绝具象化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span> *) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span> *) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>那么其实对应的const版本应该也是不行的，于是有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span> *) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span> *) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>如果想要斩草除根，那么对应的<code>const volatile</code>, <code>std::wchar_t</code>, <code>std::char16_t</code>, <code>std::char32_t</code>也都应该删除。</p>
<p>而有意思的是</p>
<blockquote>
<p>如果是类内部的函数模板，prviate声明禁止某些具象化是办不到的。</p>
</blockquote>
<p>例如如下错误示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function">tempalte&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">   &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;                 <span class="comment">//错误！</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题在于，模板特化是必须在名字空间作用域而非类作用域内撰写的。这个问题在删除函数上不会体现出来，因为：</p>
<ul>
<li>他们根本不需要不同的访问层级</li>
<li>成员函数模板可以在类外被删除，如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function">tempalte&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">   &#123;...&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;         <span class="comment">//仍然具备public访问层级但被删除了</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span> *) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>实际上，C++98的private手法想实现的效果就是delete函数的效果，所以请记住。<em><strong>始终使用删除函数</strong></em>。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 优先选用删除函数，而非private未定义函数。</td>
</tr>
<tr>
<td>2. 任何函数都可以删除，包括非成员函数和模板具现。</td>
</tr>
</tbody></table>
<h2 id="条款12-为意在改写的函数添加override声明"><a href="#条款12-为意在改写的函数添加override声明" class="headerlink" title="条款12 为意在改写的函数添加override声明"></a>条款12 为意在改写的函数添加override声明</h2><p>C++ 中虚函数<code>override</code>动作，从而使得基类接口调用派生类函数成为了可能，而这个<code>override</code>动作工作起来，需要满足如下要求：</p>
<ul>
<li>基类中函数必须是虚函数。</li>
<li>基类和派生类中的函数名字必须完全相同（析构函数除外）。</li>
<li>基类和派生类中的函数形参类型必须完全相同。</li>
<li>基类和派生类中的函数常量性必须完全相同。</li>
<li>基类和派生类中的函数返回值和异常规格必须兼容。</li>
<li>基类和派生类中的函数引用饰词必须完全相同。（C++11以后，含11要求）</li>
</ul>
<p><code>函数引用饰词</code>这个语言特性以下做讲解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;    <span class="comment">//这个版本的doWork仅在*this是左值时候调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;   <span class="comment">//这个版本的doWork仅在*this是右值时候调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makewidget</span><span class="params">()</span></span>;    <span class="comment">//工厂函数（返回右值）</span></span><br><span class="line">Widget w;               <span class="comment">//普通对象（左值）</span></span><br><span class="line">...</span><br><span class="line">w.<span class="built_in">doWork</span>();             <span class="comment">//以左值版本调用</span></span><br><span class="line"><span class="built_in">makewidget</span>().<span class="built_in">doWork</span>();  <span class="comment">//以右值版本调用</span></span><br></pre></td></tr></table></figure>

<p>那么既然改写有这么多要求，就意味着一个小错误就会造成大的偏差。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么区别在于：</p>
<ul>
<li>Base 中的mf1是声明为const的，但是在Derived中的没有。</li>
<li>Base 中的mf2的形参类型是int，而Derived中的则是unsigned int。</li>
<li>Base 中的mf3带有左值引用饰词，而Derived中的带有右值引用饰词。</li>
<li>Base 中的mf4未声明为虚函数。</li>
</ul>
<p>实际上上述情况一个都无法完成改写，更有甚者，编译器完全不会报告任何错误信息，这一点是极为可怕的，容易埋下祸根。而C++11开始提供了一种显示标记的方式让编译器检查改写是否成功。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦这么写后，编译器会强制检查，所标记函数必须能够改写基类对应接口，否则则会进行报错。</p>
<p>而<code>override</code>的好处不仅仅在于强制让编译器检查改写，还可以在打算更改基类虚函数签名的时候，能够通过编译器的报错衡量波及范围。</p>
<p>需要强调的是，虽然<code>override</code>是个关键字，但是仅仅在特定语境下保留。对于已经将<code>override</code>作为一个变量或者一个函数名的时候，依旧不受影响。</p>
<p><em>题外话，引用饰词</em>*</p>
<p>这里写个对于引用饰词的使用场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp;          <span class="comment">// 对于左值Widget类型，返回左值</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> values;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp;          <span class="comment">// 对于右值Widget类型，返回右值</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> std::<span class="built_in">move</span>(values);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于以下调用能够高效进行</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<p>如果没有引用饰词，那么对于右值版本会将临时对象中的std::vector进行复制到vals2中。而显然对于vector这种类型来说，移动操作一般比复制操作开销要小。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 为意在改写的函数添加override声明。</td>
</tr>
<tr>
<td>2. 成员函数引用饰词使得对于左值和右值对象可以处理可以区分开。</td>
</tr>
</tbody></table>
<h2 id="条款13-优先选用const-iterator，而非interator"><a href="#条款13-优先选用const-iterator，而非interator" class="headerlink" title="条款13 优先选用const_iterator，而非interator"></a>条款13 优先选用const_iterator，而非interator</h2><p><code>const_iterator</code>是STL中相当于指涉到const的指针的等价物。它们指涉到不可以被修改的值。</p>
<blockquote>
<p>只要需要一个迭代器而其指涉内容没有修改必要，那么就应该用<code>const_iterator</code></p>
</blockquote>
<p>但值得强调的是，在C++98中，<code>const_iterator</code>用起来困难重重，以下列举C++98中使用场景示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于以下调用，合理的应该改为const_iterator</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = </span><br><span class="line">    std::<span class="built_in">find</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下在C++98中尝试改进，实际上编译不过</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::iterator IterT;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::const_iterator ConstIterT;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line">ConstIterT ci = </span><br><span class="line">    std::<span class="built_in">find</span>(<span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">begin</span>()),  <span class="comment">//强制类型转换</span></span><br><span class="line">              <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">end</span>()),    <span class="comment">//强制类型转换</span></span><br><span class="line">              , <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(<span class="built_in">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>);            <span class="comment">//可能无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>实际上，如果在<code>static_cast</code>能够运作的时候，可能会这样写，但是：</p>
<p><em><strong>const_iterator就是没有任何办法转换成对应的iterator</strong></em></p>
<p>由于这种原因，所以众多程序猿并不能只要有可能就使用<code>const_iterator</code>，而是在好用的时候采用。但在C++11中，这种麻烦被修复了。看以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> it =</span><br><span class="line">    std::<span class="built_in">find</span>(values.<span class="built_in">cbegin</span>(), values.<span class="built_in">cend</span>(), <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure>

<p>只有在一种情况下C++11不能很好的使用<code>const_iterator</code>。例如以上业务，当我们想抽象出一个模板的时候，可能会这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> V&amp; targetVal,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> V&amp; insertVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cbegin;</span><br><span class="line">    <span class="keyword">using</span> std::cend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container),  <span class="comment">//非成员函数版本cbegin</span></span><br><span class="line">                        <span class="built_in">cend</span>(container),    <span class="comment">//非成员函数版本cend</span></span><br><span class="line">                        targetVal);</span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而令人遗憾的是，以上代码只能在C++14中运行，C++11由于标准委员会只添加了非成员函数版本的<code>begin</code>和<code>end</code>。并未添加<code>cbegin</code>,<code>cend</code>,<code>rbegin</code>,<code>rend</code>,<code>crbegin</code>,<code>crend</code>。在C++11中可以添加一下辅助代码实现<code>cbegin</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);       <span class="comment">//请仔细看下文解释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可能会让你觉得有些吃惊，非成员函数版本的cbegin并没有调用成员函数的cbegin。但其实这个函数的实参类型可以是任何表示类似容器的数据结构，并通过其引用到const类型的形参container来访问该实参。这样做的好处是能够同时兼容只有begin成员函数版本的容器。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 优先选用const_iterator，而非iterator。</td>
</tr>
<tr>
<td>2. 在最通用的代码中，优先选用非成员函数版本的begin、end和rbegin等，而非成员函数版本。</td>
</tr>
</tbody></table>
<h2 id="条款14-只要函数不会发射异常，就为其加上noexcept声明"><a href="#条款14-只要函数不会发射异常，就为其加上noexcept声明" class="headerlink" title="条款14 只要函数不会发射异常，就为其加上noexcept声明"></a>条款14 只要函数不会发射异常，就为其加上noexcept声明</h2><p>在C++98中，异常规格是一个喜怒无常的野兽。一般来说，不要招惹为好。</p>
<p>而在C++11中，逐渐达成了一个共识：</p>
<blockquote>
<p>关于异常发射这个事情，关键在于是否会有异常，而不关注类型。</p>
</blockquote>
<p>所以当你知道这个函数不会发射异常，那么就应该给这个函数加上<code>noexcept</code>声明，否则这是一个接口规格缺陷。</p>
<h3 id="1-动机：让编译器更好的生成目标代码"><a href="#1-动机：让编译器更好的生成目标代码" class="headerlink" title="1. 动机：让编译器更好的生成目标代码"></a>1. 动机：让编译器更好的生成目标代码</h3><p>参考差异代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>;       <span class="comment">//f不会发射异常：C++98风格</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">noexcept</span></span>;      <span class="comment">//f不会发射异常：C++11风格</span></span><br></pre></td></tr></table></figure>

<p>如果在运行期，一个异常逸出f的作用域，则f的异常规格被违反。在C++98的异常规格下，调用栈会开解至f的调用方，然后执行一些操作，程序中止。但在C++11的规格下，运行期行为会略有不同，程序执行中止之前，<em><strong>栈只是可能会开解</strong></em>。</p>
<p>这个一定会开解和可能会开解，对代码生成的差异实际上比想象中要更大。</p>
<p>在带有<code>noexcept</code>声明的函数中：</p>
<ul>
<li>优化器不要在异常传出函数的前提下，将执行期栈保持在可开解状态</li>
<li>不需要在异常逸出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构</li>
</ul>
<p>而那些以<code>throw()</code>异常规格声明的函数享受不到这样的优化灵活性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//最优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">//优化不够</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;           <span class="comment">//优化不够</span></span><br></pre></td></tr></table></figure>

<h3 id="2-经典例子"><a href="#2-经典例子" class="headerlink" title="2. 经典例子"></a>2. 经典例子</h3><h4 id="2-1-移动操作"><a href="#2-1-移动操作" class="headerlink" title="2.1 移动操作"></a>2.1 移动操作</h4><p>移动操作就是一个极好的例子。假如有一段C++98代码，使用一个<code>std::vector&lt;Widget&gt;</code>类型对象，而且会用<code>push_back</code>往其中添加一些<code>Widget</code>对象。实现代码可能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">...</span><br><span class="line">Widget w;           <span class="comment">//使用w</span></span><br><span class="line">...</span><br><span class="line">vw.<span class="built_in">push_back</span>(w);    <span class="comment">//将w加入vw</span></span><br></pre></td></tr></table></figure>

<p>当<code>std::vector</code>类型对象中添加新元素，可能会空间不够。假设<code>size()</code> &#x3D;&#x3D; <code>capacity()</code>时，再要加入新元素，那么这个事件发生的时候，<code>std::vector</code>会进行会重新分配，然后将现有元素移动到新位置（<code>加入新元素个数小于当前个数则按照当前容量翻倍，如果大于当前容量，则新空间等于当前容量+新增容量</code>）。</p>
<ul>
<li>C++98中，转移的做法是将元素逐个从旧内存复制到新内存，然后将旧内存中对象析构。这样提供了<strong>强异常安全保证</strong> ：<code>如果在复制过程中抛出异常，原对象会保持原样不变</code>。</li>
<li>C++11中，一个自然的优化，针对std::vector类型元素复制换成移动操作。但不幸的是，这样违反了push_back的强异常安全保证。如果移动过程中出现异常，那么，原来的对象就会已经被移走一部分从而无法恢复。</li>
</ul>
<p>而实际上在C++11中是按照如果移动操作不会发射异常，则进行移动。也就是<code>能移动则移动，必须复制才复制</code>的策略。而STL库中，<code>std::vector::reserve</code>, <code>std::deque::insert</code>这些也都是采用的这种方式，这种方式的基础就是查看移动操作是否带有<code>noexcept</code>声明。</p>
<h4 id="2-2-swap操作"><a href="#2-2-swap操作" class="headerlink" title="2.2 swap操作"></a>2.2 swap操作</h4><p><code>swap</code>函数是许多STL算法的核心组件。在复制赋值运算符中，也被常常调用。它的广泛使用意味着针对它声明<code>noexcept</code>的声明也是收益可观的。</p>
<p>而<code>std::swap</code>的异常声明取决于用户定义的<code>swap</code>函数是否带有<code>noexcept</code>声明。例如标准库为<code>数组</code>和<code>std::pair</code>准备的<code>swap</code>函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T(&amp;a)[N],</span></span></span><br><span class="line"><span class="params"><span class="function">          T(&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(*a, *b)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&amp; p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swap(first, p.first)) &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">noexcept</span>(swap(second, p.second)))</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里存在这样一个事实：</p>
<blockquote>
<p>高阶数据结构的swap行为要noexcept性质，一般地，仅当构建它的低阶数据结构具备noexcept性质时才成立。</p>
</blockquote>
<p>以上性质有一个推论，<strong>只要有可能的情况下，都让函数带有<code>noexcept</code>声明</strong>。但需要说明的是，如果声明了<code>noexcept</code>但是函数会抛出异常，那么遇到这种情况程序则会直接退出。所以<strong>优化诚可贵，正确价更高</strong>。</p>
<h3 id="3-其他结论"><a href="#3-其他结论" class="headerlink" title="3. 其他结论"></a>3. 其他结论</h3><h4 id="3-1-一个事实：大多数函数是异常中立的"><a href="#3-1-一个事实：大多数函数是异常中立的" class="headerlink" title="3.1 一个事实：大多数函数是异常中立的"></a>3.1 一个事实：大多数函数是异常中立的</h4><p>大多数函数是异常中立的，他们不产生异常，但是他们调用的函数可能会产生异常。<strong>异常中立函数永远不具备noexcept性质</strong>。</p>
<h4 id="3-2-一个特点：有部分函数具备noexcept性质后，收益会很高"><a href="#3-2-一个特点：有部分函数具备noexcept性质后，收益会很高" class="headerlink" title="3.2 一个特点：有部分函数具备noexcept性质后，收益会很高"></a>3.2 一个特点：有部分函数具备noexcept性质后，收益会很高</h4><ul>
<li>移动函数</li>
<li>swap函数</li>
</ul>
<p>但是需要强调的一点是，不要刻意将函数异常内部捕获从而达到对外noexcept的效果，这样带来的收益会远远小于维护成本。注意需要自然(非强制<code>try</code> <code>catch</code>)的实现。</p>
<h4 id="3-3-一个新规则"><a href="#3-3-一个新规则" class="headerlink" title="3.3 一个新规则"></a>3.3 一个新规则</h4><p>C++98允许<code>operator delete</code>或者<code>operator delete[]</code>和析构函数抛出异常，但这被认为是一种差劲的编程风格。</p>
<p>C++11修改了这个规则，默认的内存释放函数和所有的析构函数都隐式具备<code>noexcept</code>性质。如果这两类函数中抛出异常，则会<code>产生未定义行为</code>。</p>
<h4 id="3-4-宽松契约函数，狭隘契约函数"><a href="#3-4-宽松契约函数，狭隘契约函数" class="headerlink" title="3.4 宽松契约函数，狭隘契约函数"></a>3.4 宽松契约函数，狭隘契约函数</h4><p>宽松契约函数：传入参数不用不关心程序当前状态。<br>狭隘契约函数：传入的参数需要满足一定规则，否则会行为未定义。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//前置条件：s.length() &lt;= 32</span></span><br></pre></td></tr></table></figure>

<p>一般来说，只对宽松契约函数声明<code>noexcept</code>，所以上述写法是不合适的。</p>
<h4 id="3-5-最后一个用法介绍"><a href="#3-5-最后一个用法介绍" class="headerlink" title="3.5 最后一个用法介绍"></a>3.5 最后一个用法介绍</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到虽然<code>setup</code>和<code>cleanup</code>不带<code>noexcept</code>但是doWork有，这看起来自相矛盾，但的确是合适的。因为<code>setup</code>和<code>cleanup</code>可能是从C++98，或者C代码中引用过来的函数。所以只要的确是不会有异常逸出，那么就可以加上<code>noexcept</code>，编译器是不会对此情况进行报错的。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. noexcept声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。</td>
</tr>
<tr>
<td>2. 相对于不带noexcept声明的函数，带有noexcept声明的有更多机会会被优化。</td>
</tr>
<tr>
<td>3. noexcept性质对于移动，swap，内存释放，析构函数最有价值。</td>
</tr>
<tr>
<td>4. 大多数函数都是异常中立的，不具备noexcept性质。</td>
</tr>
</tbody></table>
<h2 id="条款15-只要有可能使用constexpr，就使用它"><a href="#条款15-只要有可能使用constexpr，就使用它" class="headerlink" title="条款15 只要有可能使用constexpr，就使用它"></a>条款15 只要有可能使用constexpr，就使用它</h2><p>C++11中引入的新词要评出一个“最令人困惑”大奖，那么<code>constexpr</code>很可能获此殊荣。</p>
<ul>
<li>当<code>constexpr</code>用于对象时，就是一个加强版本的<code>const</code>。</li>
<li>当<code>constexpr</code>用于函数时，则是另外一种含义了。</li>
</ul>
<p>从字面上来说，<code>constexpr</code>表示的是既是const，又是编译阶段就已知。但实际上这个说法不全面，对于<code>constexpr</code>函数而言，它不产生const或者编译阶段就已知的结果。并且这种设计是有意为之，而且是个好事情。</p>
<h3 id="1-constexpr对象"><a href="#1-constexpr对象" class="headerlink" title="1. constexpr对象"></a>1. constexpr对象</h3><p>这些对象是真的具备const属性，并且是编译期就已知的，严格的说，是翻译期间已知，包含编译，连接。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  sz;                            <span class="comment">//非constexpr变量</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">//错误！sz的值在编译期未知</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, sz&gt; data1;          <span class="comment">//错误！一样的问题</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">//没问题，10是编译期常量</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize2&gt; data2;  <span class="comment">//没问题，arraySize2是constexpr</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>const</code>并非和<code>constexpr</code>提供同样的保证，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;                             <span class="comment">//非constexpr变量</span></span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> arraySize = sz;          <span class="comment">//没问题，arraySize是sz的一个const副本</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize&gt; data;    <span class="comment">//错误！arraySize的值在编译期未知</span></span><br></pre></td></tr></table></figure>

<p>总而言之，所有<code>constexpr</code>对象都是<code>const</code>对象，而并非所有的<code>const</code>对象都是<code>constexpr</code>对象。</p>
<h3 id="2-constexpr函数"><a href="#2-constexpr函数" class="headerlink" title="2. constexpr函数"></a>2. constexpr函数</h3><p>这个关键字的理解方式是这样的：</p>
<ul>
<li><code>constexpr</code>函数可以用在要求编译期常量的语境中。在这样的语境中，若传入一个<code>constexpr</code>函数的实参是在编译期已知的，那么结果也会在编译期算出来。</li>
<li>在调用<code>constexpr</code>函数时，若传入的值有一个或多个在编译期未知，则他的运作方式和普通函数无区别。</li>
</ul>
<p>看下面一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> numConds = <span class="number">5</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, pow(3, numConds)&gt; results;</span><br></pre></td></tr></table></figure>

<p>如果base和exp的值是编译期常量，那么pow的返回结果就可以当一个编译期常量使用。如果任一其中一个不是或者都不是，那么pow的返回结果将在运行期使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> base = <span class="built_in">readFromDB</span>(<span class="string">&quot;base&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> exp = <span class="built_in">readFromDB</span>(<span class="string">&quot;exponent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> baseToExp = <span class="built_in">pow</span>(base, exp);        <span class="comment">//pow函数在运行期被调用</span></span><br></pre></td></tr></table></figure>

<p>由于<code>constexpr</code>函数必须传入编译期常量时，能够返回编译期结果，他们的实现就必须加以限制。而这个限制在C++11和C++14中有所不同。</p>
<p><strong>在C++11中，constexpr函数不得包含多于一个可执行语句，即一条return语句。</strong>那么即便我们投机取消，用上了三元操作符<code>？：</code>和递归，最多也只能写成如下这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span>   <span class="comment">//C++11</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exp == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而实际上来说，这种代码除非是喜欢函数式编程的人，否则还是不容易理解。</p>
<p><strong>在C++14中，限制条件被大大放宽了。</strong> 像下面的代码也是可以的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span>   <span class="comment">//C++14</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp; ++i)</span><br><span class="line">        result *= base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：constexpr函数仅限于传入和返回字面类型</strong></p>
<p>在C++11中，所有内建类型，除<code>void</code>都符合这个条件，并且用户自定义类型，有些情况下也是满足字面类型的，因为它的构造函数和其他成员函数可能也是<code>constexpr</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    : x(xVal), y(yVal) </span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123;x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123;y = newY;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里，Point的构造函数被声明成了<code>constexpr</code>函数，由传入它的实参在编译期可知，构造出来的Point对象数据成员也是在编译期可知，所以Point对象自然也具备constexpr属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;      <span class="comment">//没问题，编译期&quot;运行&quot;constexpr构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;      <span class="comment">//同上！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(p1.<span class="built_in">xValue</span>() + p2.<span class="built_in">xValue</span>()) / <span class="number">2</span>,</span><br><span class="line">            (p1.<span class="built_in">yValue</span>() + p2.<span class="built_in">yValue</span>()) / <span class="number">2</span>&#125;;   <span class="comment">//调用constexpr成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);      <span class="comment">//使用constexpr函数的结果初始化</span></span><br></pre></td></tr></table></figure>

<p>这是一个令人激动的功能，mid这样的变量虽然经过了构造，访问器，还有非成员函数的调用，但是仍然在可以在只读内存中得以创建，这意味着这个变量可以用在模板形参中，或者指定枚举量的表达式中。</p>
<p>这也意味着，传统代码中在运行期的很多数据已经可以在编译期完成计算。<strong>这样的迁移越多，你的程序自然运行的越快。</strong></p>
<h3 id="3-C-11中的constexpr不完美"><a href="#3-C-11中的constexpr不完美" class="headerlink" title="3. C++11中的constexpr不完美"></a>3. C++11中的constexpr不完美</h3><p>有两个限制导致setX和setY无法声明为<code>constexpr</code>。</p>
<ul>
<li>他们修改了操作对象，可是在C++11中，<code>constexpr</code>函数都隐式地被声明为<code>const</code>的了。</li>
<li>他们返回了void类型，而在C++11中，void类型并不是字面类型。</li>
</ul>
<p>但这两个限制在C++14中都并不存在，所以在C++14里，可以有这样的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;           <span class="comment">//C++14</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; x = newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; y = newY;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回p相对于原点的中心对称点(C++14)</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result;                   <span class="comment">//创建一个非const的Point对象</span></span><br><span class="line">    result.<span class="built_in">setX</span>(-p.<span class="built_in">xValue</span>());       <span class="comment">//设置其x和y成员的值</span></span><br><span class="line">    result.<span class="built_in">setY</span>(-p.<span class="built_in">yValue</span>());       </span><br><span class="line">    <span class="keyword">return</span> result;                  <span class="comment">//返回result的副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户代码可以是这样的</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.2</span>, <span class="number">27.5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">24.5</span>, <span class="number">9.5</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid =       <span class="comment">//reflectMid的值为编译器就算好的</span></span><br><span class="line">            <span class="built_in">reflection</span>(mid);</span><br></pre></td></tr></table></figure>

<p>所以本条款给出的建议是：只要有可能使用constexpr，就使用它。而这里需要注意，一旦设置了constexpr性质，就不要轻易的去除，因为可能会导致客户代码被拒绝编译。上述的建议应该是一个长期的承诺。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. constexpr对象都具备const属性，并有编译期已知的值完成初始化。</td>
</tr>
<tr>
<td>2. constexpr函数在调用时，若传入的实参值是编译期已知的，则会产生编译期结果。</td>
</tr>
<tr>
<td>3. 比起非constexpr对象或非constexpr函数而言，constexpr对象或函数可以用在一个作用域更广的语境中。</td>
</tr>
</tbody></table>
<h2 id="条款16-保证const成员函数的线程安全性"><a href="#条款16-保证const成员函数的线程安全性" class="headerlink" title="条款16 保证const成员函数的线程安全性"></a>条款16 保证const成员函数的线程安全性</h2><p>业务场景：用一个类表示多项式，这个类中有一个接口可以输出多项式的根。那么代码会是像这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般来说，多项式值计算的代价高昂，我们不会每次都计算，当不得不计算的时候，我们会把算好的值缓存下来，然后遇到相同入参的时候，直接返回缓存值即可。那么大概是这样的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span> <span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootsAreVaild) &#123;       <span class="comment">//如果缓存无效</span></span><br><span class="line">            ...</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;   <span class="comment">//则计算根，并将其存入rootVals</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从概念上来说，<code>roots</code>函数不会修改对象，然而缓存会需要修改，所以这是<code>mutable</code>的典型用例，这也是为何被加到数据成员声明中的原因。</p>
<p>设想现在有两个线程同时在一个<code>Polynomial</code>对象上调用<code>roots</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Polynomial p;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* ------线程1------ */</span>         <span class="comment">/* -------线程2------ */</span></span><br><span class="line"><span class="keyword">auto</span> rootsOfP = p.<span class="built_in">roots</span>();      <span class="keyword">auto</span> valsGivingZero = p.<span class="built_in">roots</span>();</span><br></pre></td></tr></table></figure>

<p>按理说，一般const成员函数是一个读操作，多线程在没有同步的条件下，读操作是安全的。但是上述例子却不安全。上述例子由于mutable的存在，会存在多个线程读写同一块内存的情况，这会造成<code>数据竞态</code>，从而造成<code>未定义行为</code>。所以问题在于一个<strong>const成员函数却不能保证并发安全</strong>，这个缺陷是需要修复的。</p>
<p><strong>解决办法之mutex</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span> <span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_gurad&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>;   <span class="comment">//加上互斥量</span></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreVaild) &#123;               <span class="comment">//如果缓存无效</span></span><br><span class="line">            ...</span><br><span class="line">            rootsAreValid = <span class="literal">true</span>;           <span class="comment">//则计算根，并将其存入rootVals</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之所以<code>m</code>也需要声明为mutable，因为加锁和解锁都不是const成员函数所谓，如果没有这个修饰，那么<code>roots()</code>内，<code>m</code>就会被当做是const对象处理了。</p>
<p>但这个方法有个弊端，让整个类失去了可复制性，因为<code>std::mutex</code>是个只移类型。</p>
<p><strong>解决办法之atomic</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++callCount;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">unsigned</span>&gt; callCount &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与<code>std::mutex</code>一样，<code>std::atomic</code>也是只移类型。所以Point也失去了可复制性。<code>std::atomic</code>的开销比<code>std::mutex</code>要小，<strong>也许</strong>应该尝试更加依赖<code>std::atomic</code>在可能产生数据竞态的时候。例如，如果某类需要缓存计算开销较大的int类型变量，则应该尝试使用一对<code>std::atomic</code>类型变量来取代互斥量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;          <span class="comment">//请注意，这种方式是可行但不好的方式</span></span><br><span class="line">                        <span class="comment">//后面讲解正确方式</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) </span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">            <span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line">            cachedValue = val1 + val2;</span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">bool</span>&gt; cacheValid &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">mutable</span> std::atomic&lt;<span class="type">int</span>&gt;  cacheValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这么做可行，但有时候会有一些不必要的工作，考虑这种情况：</p>
<ul>
<li>一个线程调用<code>Widget::magicValue</code>时，观察到cacheValid值为false，于是执行了两个大开销的计算，并将其和赋值给了cacheValue。</li>
<li>与此同时，另一个线程也在调用<code>Widget::magicValue</code>，也观察到cacheValid值为false，于是执行了两个大开销的计算，并将其和赋值给了cacheValue，这个时候可能不止另一个，另外若干个其他线程。</li>
</ul>
<p>这么做虽然没问题，但是与设计缓存的目的南辕北辙。那么尝试颠倒对cacheValid和cacheValue的赋值顺序可以消除该问题，但结果却更坏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;          <span class="comment">//请注意，这种方式是可行但不好的方式</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) </span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">            <span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> cachedValue = val1 + val2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设这样的场景：</p>
<ul>
<li>一个线程调用<code>Widget::magicValue</code>并执行到了 <code>cacheValid = true;</code>。</li>
<li>在这一刻，另一个线程也在调用<code>Widget::magicValue</code>并检查到<code>cacheValid</code>是true，该线程就直接把<code>cacheValue</code>的值给返回了，即使第一个线程还没执行对<code>cacheValue</code>赋值。这无疑是不正确的。</li>
</ul>
<p>这里我们学到的教训是：</p>
<blockquote>
<p>对单个要求同步的变量或者内存区域，使用std::atomic就足够了。</p>
</blockquote>
<blockquote>
<p>如果有两个或者更多变量或者内存区域需要作为一个整体单位进行操作时，就要动用互斥量了。</p>
</blockquote>
<p>那么正确的代码应该这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;          <span class="comment">//请注意，这种方式是可行但不好的方式</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (cacheValid) </span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">            <span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line">            cachedValue = val1 + val2;</span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> cachedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex  m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> cacheValid &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span>  cacheValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>目前为止本条款都基于这样的假设：多个线程会同事调用一个对象的同一个const成员函数。如果你撰写的成员函数并不符合这种情况，那么<code>mutable</code>，<code>atomic</code>，<code>mutex</code>都是不需要的。但可见的是，线程无关的场合正在变的越来越少，所以我们依旧要保证const成员函数具备线程安全性。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 保证const成员函数的线程安全性，除非可以确信他们不会在并发语境中。</td>
</tr>
<tr>
<td>2. 运用std::atomic类型会比互斥量提供更好的性能，但是前提是对单个变量或内存区域的操作。</td>
</tr>
</tbody></table>
<h2 id="条款17-理解特种成员函数的生成机制"><a href="#条款17-理解特种成员函数的生成机制" class="headerlink" title="条款17 理解特种成员函数的生成机制"></a>条款17 理解特种成员函数的生成机制</h2><p>在C++官方用于中，特种成员函数指的编译器会自动生成的成员函数。</p>
<h3 id="1-C-98中的规则"><a href="#1-C-98中的规则" class="headerlink" title="1. C++98中的规则"></a>1. C++98中的规则</h3><p>C++98中提供了4种：<code>默认构造函数</code>、<code>析构函数</code>、<code>复制构造函数</code>、<code>复制赋值运算符</code>。</p>
<p><code>生成条件</code>：<strong>这些函数仅在需要时才会生成</strong>。通俗说来，某些代码中使用了它们，但是在类中并未显示声明的场合。</p>
<p><code>生成特点</code>：默认生成的都是<code>public</code>访问层级，并且是<code>inline</code>的，而且是非虚的。除非讨论的是一个析构函数，位于一个派生类中，并且基类的析构函数是个虚函数，在那种情况下，编译器为派生类生成的析构函数也是个虚函数，否则都是<strong>非虚的</strong>。</p>
<h3 id="2-C-11中的规则"><a href="#2-C-11中的规则" class="headerlink" title="2. C++11中的规则"></a>2. C++11中的规则</h3><p>C++11中新增了两位新成员：<code>移动构造函数</code>和<code>移动赋值运算符</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);               <span class="comment">//移动构造函数</span></span><br><span class="line">    Widget &amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);   <span class="comment">//移动赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个特种成员函数生成规则和行为表现的和复制版本类似。移动操作也仅在需要时候才生成，一旦生成，他们执行的是作用于<code>非静态成员</code>的<code>按“成员移动”</code>操作。</p>
<p>意思是，移动构造&#x2F;赋值函数将依照其形参rhs的各个非静态成员对本类的对应成员执行移动构造。移动构造函数同时还会移动构造它的基类部分（如果有的话）。</p>
<p><strong>但是</strong>，上述移动操作并不保证一定真的发生。“按成员移动”实际上更贴切的说法是<code>按成员的移动请求</code>。因为对于不可移动的类型是通过复制操作实现的移动。每个按成员进行的“移动”操作，核心在于把<code>std::move</code>应用每一个移动源对象，其返回值被用于函数重载决议，最终决定移动还是复制。一句话概括就是：<code>对于可移动的移动，不可移动的复制</code>。</p>
<h3 id="3-移动构造-复制构造的不同机制"><a href="#3-移动构造-复制构造的不同机制" class="headerlink" title="3. 移动构造&#x2F;复制构造的不同机制"></a>3. 移动构造&#x2F;复制构造的不同机制</h3><h4 id="3-1-移动相互抑制"><a href="#3-1-移动相互抑制" class="headerlink" title="3.1 移动相互抑制"></a>3.1 移动相互抑制</h4><p>如果发生了复制操作的情况下，移动操作就不会在已有声明的前提下被生成。也就是<strong>生成移动操作的精确条件，与复制操作有所不同</strong>：</p>
<ul>
<li>复制构造和复制赋值运算符是彼此独立的：声明了其中一个，并不会阻止编译器生成另一个。也就是如果只声明了复制构造&#x2F;复制赋值运算符之一，但使用过程中用到了另一个，没声明的，编译器会帮你补全。</li>
<li>移动构造和移动赋值操作并不独立：声明了其中一个，就会阻止编译器生成另一个。这种机制的理由在于：<code>假如你声明了一个移动构造函数，你实际上表明移动操作的实现方式将与编译器生成的默认按成员移动的移动函数不一样。若是按成员进行移动构造操作有不合用之处的话，那么按成员移动赋值运算符极有可能不合用</code>。所以声明一个移动构造会阻止编译器生成移动赋值，而声明一个移动赋值也会阻止编译器生成移动构造。</li>
</ul>
<h4 id="3-2-复制-移动相互抑制"><a href="#3-2-复制-移动相互抑制" class="headerlink" title="3.2 复制&#x2F;移动相互抑制"></a>3.2 复制&#x2F;移动相互抑制</h4><p>一旦显示声明了复制操作，这个类不会再生成移动操作。机制理由和上述类似。</p>
<p>并且一旦声明了移动操作（不管是移动构造还是移动赋值），编译器就会废除复制操作（废除的方式是删除他们）。机制理由和上述类似。</p>
<h3 id="4-指导原则——大三律"><a href="#4-指导原则——大三律" class="headerlink" title="4. 指导原则——大三律"></a>4. 指导原则——大三律</h3><p>大三律：如果你声明了复制构造，复制赋值运算符，析构函数中的任何一个，你就得同时声明所有这三个。</p>
<p>大三律的机制理由是这样的：</p>
<ul>
<li>如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理。<ul>
<li>意味着在一种复制操作中进行的任何资源管理，极有可能在另一种中也需要改写。</li>
<li>该类的析构函数也会参与到该资源的管理中。</li>
</ul>
</li>
</ul>
<p>需要市价管理的经典资源就是内存，这就是为什么标准库中用以管理内存的类都会遵从大三律，两种复制操作和析构函数都会声明全。</p>
<p><strong>大三律的推论</strong></p>
<ul>
<li>推论1</li>
</ul>
<blockquote>
<p>如果存在用户声明的析构函数，则平凡的按成员复制也不适用于该类。</p>
</blockquote>
<ul>
<li>推论2</li>
</ul>
<blockquote>
<p>如果声明了析构函数，则复制操作就不该被自动生成，因为他们的行为不可能正确。</p>
</blockquote>
<p>但以上推论在C++98的时候，并未被编译器广泛接受。所以在C++98中，用户声明的析构函数即使存在，也不会影响编译器生成复制操作的意愿。这一点由于C++11需要兼容C++98，所以还是保留下来了。不过，这并不是因为这条规则合理，而是出于兼容性的原因考虑。所以对于移动操作，就符合推论了。</p>
<p>所以在C++11中，对于移动操作的生成条件（如果需要生成）仅当以下三者同时成立：</p>
<ul>
<li>该类未声明任何复制操作</li>
<li>该类未声明任何移动操作</li>
<li>该类未声明任何析构函数</li>
</ul>
<p>总有一天，这样的机制会延伸到复制操作，因为C++11标准规定了，在已经存在复制操作或者析构函数的条件下，仍然自动生成复制操作已经成为了<strong>被废弃</strong>的行为。假定编译器生成的这些函数有着正确的行为，那么事情就简单了，因为C++11可以通过“&#x3D;default”来显示表达这个想法。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">~<span class="built_in">Widget</span>();                          <span class="comment">//用户定义的析构函数</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;) = <span class="keyword">default</span>;    <span class="comment">//默认复制构造函数的行为是正确的</span></span><br><span class="line">Widget&amp;                             <span class="comment">//默认复制赋值运算符的行为是正确的</span></span><br><span class="line">    <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;) = <span class="keyword">default</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-default的经典使用场景"><a href="#5-default的经典使用场景" class="headerlink" title="5. default的经典使用场景"></a>5. default的经典使用场景</h3><p>这种手法(<code>=default</code>)往往对于多态基类会很有用。</p>
<p>所谓多态基类，是指定义接口的类，而派生类的操作则通过这些接口来完成。</p>
<p>多态基类往往会有虚析构函数，因为若不然，有些操作（比如通过基类指针或者引用来对派生类执行的<code>delete</code>或者<code>typeid</code>等）就会产生未定义或者误导性的结果。在这种通常情况下，默认的实现就是正确的，而<code>=default</code>手法正是表达这一点的很好的方式。</p>
<p>但如果声明了析构，那么移动操作就被抑制了，那么又要default移动。声明移动又会抑制复制，又要default复制。那么大概的多态基类会是这样的类似写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;      <span class="comment">//使析构函数成为虚函数</span></span><br><span class="line">    <span class="built_in">Base</span>(Base&amp;&amp;) = <span class="keyword">default</span>;         <span class="comment">//提供移动操作的支持性</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;    <span class="comment">//提供复制操作的支持</span></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>即使编译器能够自动生成，还是推荐用default写明。</strong></p>
<p>其实即便是编译器能够在不写default的时候，自动生成对应函数，还是推荐写明，这样能够防止一些非常微妙的缺陷。举个栗子，假设有一个表示字符串表格的类，即允许通过整型ID来快速检索字符串值的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringTable</span>() &#123;&#125;</span><br><span class="line">    ...             <span class="comment">//实现插入，擦除，检索等操作的函数</span></span><br><span class="line">                    <span class="comment">//但没有函数实现复制，移动或析构</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假定该类没有复制操作，没有移动操作，也没有析构函数，编译器将在这些函数有需要调用时，自动生成他们，还挺方便。</p>
<p>可是，假设过了一段时间，决定要把对象的默认构造和析构都记入日志。加上这样的功能也很容易：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringTable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringTable</span>()   <span class="comment">//这是后加的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Creating StringTable object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StringTable</span>()  <span class="comment">//这是后加的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Destroying StringTable object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...             <span class="comment">//其他函数不变</span></span><br><span class="line"><span class="keyword">private</span>:            <span class="comment">//数据成员不变</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些改动看起来合情合理，但是析构函数的声明有一个潜在的、客观的副作用。它阻止了移动操作的生成。当然，复制操作的生成并未受影响。但这是一个可怕的事情，因为这样的改动，不会报错，可以编译，也能通过功能测试。就练对移动操作的测试也能通过，因为移动操作其实只是移动请求，上述例子在移动操作测试的时候最终调用的是复制操作。而<code>std::map&lt;int, std::string&gt;</code>的复制操作可能比移动操作慢若干个数量级。这么一来，<strong>向类中加入一个析构函数的简单动作，就可能引发客观的性能问题！</strong></p>
<p>但如果使用<code>=default</code>，就不会有问题了。</p>
<h3 id="6-C-11中特种函数的机制"><a href="#6-C-11中特种函数的机制" class="headerlink" title="6. C++11中特种函数的机制"></a>6. C++11中特种函数的机制</h3><ul>
<li>默认构造函数：与C++98机制相同。仅当类中不包含用户声明的构造函数时，才生成。</li>
<li>析构函数：与C++98机制基本相同，唯一的区别在于析构函数默认为noexcept。与C++98机制相同，仅当基类的析构函数为虚函数，派生类的析构函数才为虚的。</li>
<li>复制构造函数：运行期行为与C++98相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的<code>复制构造函数</code>时才生成。如果该类声明了移动操作，则<code>复制构造函数</code>将被删除。在已经存在<code>复制赋值运算符</code>或者析构函数的条件下，仍然生成<code>复制构造函数</code>已经成为<strong>被废弃</strong>的行为。</li>
<li>复制赋值运算符：运行期行为与C++98相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的<code>复制赋值运算符</code>时才生成。如果该类声明了移动操作，则<code>复制赋值运算符</code>将被删除。在已经存在<code>复制构造函数</code>或者析构函数的条件下，仍然生成<code>复制赋值运算符</code>已经成为<strong>被废弃</strong>的行为。</li>
<li>移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的<code>复制操作</code>、<code>移动操作</code>和<code>析构函数</code>时才生成。</li>
</ul>
<p><strong>特例：模板函数不会抑制编译器自动生成</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">//以任意类型构造Widget</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> T&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">//以任意类型赋值Widget</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，编译器会始终生成Widget的复制和移动操作。即便这些模板具现结果生成了复制构造函数或者复制赋值运算符的签名。这一点特例将在Item 26进行展开，需要记住这一点多么重要。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 特种成员函数是指编译器会自动生成的成员函数：默认构造函数、析构函数、复制操作、以及移动操作。</td>
</tr>
<tr>
<td>2. 移动操作仅当类中未包含显式声明的复制操作，移动操作和析构函数时才生成。</td>
</tr>
<tr>
<td>3. 复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如该类声明了移动操作，则复制构造函数将被删除。复制赋值运算符规则也一样。如果已经显式存在析构函数，生成复制操作已经是<strong>被废弃</strong>的行为。</td>
</tr>
<tr>
<td>4. 成员函数模板在任何情况下都不会抑制特种函数生成。</td>
</tr>
</tbody></table>
<h1 id="第四章-智能指针"><a href="#第四章-智能指针" class="headerlink" title="第四章 智能指针"></a>第四章 智能指针</h1><h2 id="条款18-使用std-unique-ptr管理具备专属所有权的资源"><a href="#条款18-使用std-unique-ptr管理具备专属所有权的资源" class="headerlink" title="条款18 使用std::unique_ptr管理具备专属所有权的资源"></a>条款18 使用std::unique_ptr管理具备专属所有权的资源</h2><p>每当你需要使用智能指针时，<code>std::unique_ptr</code>基本上应是首选考虑。在默认的情况下，可以认为<code>std::unique_ptr</code>和裸指针有着相同的尺寸，并且对于大多数的操作，他们都是完全执行了相同的指令。也就是说，甚至可以在内存和时钟周期紧张的情况下使用<code>std::unique_ptr</code>。</p>
<p><code>std::unique_ptr</code>是一个只移类型。不可复制。实现的是一个专属所有权语义，一个非空的<code>std::unique_ptr</code>必定拥有其所指涉到的资源。<code>std::unique_ptr</code>只可移动，表示所有权从一个指针转移到另一个指针。</p>
<h3 id="1-工厂模式，unique-ptr的完美应用场景"><a href="#1-工厂模式，unique-ptr的完美应用场景" class="headerlink" title="1. 工厂模式，unique_ptr的完美应用场景"></a>1. 工厂模式，unique_ptr的完美应用场景</h3><p><code>std::unique_ptr</code>的一个常见用法是在对象继承中作为工厂函数的返回类型。如果我们有一个<code>Investment</code>为基类的投资类型。</p>
<p>代码大概类似于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span>  &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line">    <span class="keyword">public</span> Investment  &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bond</span>:</span><br><span class="line">    <span class="keyword">public</span> Investment  &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealEstate</span>:</span><br><span class="line">    <span class="keyword">public</span> Investment  &#123;...&#125;;        </span><br></pre></td></tr></table></figure>

<p>这种结构的工厂函数通常会在堆上分配一个对象并返回一个指涉到它的指针，并当不在需要该对象时，调用者负责删除。</p>
<p><code>std::unique_ptr</code>对以上业务堪称完美匹配。因为调用者需要对工厂函数返回的资源负责，而当<code>std::unique_ptr</code>被析构时，又会自动指涉到对象实施<code>delete</code>。</p>
<p><code>Investment</code>继承谱系的工厂函数应该声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... TS&gt;           <span class="comment">//返回std::unique_ptr</span></span><br><span class="line">std::unique_ptr&lt;Investment&gt;         <span class="comment">//指涉到根据指定实参的对象</span></span><br><span class="line"><span class="built_in">makeInvestment</span>(Ts&amp;&amp;... params);</span><br></pre></td></tr></table></figure>

<p>调用者可以类似这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> pInvestment =                  <span class="comment">//pInvestment的类型是</span></span><br><span class="line">        <span class="built_in">makeInvestment</span>( arguments );    <span class="comment">//std::unique_ptr&lt;Investment&gt;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;                                       <span class="comment">//pInvestment在此析构</span></span><br></pre></td></tr></table></figure>

<p>即便所有权不断流转，<code>std::unique_ptr</code>也会在无人指涉的时候自动析构掉。</p>
<p>默认的，析构通过<code>delete</code>运算符实现，但是在析构过程也可以指定自定义析构器：析构资源时所调用的任意函数。例如如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)&#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt;</span></span><br><span class="line"><span class="function">        <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* 应创建一个Stock类型的对象 */</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 应创建一个Bond类型的对象 */</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 应创建一个RealEstate类型的对象 */</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上形式，会让工厂模式完美运作。假定把<code>makeInvestment</code>的调用结果存储在<code>auto</code>变量中，则你可以忽略正在使用的资源需要在析构的时候特殊处理的事情。因为无论何时析构，<code>std::unique_ptr</code>都会自动完成所有工作。</p>
<ul>
<li>当<code>std::unique_ptr</code>需要使用自定义析构器的时候，必须指定为<code>std::unique_ptr</code>构造的第二个参数。</li>
<li><code>std::unique_ptr</code>用于工厂模式的基本流程是创建一个空的<code>std::unique_ptr</code>，然后使起指涉到适当类型的对象，然后将其返回。</li>
<li>将一个裸指针赋值给<code>std::unique_ptr</code>是不会通过的，因为将裸指针赋值给<code>std::unique_ptr</code>可能会造成<code>std::unique_ptr</code>无法独占资源，所以要用<code>reset</code>方式更新。</li>
<li>对于万能引用要配合<code>std::forward</code>进行转发，使得创建对象的构造函数可以获得调用者提供的正确信息。</li>
</ul>
<ul>
<li>自定义析构器接受一个类型为<code>Investment*</code>的形参，所以无论是基类还是子类对象被删除的时候，都会正确进行释放。这里再次强调作为基类，必须具备一个<code>虚析构函数</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Investment</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在C++14中，写法可以更加简单一些，封装性更好一些，<code>delInvmt</code>可以写在模板内部，C++11之所以不能放进去，是因为auto如果写全会导致delInvmt没定义之前就使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)&#123;</span><br><span class="line">        <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">        <span class="keyword">delete</span> pInvestment;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt;</span></span><br><span class="line"><span class="function">        <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* 应创建一个Stock类型的对象 */</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 应创建一个Bond类型的对象 */</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 应创建一个RealEstate类型的对象 */</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-unique-ptr特点"><a href="#2-unique-ptr特点" class="headerlink" title="2. unique_ptr特点"></a>2. unique_ptr特点</h3><blockquote>
<p>在没有自定义析构器的情况下，可以认为unique_ptr和裸指针<strong>尺寸相同</strong>！</p>
</blockquote>
<p>但如果有自定义析构器，就不同了。</p>
<ul>
<li>如果自定义析构器是<code>函数指针</code>，那么<code>std::unique_ptr</code>的尺寸一般会增加1到2个字长。</li>
<li>如果自定义析构器是<code>函数对象</code>，那么<code>std::unique_ptr</code>的尺寸取决于该函数对象中存储了多少状态。特别指出，<strong>无状态的函数对象（例如，无捕获的lambda表达式）不会浪费存储尺寸</strong></li>
</ul>
<blockquote>
<p>意味着，如果自定义表达器，既可以用函数也可以用无捕获的lambda表达式的时候，lambda表达式会是更好的选择。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt1 = [](Investment* pInvestment)&#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);              <span class="comment">//使用无状态的lambda捕获</span></span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt1)</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span>              <span class="comment">//返回值尺寸和Investment *相同</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delInvmt2</span><span class="params">(Investment* pInvestment)</span></span>&#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);              <span class="comment">//使用函数作为自定义析构器</span></span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">void</span><span class="params">(*)</span><span class="params">(Investment *)</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span>              <span class="comment">//返回值尺寸等于Investment *的尺寸加上至少函数指针的尺寸</span></span></span><br></pre></td></tr></table></figure>

<p>当析构器采用大量状态的函数对象存在，则会使得<code>std::unique_ptr</code>的尺寸过大，一般这个时候需要修改设计。</p>
<h3 id="3-std-unique-ptr在Pimpl场景也很实用"><a href="#3-std-unique-ptr在Pimpl场景也很实用" class="headerlink" title="3. std::unique_ptr在Pimpl场景也很实用"></a>3. std::unique_ptr在Pimpl场景也很实用</h3><p>这里主要在Item22展开。</p>
<h3 id="4-std-unique-ptr的小知识"><a href="#4-std-unique-ptr的小知识" class="headerlink" title="4. std::unique_ptr的小知识"></a>4. std::unique_ptr的小知识</h3><p><code>std::unique_ptr</code>以两种形式提供，一个是单对象（<code>std::unique_ptr&lt;T&gt;</code>)，一个是数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。这样区分的结果是，<code>std::unique_ptr</code>指向的对象不会产生二义性。对应的接口，单对象的时候没有<code>operator[]</code>，数组则不提供<code>operator*</code>和<code>operator-&gt;</code>。但是对于数组形式一般没什么特别好的应用场景，因为<code>std::array</code>，<code>std::vector</code>，<code>std::string</code>总是比裸数组好的。所以了解即可，无需使用。</p>
<p><code>std::unique_ptr</code>也可以很方便的转换成<code>std::shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将std::unique_ptr转换为std::shared_ptr类型</span></span><br><span class="line">std::shared_ptr&lt;Investment&gt; sp = <span class="built_in">makeInvestment</span>(argments);</span><br></pre></td></tr></table></figure>

<p>可以看到直接就能转换过去，这种特性也让<code>std::unique_ptr</code>作为工厂模式返回值更加方便合理。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. std::unique_ptr是小巧的，高速的，只能移动的智能指针，对托管资源实施专属所有权语义。</td>
</tr>
<tr>
<td>2. 默认的，析构器采用delete实现，也可以指定自定义析构器。但有状态捕获和函数指针的实现方式会增加std::unique_ptr变量的尺寸。</td>
</tr>
<tr>
<td>3. 将std::unique_ptr转换成std::shared_ptr是很方便的。</td>
</tr>
</tbody></table>
<h2 id="条款19-使用std-shared-ptr管理具备共享所有权的资源"><a href="#条款19-使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="条款19 使用std::shared_ptr管理具备共享所有权的资源"></a>条款19 使用std::shared_ptr管理具备共享所有权的资源</h2><p><code>std::shared_ptr</code>让C++程序猿有了垃圾回收机制，<code>std::shared_ptr</code>采用的引用计数法做的垃圾回收。虽然不如根搜索算法那样，可以防止相互引用无法释放，但比起之前已经是飞跃了。</p>
<blockquote>
<p>引用计数法：<strong>通常</strong>构造的时候+1引用计数，析构的时候-1引用计数。引用计数为0的时候，真正释放此对象。</p>
</blockquote>
<p>引用计数法会带来一些性能影响：</p>
<ul>
<li><strong>std::shared_ptr的尺寸是裸指针的两倍</strong>。它们内部包含一个直射到该资源的裸指针，也包含一个指涉到该资源引用计数的裸指针。</li>
<li><strong>引用计数的内存必须动态分配</strong>。智能指针的设计方式是指到资源的指针和指到引用计数的指针是相互独立的，所以被指涉的对象并不知道引用计数的位置。虽然可以由<code>std::make_ptr</code>系列方法创建避免动态分配的成本，但有些情况下<code>std::make_ptr</code>没办法使用，但引用计数总是会作为动态分配的数据来存储。</li>
<li><strong>引用计数的递增和递减必须是原子操作</strong>。因为在不同线程中观察<code>std::shared_ptr</code>的引用数值必须保持原子性，否则会造成数据竞态。而原子性必定带来更高开销。</li>
</ul>
<p><strong>这里解释一下为何通常构造函数会增加引用</strong></p>
<p>因为移动构造函数和移动赋值函数不需要修改引用，所以在可以对<code>std::shared_ptr</code>进行移动操作时，开销会降低很多。</p>
<h3 id="1-std-shared-ptr的自定义析构器"><a href="#1-std-shared-ptr的自定义析构器" class="headerlink" title="1. std::shared_ptr的自定义析构器"></a>1. std::shared_ptr的自定义析构器</h3><h4 id="1-1-特点1"><a href="#1-1-特点1" class="headerlink" title="1.1 特点1"></a>1.1 特点1</h4><p><code>std::shared_ptr</code>和<code>std::unique_ptr</code>都可以自定义析构器，但前者类型中不包括自定义析构器，而后者包括。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw)&#123;</span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pw);</span><br><span class="line">                    <span class="keyword">delete</span> pw;</span><br><span class="line">                &#125;;</span><br><span class="line">std::unique_ptr&lt;Widget, <span class="keyword">decltype</span>(loggingDel)&gt;   <span class="comment">//std::unique_ptr</span></span><br><span class="line">    <span class="built_in">upw</span>(<span class="keyword">new</span> Widget, loggingDel);        <span class="comment">//类型中需要包含自定义析构器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::shared_ptr类型中不需要包含自定义析构器</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对比代码可以发现，<code>std::shared_ptr</code>的设计更具弹性。因为自定义析构器类型不在类中体现的优势有两点：</p>
<ol>
<li>可以把一系列不同析构器的对象放入容器中，但<code>std::unique_ptr</code>就办不到。</li>
<li>两个<code>std::shared_ptr</code>可以相互赋值，即便析构器类型不同。</li>
</ol>
<h4 id="1-2-特点2"><a href="#1-2-特点2" class="headerlink" title="1.2 特点2"></a>1.2 特点2</h4><blockquote>
<p> 无论自定义析构器是函数对象，还是函数指针，甚至是捕获了很多变量的lambda表达式， <code>std::shared_ptr</code>的尺寸是固定的裸指针的两倍。</p>
</blockquote>
<p>来看具体 <code>std::shared_ptr</code>的实现方式：</p>
<img src="/2023/06/10/EffectiveModernCPP/智能指针结构.png" alt="智能指针结构" style="zoom:50%;">

<p><code>std::shared_ptr</code>和裸指针相比不得不分配更多的内存，我们且取名叫控制块，这个控制块分配在堆上，或者按照自定义分配器分配的内存空间中。每一个由<code>std::shared_ptr</code>管理的<code>std::shared_ptr</code>和裸指针相比不得不分配更多的内存，我们且取名叫控制块，这个控制块分配在堆上，或者按照自定义分配器分配的内存空间中。每一个由<code>std::shared_ptr</code>管理的。</p>
<p><strong>控制块相关知识</strong></p>
<p>一个对象的控制块由创建<strong>首个</strong>指涉该对象的<code>std::shared_ptr</code>的函数来确定。</p>
<p>控制块的创建遵循以下规则：</p>
<ul>
<li><code>std::make_shared</code>总是创建一个控制块。</li>
<li>从具备专属所有权的指针(std::unique_ptr或std::auto_ptr[这个不要用拉])出发构造一个<code>std::shared_ptr</code>时，会创建一个。</li>
<li>当<code>std::shared_ptr</code>构造函数使用裸指针作为实参来调用时，会创建一个。</li>
</ul>
<p>以上规则实际上会造成一个不好的结果：</p>
<p><strong>从同一个裸指针出发构造不止一个<code>std::shared_ptr</code>的话，会出现多重控制块。</strong></p>
<p>这是一个非常危险的问题，多重控制块意味着析构的时候，每个控制块会析构一次。这是很危险的行为。<strong>以下的代码是一定不行的！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget;       <span class="comment">//pw是一个裸指针</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, loggingDel)</span></span>; <span class="comment">//为*pw创建了一个控制块</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, loggingDel)</span></span>; <span class="comment">//为*pw创建了又一个控制块</span></span><br></pre></td></tr></table></figure>

<p>以上代码在spw1和spw2析构的时候会引发多重析构行为，而这无疑会造成未指定行为的错误。</p>
<p>教训：</p>
<ul>
<li>尽可能避免把裸指针传递给<code>std::shared_ptr</code>的构造函数，请使用<code>std::make_shared</code>，但<code>std::make_shared</code>不支持传入自定义析构函数。</li>
<li>如果只能用裸指针，请按照如下方式写：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这种写法大大降低了用裸指针创建多个<code>std::shared_ptr</code>的可能性，即便要使用第二个，也只能写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(spw1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>而这种方式并不会增加控制块，是调用的<code>std::shared_ptr</code>的复制构造函数。</p>
<h3 id="2-shared-ptr构造碰上this指针而引发的多重控制块问题"><a href="#2-shared-ptr构造碰上this指针而引发的多重控制块问题" class="headerlink" title="2. shared_ptr构造碰上this指针而引发的多重控制块问题"></a>2. shared_ptr构造碰上this指针而引发的多重控制块问题</h3><p>试想这样一个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>Widget::process</code>而言，有一种<strong>看似合理的方法来完成跟踪操作</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...     <span class="comment">//处理对象本身</span></span><br><span class="line">    processedWidgets.<span class="built_in">emplace_back</span>(<span class="keyword">this</span>);    <span class="comment">// 将处理完的Widget加入链表</span></span><br><span class="line">                                            <span class="comment">// 这种做法大错特错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种行为看似合理，但极有可能在已经指涉到Widget类型的对象成员函数外部在套一层<code>std::shared_ptr</code>，未定义行为已经悄悄跟过来了。</p>
<p>有幸的是，标准库为解决上述问题提供了一种解决思路。并且使用了最古怪的一个名字，<code>std::enable_shared_from_this</code>。这个类的创作目的是:</p>
<blockquote>
<p> <strong>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全的由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，它将为你继承而来的基类提供一个模板。</strong></p>
</blockquote>
<p>那么上述代码会呈现为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-std-enbale-shared-from-this"><a href="#3-std-enbale-shared-from-this" class="headerlink" title="3. std::enbale_shared_from_this"></a>3. std::enbale_shared_from_this</h3><p><code>std::enbale_shared_from_this</code>是一个基类模板，其<strong>类型形参总是其派生类的类名</strong>。注意这是一个古怪的设定，你细品，<em>一个派生类的基类是用该派生类作为模板形参具现的类型</em>。如果不好理解，就死记吧。这代码完全合法，其背后的设计模式也已得到普遍认可，还有一个标准的名字：奇妙递归模版模式（The Curiously Recurring Template Pattern，CRTP）。</p>
<p><code>std::enbale_shared_from_this</code>定义了一个成员函数，它会创建一个<code>std::shared_ptr</code>指涉到当前对象，但同时不会重复创建控制块。这个成员函数的名字是<code>shared_from_this</code>，每当你需要一个和<code>this</code>指针指涉到相同对象的<code>std::shared_ptr</code>时，都可以在成员函数中使用它。那么上述代码实现会是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//同前，处理对象本身</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将指涉到当前对象的std::shared_ptr加入processWidgets</span></span><br><span class="line">    processedWidgets.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-std-enbale-shared-from-this-的实现机理"><a href="#3-1-std-enbale-shared-from-this-的实现机理" class="headerlink" title="3.1 std::enbale_shared_from_this 的实现机理"></a>3.1 std::enbale_shared_from_this 的实现机理</h4><p><code>shared_from_this</code>查询当前对象的控制块，并创建一个指涉到该控制块的新<code>std::shared_ptr</code>。为了实现这一点，就必须有一个已经存在的指涉到当前对象的<code>std::shared_ptr</code>。如果这样的<code>std::shared_ptr</code>不存在，那么该行为未定义，一般会由<code>shared_from_this</code>抛出异常。</p>
<h4 id="3-2-std-enbale-shared-from-this的注意事项"><a href="#3-2-std-enbale-shared-from-this的注意事项" class="headerlink" title="3.2 std::enbale_shared_from_this的注意事项"></a>3.2 std::enbale_shared_from_this的注意事项</h4><p>为了避免上述异常情况的发生，即用户在std::shared_ptr指涉到该对象前就调用了<code>shared_from_this</code>问题，一般而言，<strong>继承自<code>std::enbale_shared_from_this</code>的类通常会将其构造函数声明为private访问层级</strong>。所以代码可能会是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> :<span class="keyword">public</span> std::enbale_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将实参完美转发给private构造函数的工厂函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Ts&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> std::shared_ptr&lt;Widget&gt; <span class="title">create</span><span class="params">(Ts&amp;&amp; ... params)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;     <span class="comment">//同前</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...                 <span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-std-enable-shared-from-this实现"><a href="#3-3-std-enable-shared-from-this实现" class="headerlink" title="3.3 std::enable_shared_from_this实现"></a>3.3 std::enable_shared_from_this实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt; <span class="title">shared_from_this</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt; (<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt;	_M_weak_this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-重回控制块"><a href="#3-4-重回控制块" class="headerlink" title="3.4 重回控制块"></a>3.4 重回控制块</h4><p>一个控制块的尺寸通常只有几个字长，尽管自定义析构器和内存分配器可能会使其变得更大。但通常的控制块的实现比你语气的要更加复杂。它使用了继承，甚至会用到虚函数（ 用以确保所指涉到的对象被适当地析构）。这就意味着，使用<code>std::shared_ptr</code>也会带来控制块用到的虚函数带来的成本。</p>
<h3 id="4-std-shared-ptr成本探究"><a href="#4-std-shared-ptr成本探究" class="headerlink" title="4. std::shared_ptr成本探究"></a>4. std::shared_ptr成本探究</h3><p>之前说了那么多<code>std::shared_ptr</code>的开销，但实际上<code>std::shared_ptr</code>的开销和他提供的功能是匹配的。经典场景下，默认析构器和默认内存分配器，并且<code>std::shared_ptr</code>是由<code>std::make_shared</code>创建的前提下，控制块的尺寸只有3个字长，而且分配操作实质上没有任何成本（因为控制块随对象一起分配，而不会分开两次分配）。这意味着，使用<code>std::shared_ptr</code>并不比使用一个裸指针开销更多。</p>
<p>进行一项要求引用计数的操作（如复制构造或者复制赋值，析构）需要一个或两个原子化操作，但这些操作通常会映射到单个机器指令。尽管原子化指令相对成本较高，但仍旧是单指令。</p>
<p>控制块中的虚函数机制，通常只被每个托管给<code>std::shared_ptr</code>的对象使用一次：在该对象被析构的时候。</p>
<h3 id="5-std-shared-ptr应该合适使用"><a href="#5-std-shared-ptr应该合适使用" class="headerlink" title="5. std::shared_ptr应该合适使用"></a>5. std::shared_ptr应该合适使用</h3><p>付出了这样温和的成本后，得到的却是动态分配资源的自动生存期管理。绝大多数时候，<code>std::shared_ptr</code>用来管理共享所有权的对象生命期是十分可取的。但如果发现所管理对象是独占的，那么请使用<code>std::unique_ptr</code>，它的表现和裸指针非常相似，并且也能够很方便的转换至<code>std::shared_ptr</code>。</p>
<p>但<code>std::shared_ptr</code>并不能反转至<code>std::unique_ptr</code>。资源和指涉到它的<code>std::shared_ptr</code>之间的契约是“永续的”，不可废止，也不能免除。</p>
<h3 id="6-std-shared-ptr和std-unique-ptr的不同"><a href="#6-std-shared-ptr和std-unique-ptr的不同" class="headerlink" title="6. std::shared_ptr和std::unique_ptr的不同"></a>6. std::shared_ptr和std::unique_ptr的不同</h3><p><code>std::shared_ptr</code>不能做的事情，包括处理数组。</p>
<p>和<code>std::unique_ptr</code>的另一个不同是，<code>std::shared_ptr</code>的API仅被设计用来处理指涉到单个对象的指针。并没有所谓的<code>std::shared_ptr&lt;T[]&gt;</code>。</p>
<p>有些“聪明”的程序员会误打误撞地发现可以使用<code>std::shared_ptr&lt;T&gt;</code>来指涉到一个数组，并通过指定一个自定义析构器来完成数组删除操作（即<code>delete[]</code>）。<strong>这种做法能够通过编译，却是一个糟糕透顶的主意</strong>。</p>
<ul>
<li>一方面，<code>std::shared_ptr&lt;T&gt;</code>未提供<code>operator[]</code>，这么一来要取得数组的下标，就要用基于指针算数的笨拙表达式。</li>
<li>另一方面，<code>std::shared_ptr</code>支持从派生类到基类的指针类型转换，这对单个数组而言是有意义的，但是应用到数组的时候，会在类型系统上开天窗。也正是因为如此，<code>std::unique_ptr&lt;T[]&gt;</code>的API禁止此类型转换。</li>
<li>C++11本身就设置了比数组更好用的array，vector，string。如果在这个前提下，还非要用智能指针指向非智能的数组，那么多半是个拙劣的设计。</li>
</ul>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>std::shared_ptr</code>提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。</td>
</tr>
<tr>
<td>2. 与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用计数操作。</td>
</tr>
<tr>
<td>3. 默认的资源析构通过<code>delete</code>运算符进行，但同时也支持定制删除器。删除器的类型对<code>std::shared_ptr</code>的类型没有影响。</td>
</tr>
<tr>
<td>4. 避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>指针。</td>
</tr>
</tbody></table>
<h2 id="条款20-对于类似std-shared-ptr但有可能悬空的指针，使用std-weak-ptr"><a href="#条款20-对于类似std-shared-ptr但有可能悬空的指针，使用std-weak-ptr" class="headerlink" title="条款20 对于类似std::shared_ptr但有可能悬空的指针，使用std::weak_ptr"></a>条款20 对于类似std::shared_ptr但有可能悬空的指针，使用std::weak_ptr</h2><p>如果需要某种智能指针能够像<code>std::shared_ptr</code>一样方便，但又无需参与管理所指涉到的对象的共享所有权的话。就很好适合用<code>std::weak_ptr</code>。</p>
<p>但这样的功能同样会带来一个问题。这种指针需要处理一个对<code>std::shared_ptr</code>而言不是问题的问题：<strong>所指涉的对象有可能已经被析构</strong>。而<code>std::weak_ptr</code>的确是可以判断所指向对象是否还存在。</p>
<h3 id="1-std-weak-ptr的用途"><a href="#1-std-weak-ptr的用途" class="headerlink" title="1. std::weak_ptr的用途"></a>1. std::weak_ptr的用途</h3><p>在看完<code>std::weak_ptr</code>的API后，你可能会困惑，这东西不能取地址，也不能检查是否为空。这东西到底有什么用呢。其实这个东西需要配合<code>std::shared_ptr</code>使用，相当于<code>std::shared_ptr</code>的一种扩充。</p>
<p>用途示例，一般<code>std::weak_ptr</code>由<code>std::shared_ptr</code>创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw =                  <span class="comment">//完成spw构造后，指涉到Widget的引用计数为1</span></span><br><span class="line">std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>; <span class="comment">//wpw和spw指向同一个Widget，引用计数保持为1</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">spw = <span class="literal">nullptr</span>;              <span class="comment">// 引用计数为0，Widget对象被析构，wpw悬空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wpw.<span class="built_in">expired</span>()) ...      <span class="comment">// 若wpw不再指涉到任何对象，可以用来判断悬空</span></span><br></pre></td></tr></table></figure>

<h3 id="2-std-weak-ptr的用法"><a href="#2-std-weak-ptr的用法" class="headerlink" title="2. std::weak_ptr的用法"></a>2. std::weak_ptr的用法</h3><p>通常的一个使用场景是，<strong>判断一个<code>std::weak_ptr</code>是否已经失效，如果没有失效，就访问它所指涉的对象</strong>。</p>
<p>这个想法想起来容易，做起来难。由于<code>std::weak_ptr</code>缺乏取地址接口。写不出这样的代码，即便能写出来，也会导致竞态风险。例如如下危险代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!wpw.<span class="built_in">expired</span>())</span><br><span class="line">    <span class="keyword">auto</span> p = *wpw;      <span class="comment">//没有取地址接口，并且这里会存在竞态风险</span></span><br><span class="line">                        <span class="comment">//判断的时候没失效，但是执行的时候可能失效了</span></span><br></pre></td></tr></table></figure>

<p>所以上述场景需要一个原子操作来检验是否悬空和使用。<code>std::weak_ptr</code>接口定义了这样的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>();  <span class="comment">//若wpw悬空，则spw1为空</span></span><br><span class="line"><span class="keyword">auto</span> spw2 = wpw.<span class="built_in">lock</span>();                     <span class="comment">//若wpw悬空，则spw2为空</span></span><br><span class="line"><span class="comment">//或者用下面的方式，与上面等效</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw3</span><span class="params">(wpw)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-std-weak-ptr的使用场景"><a href="#3-std-weak-ptr的使用场景" class="headerlink" title="3. std::weak_ptr的使用场景"></a>3. std::weak_ptr的使用场景</h3><p>考虑一个工厂函数，该函数基于唯一ID来创建一些指涉到只读对象的智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">loadWidget</span><span class="params">(WidgetID id)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果loadWidget成本高昂，并且ID会被频繁使用的话，一个合理的优化是，撰写一个能够完成loadWidget的工作，但又能缓存结果的函数。而缓存所有用过的Widget可能会引起性能问题，因此另一种合理的优化是，在缓存的Widget不再有人用的时候，及时将其删除</strong>。</p>
<p>那么对于这个场景看来，返回unique_ptr就不太合适了，因为调用者会使用，但是缓存管理器也需要指涉这个对象。因此应该缓存<code>std::weak_ptr</code>。这里提供一个<strong>快速而粗糙</strong>的实现版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::unordered_map&lt;WidgetID,</span><br><span class="line">                                std::weak_ptr&lt;<span class="type">const</span> Widget&gt;&gt; cache;</span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>();     <span class="comment">//objPtr的类型是std::shared_ptr</span></span><br><span class="line">                                        <span class="comment">//指涉到缓存的对象，如果不存在，则返回空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;                      <span class="comment">//如果对象不再缓存中，</span></span><br><span class="line">        objPtr = <span class="built_in">loadWidget</span>(id);        <span class="comment">//则加载</span></span><br><span class="line">        cache[id] = objPtr;             <span class="comment">//并缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以说粗糙，是因为缓存里不用的指针会越来越多。这里如何改进的方式暂时不在本讲讨论范围内。</p>
<p>考虑这样一个使用场景，A，B，C三个对象的数据结构，A和C共享B的所有权，因此各持有一个指向B的<code>std::shared_ptr</code>。</p>
<p>为了使用方便，假设有一个指针从B指向A，那么应该如何表示呢？</p>
<p>有三个选择：</p>
<ol>
<li>裸指针： 在此情况下，A被析构，而C仍然指涉到B，B将保存着指涉到A的悬空指针。B却检查不出来，可能会产生未定义行为。</li>
<li><code>std::shared_ptr</code>：这种设计中，AB相互保存着指向对方的<code>std::shared_ptr</code>。这种环路实际上已经无法释放，已经内存泄露了。</li>
<li><code>std::weak_ptr</code>：避免了上述两个问题，可以判空，不会产生循环引用。</li>
</ol>
<p>但是这里需要指出：虽然<code>std::weak_ptr</code>在这里可以使用，但是用<code>std::weak_ptr</code>打破循环引用不是特别常见的做法。类似树结构的艳歌继承谱系中，子节点通常只被其父节点拥有，当父节点被析构后，子节点也应被析构。一般来说，这种严格的接口，可以用<code>std::unique_ptr</code>实现父节点指向子节点，而子节点的反指向可以用裸指针安全实现，因为子节点的生命周期必定小于父节点。但不是严格的树结构就不能这么用了。</p>
<h3 id="4-std-weak-ptr效率分析"><a href="#4-std-weak-ptr效率分析" class="headerlink" title="4. std::weak_ptr效率分析"></a>4. std::weak_ptr效率分析</h3><p>从效率上说，<code>std::weak_ptr</code>和<code>std::shared_ptr</code>是一致的。两个指向的对象是同一个，并且拥有相同的控制块，其构造，析构，赋值操作都包含了对引用计数的原子操作。</p>
<p>这么说可能令你惊讶，但的确如此。<code>std::weak_ptr</code>不干涉共享对象所有权，因此不会影响所指涉对象的引用计数。但实际上控制块里还有第二个引用计数（弱引用计数）。更多细节请参看Item 21。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 使用<code>std::weak_ptr</code>来代替可能悬空的<code>std::shared_ptr</code>。</td>
</tr>
<tr>
<td>2. <code>std::weak_ptr</code>可能的用武之地包括：<strong>缓存</strong>， <strong>观察者列表</strong>，以及避免<code>std::shared_ptr</code>指针环路。</td>
</tr>
</tbody></table>
<h2 id="条款21-优先选用std-make-unique和std-make-shared，而非直接使用new"><a href="#条款21-优先选用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="条款21 优先选用std::make_unique和std::make_shared，而非直接使用new"></a>条款21 优先选用std::make_unique和std::make_shared，而非直接使用new</h2><p>这里我们把<code>std::make_unique</code>和<code>std::make_shared</code>放到同一起跑线作为本条款的开端。如果您使用的是C++11没有<code>std::make_unique</code>也没事，下面的代码很容易将生成这个功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(TS&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(prams)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码可知，make_unique仅仅是将其形参向待创建对象构造函数做了一次完美转发，从一个new的运算符产生的裸指针出发，构造了一个<code>std::unique_ptr</code>而已。这个形式的函数不支持数组和自定义析构器，但它证明了只需通过一点点的努力就可以根据需要创建一个make_unique。但需要记住的是，不要把自己版本的make_unique放入std，否则等代码升级编译器的时候就报错了。</p>
<p>和<code>std::make_shared</code>与<code>std::make_unique</code>并列的，其实还有个<code>std::allocate_shared</code>。这个函数的行为和<code>std::make_shared</code>一样，只不过它的第一个参数是用以动态分配内存的分配器对象。</p>
<h3 id="1-使用make系列函数的优势"><a href="#1-使用make系列函数的优势" class="headerlink" title="1. 使用make系列函数的优势"></a>1. 使用make系列函数的优势</h3><h4 id="1-1-去除冗余代码"><a href="#1-1-去除冗余代码" class="headerlink" title="1.1 去除冗余代码"></a>1.1 去除冗余代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;      <span class="comment">//使用make系列函数</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">//不使用make系列函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;      <span class="comment">//使用make系列函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">//不使用make系列函数</span></span><br></pre></td></tr></table></figure>

<p>上述不使用make系列的函数，会产生重复撰写的问题。而<strong>代码冗余</strong>应该避免，因为冗余很容易导致不一致的缺陷。</p>
<h4 id="1-2-确保异常安全"><a href="#1-2-确保异常安全" class="headerlink" title="1.2 确保异常安全"></a>1.2 确保异常安全</h4><p>假设这样一个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priortiy)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么我们可能会有这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePrority</span>());  <span class="comment">//这里存在潜在的资源泄露风险</span></span><br></pre></td></tr></table></figure>

<p>原因在哪呢? 是与编译器从源代码翻译到目标代码的情况有关。在运行期，传递给函数的实参必须在函数调用被发起之前完成求值。所以在<code>processWidget</code>运行之前，会先执行如下步骤：</p>
<ul>
<li>表达式<code>new Wdiget</code>必须先进行求值。即一个Widget对象必须现在堆上创建。</li>
<li>由new产生的裸指针的托管对象<code>std::shared_ptr&lt;Widget&gt;</code>的构造函数必须执行。</li>
<li>computePriority必须运行。</li>
</ul>
<p>而上述三个步骤并不一定会按照某种固定顺序执行，唯一的区别只是第一条必须在第二条之前完成，其他的顺序要求没有。那么就有可能出现这样的顺序：</p>
<ol>
<li>实施“new Widget”。</li>
<li>执行computePriority。</li>
<li>运行std::shared_ptr构造函数。</li>
</ol>
<p>如果第2步出现异常，那么第一步动态分配的Widget会被泄露。因为它将永远不会被存储到第3步才接管的std::shared_ptr中。但是使用<code>std::make_shared</code>就可以避免该问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(),       <span class="comment">//不会发生潜在的资源泄露风险</span></span><br><span class="line">                <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure>

<p>按照以上写法，<code>std::make_shared</code>和<code>computePriority()</code>肯定有一个先调用。</p>
<ul>
<li><code>std::make_shared</code>先调用：则动态分配裸指针会在<code>computePriority()</code>异常之前保存在<code>std::shared_ptr</code>对象中。<code>computePriority()</code>异常之后，也能保证<code>std::shared_ptr</code>的析构函数正确释放资源。</li>
<li>如果<code>computePriority()</code>先调用：那么直接异常也不会造成动态分配了。</li>
</ul>
<p>这种逻辑在<code>std::make_shared</code>和<code>std::make_unique</code>的时候判断一样，用make系列函数可以保证异常安全。</p>
<h4 id="1-3-提高性能"><a href="#1-3-提高性能" class="headerlink" title="1.3 提高性能"></a>1.3 提高性能</h4><p>使用make系列函数会让编译器有机会利用更简洁的数据结构产生更小更快的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>

<p>显然这段代码会引发一次内存分配，但实际上会引发两次。Item 19]解释过，每个<code>std::shared_ptr</code>会指涉到一个控制块，除了其他东西之外，该控制块包含了所指涉到的对象相关联的计数引用。控制块的内存是<code>std::shared_ptr</code>的构造函数进行分配的。因此，直接使用new表达式的话，除了要为Widget进行一次内存分配，还要为控制块分配一次。</p>
<p>但如果使用下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;();</span><br></pre></td></tr></table></figure>

<p>一次内存分配足矣。因为<code>std::make_shared</code>会一次分配好单块内存同时可以放置对象和对应的控制块。</p>
<p>这种优化：</p>
<ul>
<li>减小了程序的静态尺寸，因为代码只包含一次内存分配调用</li>
<li>增加了可执行代码的运行速度，因为内存是一次性分配出来的</li>
<li><code>std::make_shared</code>还能避免控制块中一些信息的必要性，能够潜在减少了程序的内存痕迹总量</li>
</ul>
<p>同理，<code>std::make_shared</code>的性能分析也适用于<code>std::allocate_shared</code>。</p>
<h3 id="2-不能使用的特例情况"><a href="#2-不能使用的特例情况" class="headerlink" title="2. 不能使用的特例情况"></a>2. 不能使用的特例情况</h3><h4 id="2-1-无法使用std-make-shared和std-make-unique"><a href="#2-1-无法使用std-make-shared和std-make-unique" class="headerlink" title="2.1 无法使用std::make_shared和std::make_unique"></a>2.1 无法使用std::make_shared和std::make_unique</h4><ol>
<li>所有的make系列函数不允许使用自定义析构器。</li>
<li>对于有初始化列表构造函数的对象，make系列函数会抑制初始化列表构造调用，因为底层是用的圆括号而不是大括号构造的。如果非要使用大括号构造函数也不想放弃<code>std::make_shared</code>，则要这么写。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> initList = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-无法使用std-make-shared"><a href="#2-2-无法使用std-make-shared" class="headerlink" title="2.2 无法使用std::make_shared"></a>2.2 无法使用std::make_shared</h4><p>对于<code>std::make_shared</code>还有两种额外情况无法使用：</p>
<blockquote>
<p>有些类会定义自身版本的operator new和operator delete。</p>
</blockquote>
<p>这些函数意味着全局版本的内存分配和释放不适用于这个对象。通常情况下，类自定义的这两种函数被设计成仅用来分配和释放该类精确尺寸的内存块。而这样的分配器对于对象+控制块的内存大小显然不满足，所以通常不要使用make系列函数去为带有自定义版本的operator new和operator delete的类创建对象。</p>
<h3 id="3-双刃剑std-make-shared的劣势"><a href="#3-双刃剑std-make-shared的劣势" class="headerlink" title="3. 双刃剑std::make_shared的劣势"></a>3. 双刃剑std::make_shared的劣势</h3><p>之前说了<code>std::make_shared</code>效率高体现在一块内存上的单块分配。但这样也带来一个弊端，析构的时候，也需要等两者均无人引用时，才可一起释放。简单的说，<strong>拖慢了内存块释放的速度</strong>。</p>
<p>这种弊端常见于使用了<code>std::weak_ptr</code>的场景。在<code>std::shared_ptr</code>对象都没人引用，但是<code>std::weak_ptr</code>还在引用时，对应的<strong>对象空间本可以释放，只留控制块空间即可</strong>。但是由于是一块内存的原因，导致对应对象也无法立即释放。也就是说，在<code>std::make_shared</code>生成的场景下，内存块必须在最后一个<code>std::shared_ptr</code>和<code>std::weak_ptr</code>对象均析构的时候，才能得到释放。</p>
<p>在<code>std::make_shared</code>劣势明显的时候，如何保证异常安全</p>
<p>考虑之前异常安全无保证的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cusDel</span><span class="params">(Widget *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(                                      <span class="comment">//潜在的资源泄露风险</span></span><br><span class="line">    std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, cusDel),</span><br><span class="line">    <span class="built_in">computePriority</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>有了之前的分析，那么很容易写出如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(spw, <span class="built_in">computePriority</span>());              <span class="comment">//正确但并非最优化</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">move</span>(spw), <span class="built_in">computePriority</span>());   <span class="comment">//正确且高效率</span></span><br></pre></td></tr></table></figure>

<p>第二种写法使用移动语义，不会对引用计数进行变化，而变化引用计数是原子操作，开销较大。</p>
<p>但仍然要强调的是，平常你很少有机会不能使用<code>std::make_shared</code>，除非你有充分的理由不能使用，否则都应该使用它们。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 相对于直接使用new比倒是，make系列函数消除了重复代码，改进了异常安全性，并且生成的目标代码尺寸更小，速度更快。</td>
</tr>
<tr>
<td>2. 不适用于make系列的场景包括，自定义删除器以及期望直接传递大括号初始化。</td>
</tr>
<tr>
<td>3. 对于<code>std::shared_ptr</code>，不建议适用make系列的场景包括：①自定义内存管理的类②内存紧张的系统，非常大的对象以及存在比指涉<code>std::shared_ptr</code>对象生存期更长的<code>std::weak_ptr</code>对象。</td>
</tr>
</tbody></table>
<h2 id="条款22-适用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款22-适用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款22 适用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款22 适用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h2><p>如果你有和过长构建时间的抗争经历，那么你应该熟悉Pimpl习惯用法。这种技巧就是把某类的数据成员用一个指涉到某实现类的指针代替，然后把原来在主类中的数据成员放置到实现类中，并通过指针间接访问这些数据成员。例如考虑某Widget类如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;              <span class="comment">//位于头文件&quot;widget.h&quot;内</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;      <span class="comment">//Gadget是某种用户自定义类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为Widget的数据成员属于std::string，std::<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>和Gadget等多种类型，这些类型所对应的头文件必须存在，Widget才能通过编译。这说明了用户必须<code>#include &lt;string&gt; &lt;vector&gt; gadget.h</code>，但这些头文件增加了客户的编译时间，并且这些头文件变化的时候，客户也必须重新编译。</p>
<p>在C++98中，你一定见过这种常见解决方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;      <span class="comment">//仍旧位于头文件内</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();      <span class="comment">//析构函数变的必要</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;    <span class="comment">//声明实现结构体</span></span><br><span class="line">    Impl *pImpl;    <span class="comment">//以及指涉到它的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，头文件中不再需要<code>#include &lt;string&gt; &lt;vector&gt; gadget.h</code>。这样的优势会让便以速度提升，同时意味着这些头文件的改变不会影响客户代码。对于一个已声明但未定义的型参类型能做的操作极其有限，但声明一个指涉到它的指针是没问题的。</p>
<h3 id="1-Pimpl习惯用法"><a href="#1-Pimpl习惯用法" class="headerlink" title="1. Pimpl习惯用法"></a>1. Pimpl习惯用法</h3><ol>
<li>声明一个指针类型的数据成员，指涉到一个非完整类型。</li>
<li>动态分配和回收持有原始类里数据成员的对象，而分配和回收代码放在实现文件中。</li>
</ol>
<h4 id="1-1-C-98中的Pimpl写法"><a href="#1-1-C-98中的Pimpl写法" class="headerlink" title="1.1 C++98中的Pimpl写法"></a>1.1 C++98中的Pimpl写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() :<span class="built_in">pImpl</span>(<span class="keyword">new</span> Impl) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123;<span class="keyword">delete</span> pImpl;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-C-11中的Pimpl写法"><a href="#1-2-C-11中的Pimpl写法" class="headerlink" title="1.2 C++11中的Pimpl写法"></a>1.2 C++11中的Pimpl写法</h4><p>这里<code>pImpl</code>一般是用来管理动态分配的<code>Widget::Impl</code>对象的，所以在C++11中<code>std::unique_ptr</code>是一个很合适的智能指针。那么写法可能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;    <span class="comment">//这里使用了智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() :<span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>你也许会注意到，析构函数不复存在了，那是因为我们无需再为其撰写代码。</p>
<p>但非常遗憾的是，这样的写法根本无法通过编译。</p>
<p>但这是让人震惊的，原因在于：</p>
<ol>
<li>std::unique_ptr号称可以支持非完整类型；</li>
<li>Pimpl习惯用法是std::unique_ptr最广泛应用场景之一。</li>
</ol>
<p>既然这样为什么不能用呢。编不过去的原因在于：</p>
<blockquote>
<p>Widget对象析构的时候，析构函数被调用，但是我们并未声明析构函数。</p>
</blockquote>
<p>那么编译器会自动为我们生成默认析构函数，但在该析构函数内，编译器会插入代码来调用Widget的数据成员pImpl的默认析构函数。<code>std::unique_ptr</code>的默认析构器一般是用delete运算符删除对应的裸指针，从而实现析构。<strong>而在实施delete之前，典型的实现会使用C++11中的<code>static_assert</code>去确保裸指针并未指涉到非完整类型</strong>。这样一来就产生了一个失败的<code>static_assert</code>。这个信息会比较模糊，因为和对象析构的位置有关，因为Widget的析构函数与其他编译器自己产生的函数一样，是隐式inline的。所以这个编译错误通常会表示在Widget对象生成的那一行，因为正是这行源码的显示创建导致了后面的隐式析构。</p>
<h4 id="1-3-C-11中的Pimpl的解决方案"><a href="#1-3-C-11中的Pimpl的解决方案" class="headerlink" title="1.3 C++11中的Pimpl的解决方案"></a>1.3 C++11中的Pimpl的解决方案</h4><p>由上述根因可知，<strong>只需保证在生成析构<code>std::unqiue_ptr&lt;Widget::Impl&gt;</code>代码处，Widget::Impl是个完整类型即可。</strong></p>
<p>那么代码可以写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();          <span class="comment">//仅声明</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;    <span class="comment">//这里使用了智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() :<span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123;&#125;            <span class="comment">//析构函数的实现，注意一定要在Widget::Impl的实现之后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这么写</span></span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>同样的，如果上述类需要移动操作，那么也需要在头文件声明，在实现文件中<code>=default</code>。</p>
<p>但对于复制构造函数和复制构造运算符则体现略有不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);          <span class="comment">//仅声明</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">    std::unique_ptr&lt;Impl&gt; pImpl;    <span class="comment">//这里使用了智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span>                 <span class="comment">//同前</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line">...                                 <span class="comment">//同前</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;        <span class="comment">//同前</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;(*rhs.pImpl)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    *pImpl = *rhs.pImpl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-特例"><a href="#2-特例" class="headerlink" title="2. 特例"></a>2. 特例</h3><p>需要指出的是，以上的表示方式仅需要在<code>std::unique_ptr</code>时使用，对于<code>std::shared_ptr</code>则无需这样，这是源自于他们对于自定义析构器的支持不同。</p>
<ul>
<li>对于<code>std::unique_ptr</code>而言，析构器是智能指针类型的一部分，这使得编译器会产生更小尺寸的运行期数据结构以及更快的运行期代码。这种优势的代价是，欲使用编译器生成的特种函数（析构或者移动），就要指涉的类型必须是完整类型。</li>
<li>对于<code>std::shared_ptr</code>而言，析构器类型并非智能指针类型的一部分，这就需要更大的数据结构以及更慢一些的目标代码。不过这样也无需要求特种函数指涉到的类型是完整的。</li>
</ul>
<p>但话说回来，一般而言对于pImpl手法的关系一般是使用<code>std::unique_ptr</code>的。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. Pimpl是一种降低类客户和实现之间依赖性的常见手法，可以减少构建次数。</td>
</tr>
<tr>
<td>2. 对于用<code>std::unique_ptr</code>实现的Pimpl指针，须在类的头文件中声明特种成员函数，但在实现文件中再实现他们，即便默认函数有着正确的行为，也必须这么做。</td>
</tr>
<tr>
<td>3. 上述建议只适用于<code>std::unique_ptr</code>，对于<code>std::shared_ptr</code>则无需这样。</td>
</tr>
</tbody></table>
<h1 id="第五章-右值引用、移动语义和完美转发"><a href="#第五章-右值引用、移动语义和完美转发" class="headerlink" title="第五章 右值引用、移动语义和完美转发"></a>第五章 右值引用、移动语义和完美转发</h1><h2 id="条款23-理解std-move和std-forward"><a href="#条款23-理解std-move和std-forward" class="headerlink" title="条款23 理解std::move和std::forward"></a>条款23 理解std::move和std::forward</h2><blockquote>
<p><code>std::move</code>并不进行任何移动 <code>std::forward</code> 并不进行任何转发</p>
</blockquote>
<p>这两者在运行期都没有任何作为，<strong>不会产生任何可执行代码，连一个字节都不会生成</strong>。</p>
<blockquote>
<p><code>std::move</code> 和 <code>std::forward</code> 都仅仅是执行强制类型转换的函数（实际上是函数模板）</p>
</blockquote>
<ul>
<li><code>std::move</code> <strong>无条件</strong>将实参强制转换成右值。</li>
<li><code>std::forward</code><strong>仅在特点条件满足</strong>时，才执行同一个强制转换。</li>
</ul>
<p>实际上本章所有内容就这么多，但如果要说的更具体些的话。</p>
<p>再开始之前，需要记住这样一点：所有形参都是左值，即便形参的类型是个指涉到T对象的右值引用，形参也是个左值。如果忘记了这一点，可以重温Item 1。</p>
<h3 id="1-std-move的本质只是个强转"><a href="#1-std-move的本质只是个强转" class="headerlink" title="1. std::move的本质只是个强转"></a>1. std::move的本质只是个强转</h3><p>以下实现虽然不完全符合标准的所有细节，但已经非常接近了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                    <span class="comment">//位于名字空间std内</span></span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param)     <span class="comment">//  ①</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上move的本质就是上述代码中<code>①</code>的地方，其他的额外代码都是为了符合类型描述。std::move的形参是一个指涉到对象的万能引用，它返回的是指涉到同一个对象的引用。</p>
<p>上述为何要说是返回的是引用，注意返回值的<code>&amp;&amp;</code>部分，这里暗示返回值希望是一个右值。但如果T碰巧是个左值引用的话，T&amp;&amp;就成了左值引用。为了避免这种情况出现，代码中使用了<code>std::remove_reference</code>保证了<code>&amp;&amp;</code>一定是作用在非引用类型之上。从而确保了返回值一定是右值引用。所以<code>std::move</code>的本质就只是一个强转而已。</p>
<p>而上述代码在C++14中写法更为简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实在<code>std::move</code>命名之前，有人说这个函数更好的命名可能叫<code>rvalue_cast</code>。这个的确更贴切，但是既然这么叫了，也无妨。</p>
<h3 id="2-std-move也只是在通常情况下能够移动"><a href="#2-std-move也只是在通常情况下能够移动" class="headerlink" title="2. std::move也只是在通常情况下能够移动"></a>2. std::move也只是在通常情况下能够移动</h3><p>考虑这样一个场景:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(std::string text)</span></span>;  <span class="comment">//待复制的形参</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而对于只读对象，不需要修改，那么遵循着由来已久的传统：<strong>只要有可能使用const就使用const</strong>，你修改了代码变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span></span>;  <span class="comment">//待复制的形参</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了避免付出将test复制入数据成员过程中产生的复制操作成本，又将text实施了<code>std::move</code>，从而产生了一个右值。为了防止不必要的默认初始化，聪明的你采用了构造函数初始化列表的形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span>  <span class="comment">//待复制的形参</span></span></span><br><span class="line"><span class="function">    : value(std::move(text)) &#123;</span> ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码顺利的通过了编译，完成了链接，也跑了起来，体现也看起来都正确，但美中不足的是，这里的text<strong>并非是被移动的</strong>，它依旧<strong>是被复制</strong>进value的。</p>
<p><strong>以上代码逐步分析</strong></p>
<p>的确，text已经被<code>std::move</code>强转成了一个右值。但是，<code>text</code>被声明为<code>const std::string</code>，所以在强转之前，是个左值<code>const std::string</code>，而强转后变为右值的<code>const std::string</code>。</p>
<p>接着看，std::string的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;                  <span class="comment">//std::string实际上是个typedef</span></span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">//代表std::basic_string&lt;char&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">string</span>(<span class="type">const</span> string&amp; rhs);  <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="built_in">string</span>(string&amp;&amp; rhs);       <span class="comment">//移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Annotation的构造函数的成员初始化列表中，<code>std::move(text)</code>的结构是个<code>const std::string</code>类型的右值。这个右值无法传递给std::string的移动构造函数，因为移动构造函数只能接受非常量的std::string类型的右值引用作为形参。可是这样一个右值可以传递给复制构造函数，因为指涉到常量的左值引用允许绑定到一个常量右值类型的形参。	</p>
<p>因此，成员初始化最终会调用的是std::string的复制构造函数，即便text已经是一个右值。其实简单来说也好理解，<strong>move操作会改变该对象，而const对象是不允许被改变的</strong>。</p>
<p><strong>分析得到两点经验</strong></p>
<ol>
<li><p>如果想对某个对象执行移动操作，不要将其声明为const，声明后会一声不响的调用了复制构造而不通知你。</p>
</li>
<li><p><code>std::move</code>不仅不实际移动任何东西，甚至不保证经过其强转类型后的对象具备可移动能力。<code>std::move</code>操作后唯一可以确定的是，该操作返回值是个右值。</p>
</li>
</ol>
<h3 id="2-std-forward分析"><a href="#2-std-forward分析" class="headerlink" title="2. std::forward分析"></a>2. std::forward分析</h3><p>一言以蔽之：</p>
<blockquote>
<p><code>std::forward</code>是一个有条件的强制转换。</p>
</blockquote>
<p>来个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>;    <span class="comment">//处理左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; lvalArg)</span></span>;         <span class="comment">//处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span>           <span class="comment">//把param传递给process的函数模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = </span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>();   <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling &#x27;process&#x27;&quot;</span>, now);</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑两种调用logAndProcess的情景，一种传递左值，一种传入右值：	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndProcess</span>(w);                   <span class="comment">//传入左值</span></span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(w));        <span class="comment">//传入右值</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，我们肯定希望传入的左值w的时候，调用左值版本的<code>process</code>，传入右值w的时候，调用右值版本的<code>process</code>。</p>
<p>但是，如开篇所说，所有函数形参皆为左值，param也是一样。所以，所有logAndProcess内，对process的调用都会是取用了左值类型的那个重载版本。为了避免这种结果，就需要一种机制，当且仅当用来初始化param的实参是个右值的条件下，把param强制转换成右值类型。</p>
<p>以上的这些描述，就是<code>std::forward</code>的功能：<strong>仅当其实参是使用右值完成初始化时，才会执行向右值类型的强制转换</strong>。</p>
<p><code>std::forward</code>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">	<span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>std::forward</code>机制简析</strong></p>
<p><code>std::forward</code>是通过传入的T来判断传入的是左值还是右值，并将这个信息转发下去的。</p>
<p><strong><code>std::forward</code>和<code>std::move</code>的小插曲</strong></p>
<p>既然这两者都是强制转换，并且<code>std::forward</code>的功能仅仅有时会实施。这么一来你不免会问，是否可以弃用<code>std::move</code>而只用<code>std::forward</code>。纯粹从技术的角度来说是可以的，甚至纯粹从技术的角度看，这两个函数没有一个是必不可少的。因为毕竟都可以自己写强转。但依旧需要记住：</p>
<ul>
<li><code>std::move</code>是无条件强转，本质是为了移动操作做铺垫。</li>
<li><code>std::forward</code>是有条件转换，本质是为了保证传入和输出的变量左右值属性不改变。</li>
</ul>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. std::move试试的是无条件的向右值类型转换，它本身是不会执行移动操作的。</td>
</tr>
<tr>
<td>2. 仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值类型的强制类型转换。</td>
</tr>
<tr>
<td>3. 在运行期，std::move和std::forward都不会做任何操作。</td>
</tr>
</tbody></table>
<h2 id="条款24-区分万能引用和右值引用"><a href="#条款24-区分万能引用和右值引用" class="headerlink" title="条款24 区分万能引用和右值引用"></a>条款24 区分万能引用和右值引用</h2><h3 id="1-万能引用和右值引用示例"><a href="#1-万能引用和右值引用示例" class="headerlink" title="1. 万能引用和右值引用示例"></a>1. 万能引用和右值引用示例</h3><p>当你看到<code>T&amp;&amp;</code>，可能会把它当做一个右值引用。但实际上事情没有那么简单，看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>;         <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>();       <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;             <span class="comment">//非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//非右值引用</span></span><br></pre></td></tr></table></figure>

<p>实际上，<code>T&amp;&amp;</code>系列写法有两种不同的含义：</p>
<ul>
<li>一种含义，理所当然是右值引用。他们会绑定到右值，这么写的目的是<strong>为了识别出可移对象</strong>。</li>
<li>另一种含义，则表示既可以是右值引用，也可以是左值引用，两者选一个。并且他们不仅仅可以绑定到左右值，cv属性也可以绑定上去。他们几乎可以绑定到万事万物。这种史无前例的灵活的引用值值得拥有一个特殊的名字。我称之为万能引用<code>universeal reference</code>。也有些地方称之为<code>forwarding reference</code>。</li>
</ul>
<h3 id="2-万能引用达到的效果"><a href="#2-万能引用达到的效果" class="headerlink" title="2. 万能引用达到的效果"></a>2. 万能引用达到的效果</h3><ul>
<li>函数模板的形参：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">//param是个万能引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>auto声明：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;&amp; var2 = var1;        <span class="comment">//var2是个万能引用</span></span><br></pre></td></tr></table></figure>

<p>这两种使用场景的共同之处，在于他们都涉及类型推导。而实际上，万能引用的格式要求比想象中更加严格，因为如下代码看似很像，也有类型推导，但他们都不是万能引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;     <span class="comment">//param是个右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;            <span class="comment">//param是个右值引用</span></span><br></pre></td></tr></table></figure>

<p>以上例子表明万能引用的必须严格遵守格式<code>T&amp;&amp;</code>。但需要说明的是，即便看到完全符合的<code>T&amp;&amp;</code>，也不全是万能引用，因为位于<strong>模板内并不意味着一定涉及类型推导</strong>。</p>
<h3 id="3-函数模板的形参"><a href="#3-函数模板的形参" class="headerlink" title="3. 函数模板的形参"></a>3. 函数模板的形参</h3><p>看以下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);                  <span class="comment">//右值引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>push_back的形参当然具备万能引用的正确格式，但在上述代码中，并不涉及类型推导。因为push_back作为vector的一部分，对于某个特定的vector，这个push_back传参的类型是固定的。所以这个接口不涉及类型推导。但同样是vector内，另一个接口却不同的体现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> ... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args);      <span class="comment">//仍然来自C++标准</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里虽然是个可变参数包，但形式上依旧符合万能引用的格式，并且对于一个固定vector而言，这个接口的形参类型依旧是需要推导的。所以这里的Args是一个万能引用。</p>
<h3 id="4-auto声明情况"><a href="#4-auto声明情况" class="headerlink" title="4. auto声明情况"></a>4. auto声明情况</h3><blockquote>
<p>声明为auto&amp;&amp;类型的变量都是万能引用。</p>
</blockquote>
<p>在C++11中遇到的场景可能不多，但C+14中会比较频繁的遇到。主要源于C++14中lambda表达式中可以声明auto&amp;&amp;的形参。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation = </span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计时器启动</span></span><br><span class="line">        std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(</span><br><span class="line">            std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//计时器停止并记录流逝的时间</span></span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>

<p>多亏了有了<code>auto&amp;&amp;</code>这种万能引用，使得timeFuncInvocation可以算出绝大多数任何函数的执行时间。这里说绝大多数，是因为完美转发也有会失败的情况。详见Item 30。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>本条款是个谎言，或者说是个抽象。底层的真相，被称为引用折叠<code>reference collapse</code>。Item 28会展开说明这个主题。但本条款依旧有着自己的含义，作用有：</p>
<ul>
<li>区分右值引用和万能引用有助于你能更加精细的读懂代码。</li>
<li>避免你和同事交流的过程中产生歧义。</li>
</ul>
<p>理解好本条款是学习后面Item 25和Item 26的基础。就如同学习经典力学虽然并不一定对，但是对理解相对论也是有好处的。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 如果函数模板形参具备T&amp;&amp;类型，并且T是类型推导而来的，或者对象使用auto&amp;&amp;声明其应用类型，则该形参或者对象就是个万能引用。</td>
</tr>
<tr>
<td>2. 如果类别声明并不精确地具备type&amp;&amp;的形式，或者类型推导未发生，那么type&amp;&amp;就代表右值引用。</td>
</tr>
<tr>
<td>3. 若采用右值来初始化万能引用，就会得到一个右值引用。若左值，则左值引用。</td>
</tr>
</tbody></table>
<h2 id="条款25-针对右值引用实施std-move，针对万能引用使用std-forward"><a href="#条款25-针对右值引用实施std-move，针对万能引用使用std-forward" class="headerlink" title="条款25 针对右值引用实施std::move，针对万能引用使用std::forward"></a>条款25 针对右值引用实施std::move，针对万能引用使用std::forward</h2><p>右值引用仅仅会绑定到那些可供移动的对象上，如果形参为右值引用，则应该清楚了解，它绑定的对象可供移动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);   <span class="comment">//rhs确定无疑会绑定到可以移动的对象上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果，当你希望把这些对象传递给其他函数时，<strong>使用一种允许该函数利用该对象的右值性的方式</strong>。那么你可以使用这样的方法：</p>
<blockquote>
<p>把绑定到这些对象的形参转换为右值。</p>
</blockquote>
<p>而正如Item 23中介绍的，这不仅仅是<code>std::move</code>能够胜任的工作，也是<code>std::move</code>被设计出来的动机。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)),</span><br><span class="line">                            <span class="built_in">p</span>(std::<span class="built_in">move</span>(rhs.p))</span><br><span class="line">    &#123;....&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但万能引用却不一样。万能引用可以接受左值，也可以接受右值。只有当使用右值初始化的时候，才需要强制转换成右值类型。Item 23解释过，这也正是<code>std::forward</code>的所作所为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span>               <span class="comment">//newName是个万能引用</span></span></span><br><span class="line"><span class="function">    </span>&#123; name = std::forward&lt;T&gt;(newName);&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简而言之：</p>
<blockquote>
<p>当转发右值引用给其他函数的时候，应当对其使用 <code>std::move</code>，因为他们一定会绑定到右值</p>
</blockquote>
<blockquote>
<p>当转发万能引用的时候，应当对其实施<strong>有条件</strong>的向右值转换，即使用<code>std::forward</code>，因为他们不一定要绑定到右值。</p>
</blockquote>
<h3 id="1-如果对右值引用实施std-forward"><a href="#1-如果对右值引用实施std-forward" class="headerlink" title="1. 如果对右值引用实施std::forward"></a>1. 如果对右值引用实施std::forward</h3><p>需要说明的是，如果针对右值引用实施<code>std::forward</code>，也能硬弄出正确的行为来，但是代码啰嗦，易错，并且不符合习惯用法。所以**应当避免针对右值引用实施<code>std::forward</code>**。</p>
<h3 id="2-如果对万能引用实施std-move"><a href="#2-如果对万能引用实施std-move" class="headerlink" title="2. 如果对万能引用实施std::move"></a>2. 如果对万能引用实施std::move</h3><p>这样能通过编译，但是会使得某些左值遭到意外修改（例如，某些局部变量）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123; name = std::<span class="built_in">move</span>&lt;T&gt;(newName);&#125;  <span class="comment">//万能引用，使用了move</span></span><br><span class="line">                                      <span class="comment">//糟糕透顶！但是可以编译通过</span></span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>;            <span class="comment">//工厂函数</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>();               <span class="comment">//n是个局部变量</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setName</span>(n);                           <span class="comment">//将n移入了w！</span></span><br><span class="line"></span><br><span class="line">...                                     <span class="comment">//n的值变的未知</span></span><br></pre></td></tr></table></figure>

<p>这里，局部变量 <code>n</code>被传递给<code>w.setName</code>，而调用者会合情合理的假定这是一个对<code>n</code>的只读操作。但由于内部实现是<code>std::move</code>，已经强制转换为右值，<code>n</code>的值已经被移动到<code>w.name</code>中，<code>n</code>变成了一个不确定的值。这样的接口行为无疑会让人抓狂。</p>
<p>当然，也许你会诡辩，说setName不应该将形参声明为一个万能引用。你会说，只要把setName按照常量左值和右值实现出不同的重载，整个问题就结束战斗了。你给出了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;name = newName;&#125;                           <span class="comment">//从常量左值取得赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span>         <span class="comment">//从右值取得赋值</span></span></span><br><span class="line"><span class="function">    </span>&#123;name = std::<span class="built_in">move</span>(newName);&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的手法当然可以让本例正常运行，但是也带来了其他缺点。</p>
<ol>
<li>需要编写和维护更多的源代码（两个函数，而不是一个简单的模板）</li>
<li>效率要打折扣。例如考虑下面的这种setName用法：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="built_in">setName</span>(<span class="string">&quot;Xyy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在使用万能引用做形参的<code>setName</code>版本里，字符串的字面值<code>&quot;xyy&quot;</code>会被传递给<code>setName</code>，然后再传递给<code>w</code>内部<code>std::string</code>的赋值运算符。这么一来，<code>w</code>的数据成员<code>name</code>可以直接从字符串字面值得到复制，而不会产生<code>std::string</code>类型的临时变量。</p>
<p>但是重载版本的<code>setName</code>就需要创建临时变量以供<code>setName</code>调用，那么依次会产生一次<code>std::string</code>的构造函数（创建临时对象），一次<code>std::string</code>的移动赋值运算符（以移动<code>newName</code>到<code>w.name</code>），还有一次<code>std::string</code>的析构函数（以销毁临时变量）。</p>
<p>以上的执行方式，几乎肯定比仅仅调用一次<code>std::string</code>赋值运算符（通过<code>const char*</code>指针）代价要高。</p>
<h3 id="3-用左右值引用重载代替万能引用的弊端"><a href="#3-用左右值引用重载代替万能引用的弊端" class="headerlink" title="3. 用左右值引用重载代替万能引用的弊端"></a>3. 用左右值引用重载代替万能引用的弊端</h3><p>更进一步。事实就是，<strong>若用一对通过左值和右值引用的重载函数来替换使用万能引用形参的模板函数，很可能在某些情况下引发运行期效率问题</strong>。这个事实会在移动函数开销增大的时候，更加显著。具体分析可以看Item 29。</p>
<p>即便忽略代码膨胀，忽略习惯用法，忽略运行期效率折损。用左右值重载的方式，代码的可扩展性同样大打折扣。<code>Widget::setName</code>只有两个形参，但是如果有多个形参，每个都要按照左右值重载，甚至有些函数会有无穷多个形参，每个形参可能都需要左右值重载。例如我们常用的<code>std::make_shared</code>，如果涉及到C++14，那么就还有<code>std::make_unique</code>。看看他们的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ...Args&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span></span>;  <span class="comment">//选自C++11标准</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ...Args&gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span></span>;  <span class="comment">//选自C++14标准</span></span><br></pre></td></tr></table></figure>

<p>针对这种业务，重载是万万不行的。只有使用<code>std::forward</code>才能解决。</p>
<h3 id="4-更多的在万能和右值引用传参中需要注意的"><a href="#4-更多的在万能和右值引用传参中需要注意的" class="headerlink" title="4. 更多的在万能和右值引用传参中需要注意的"></a>4. 更多的在万能和右值引用传参中需要注意的</h3><p>当你在单一函数内将某个对象不止一次绑定到右值引用或者万能引用，而且你想保证完成对该对象的其他所有操作之前，其值不被移走。在这种情况下，你就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>。例如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; text)</span>                  <span class="comment">//text是个万能引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sign.<span class="built_in">setText</span>(text);                     <span class="comment">//使用text但不改变其值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = </span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>();   <span class="comment">//取得当前时间</span></span><br><span class="line"></span><br><span class="line">    signHistory.<span class="built_in">add</span>(now, </span><br><span class="line">                std::forward&lt;T&gt;(text));     <span class="comment">//有条件地将text转换为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们想要保证text的值不会被<code>sign.setText</code>修改，因为还要在调用<code>signHistroy.add</code>中使用这个值，所以只能在最后使用<code>std::forward</code>。</p>
<p>同样，对于<code>std::move</code>的使用也需要注意这点。在很少数情况下，你需要使用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。具体原因在Item 14中有讲解。</p>
<h3 id="5-什么时候，可以在返回值的地方使用move-or-forward"><a href="#5-什么时候，可以在返回值的地方使用move-or-forward" class="headerlink" title="5. 什么时候，可以在返回值的地方使用move or forward"></a>5. 什么时候，可以在返回值的地方使用move or forward</h3><blockquote>
<p>在按值返回的函数中，如果返回的是<code>绑定到一个右值引用或一个万能引用的对象</code>，则当你<code>返回该引用</code>时，应该对其实施<code>std::move</code>或<code>std::forward</code>。</p>
</blockquote>
<p>考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs,<span class="type">const</span> Matrix&amp; rhs)    <span class="comment">//按值返回</span></span><br><span class="line">&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(lhs);                          <span class="comment">//将lhs移入返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在返回语句中把lhs强制转换成右值类型，lhs会被移入函数的返回值存储位置。如果把<code>std::move</code>的调用省略：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs,<span class="type">const</span> Matrix&amp; rhs)    <span class="comment">//同上</span></span><br><span class="line">&#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> lhs;                                     <span class="comment">//将lhs复制入返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lhs</code>是个左值这一事实会强迫编译器将其复制入返回值存储位置。假定<code>Matrix</code>类型支持移动构造，这将比复制构造效率更高，从而在返回值语句中使用<code>std::move</code>会产生更高效的代码。<strong>注意，后文马上会讲到，这个使用不能推广到任何地方</strong>。</p>
<p>假如<code>Matrix</code>不支持移动，将其转换为右值也并无大碍，因为右值也就是会通过<code>Matrix</code>的复制构造函数来完成复制而已（详见Item 23）。但若Matrix后来被修改为支持移动操作，则下次编译完成过后，<code>operator+</code>就能自动获益。这个例子中，对函数按值返回的右值引用实施<code>std::move</code>，不会付出任何代价（可能还会有不小收益）。</p>
<p>对于万能引用来说，情况类似。考虑如下业务场景，函数模板reduceAndCopy，它接收一个可能未月份的Fraction对象，实施约分，然后返回一个约分后的副本。如果原始对象是一个右值，它的值应当被移动到返回值上（这样可以避免制造副本的成本）。但如果原始对象是一个左值，那就必须创建出实实在在的副本来。因此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduceAndCopy</span><span class="params">(T&amp;&amp; frac)</span>        <span class="comment">//按值返回万能引用形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    frac.<span class="built_in">reduce</span>();</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;T&gt;(frac);       <span class="comment">//对于右值，是移动返回值</span></span><br><span class="line">                                        <span class="comment">//对于左值，是复制返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果省去对<code>std::forward</code>的调用，则frac会无条件地被复制到reduceAndCopy的返回值。</p>
<h3 id="6-什么时候，不可以在返回值的地方使用move-or-forward"><a href="#6-什么时候，不可以在返回值的地方使用move-or-forward" class="headerlink" title="6. 什么时候，不可以在返回值的地方使用move or forward"></a>6. 什么时候，不可以在返回值的地方使用move or forward</h3><p>以上相同的优化逻辑，不可用于<strong>欲返回的局部变量</strong>上。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span>     <span class="comment">//makeWidget的“复制”版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;           <span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">    ...                 <span class="comment">//操作w</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w;           <span class="comment">//将w“复制”入返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而可以通过将“复制”转为移动来“优化”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span>     <span class="comment">//makeWidget的“移动”版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w); <span class="comment">//将w“移动”入返回值，别这么做！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为什么不要在局部变量返回的时候，使用<code>std::move</code>呢。</p>
<p>根本原因在于：标准化委员会已经领先于上例中的那些程序猿很多年前就处理了这种优化问题。人们很久之前就认识到，<code>makeWidget</code>的“复制”版本可以通过直接在为函数返回值分配的内存上创建局部变量w来避免复制，这就是我们熟知的返回值优化（return value optimization, RVO），这是C++标准一问世就有的，白纸黑字写下来的福音。</p>
<p>但上述福音的措辞十分严谨，因为所有优化仅仅在当其不影响软件的可观测行为时，才允许发生。所以RVO需要满足两个前提条件：</p>
<ol>
<li>局部对象类型和函数返回值类型相同。</li>
<li>返回的就是局部对象本身。</li>
</ol>
<p>那么再回头分析上述“复制”版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span>     <span class="comment">//makeWidget的“复制”版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;           <span class="comment">//局部变量</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> w;           <span class="comment">//将w“复制”入返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在复制版本中，两个前提条件都满足了。也就是复制的版本并不会进行任何复制。</p>
<p>再分析移动版本。移动版本的<code>makeWidget</code>做了名副其实的事情（假设<code>Widget</code>提供了移动构造函数）：它移动了<code>w</code>的内容到<code>makeWidget</code>函数的返回值空间。但为什么编译器没有用RVO来消除移动，而是在函数返回值分配的内存空间里重建了一个<code>w</code>呢？</p>
<p>因为前提条件2规定了，RVO只能在返回值是一个局部对象本身时执行，而移动版本的<code>makeWidget</code>里并非如此。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> std::<span class="built_in">move</span>(w);</span><br></pre></td></tr></table></figure>

<p>这里返回的不是局部对象<code>w</code>，而是<code>w</code>的引用，<code>std::move(w)</code>的结果。返回一个局部对象的引用并不满足实施RVO的前提条件，因此编译器必须把<code>w</code>移入函数的返回值存储位置。</p>
<p><strong>开发者本来企图通过对即将返回的局部变量实施<code>std::move</code>来帮编译器进行优化，然而实际上却适得其反地限制了本来可用的编译优化选项！</strong></p>
<h3 id="7-进一步深究RVO"><a href="#7-进一步深究RVO" class="headerlink" title="7. 进一步深究RVO"></a>7. 进一步深究RVO</h3><p>RVO是种优化。编译器并无义务省略复制和移动操作，即便可以这么做。</p>
<p>那么也许你比较偏执，担心编译器没有在可以做的时候，好好优化。又或者你觉得在有些情况下，编译器要实施RVO会存在困难。你可能认为付出移动的代价是一种为了避免复制而缴纳的保险。也就是你也许仍然认为，针对欲返回的局部对象实施<code>std::move</code>是合理的。仅仅因为这么一来，你就可以放宽心，因为绝不会为复制付出成本。</p>
<p>可是抱歉，即使在上述假设的情况下，针对局部变量实施<code>std::move</code>仍然是个馊主意。</p>
<p>因为标准中个关于RVO的福音中，后面接着说明。</p>
<blockquote>
<p>即使实施RVO的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。</p>
</blockquote>
<p>这么一来，就等于标准要求：当RVO的前提条件允许是，要么发生复制省略，要么<code>std::move</code>被隐式地被实施于返回的局部对象上。因此，在<code>makeWidget</code>的“复制”版本中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span>     <span class="comment">//makeWidget的“复制”版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;           <span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">    ...                 <span class="comment">//操作w</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w;           <span class="comment">//将w“复制”入返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器必须要么省略w的复制操作，要么让函数进行特别处理，以便与一下代码等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w);    <span class="comment">//w会作为右值处理，</span></span><br><span class="line">                            <span class="comment">//原因是复制省略没有实施</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述情况与按值传递的函数形参类似。他们作为函数返回值时，不会实施复制省略，但编译器必须在其返回时作为右值处理。</p>
<p>以结果论，如果你的代码看起来是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span>     <span class="comment">//按值传递的形参，与函数返回值类型相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...                 </span><br><span class="line">    <span class="keyword">return</span> w;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译器必须处理上面这段代码，以使得他们与以下代码等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span>     <span class="comment">//按值传递的形参，与函数返回值类型相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...                 </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w);        <span class="comment">//将w作为右值处理          </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，针对函数中按值返回的局部对象实施<code>std::move</code>的操作，不能给编译器帮忙（如果不执行复制省略，就必须将局部对象作为右值处理，效果一样），却可以帮倒忙（可能会抑制RVO）。的确存在适合于针对局部变量实施<code>std::move</code>的情况（即，将其传递给某个函数，并且你确定自己不会再使用该变量），但是其作为return语句的一部分时，要么适合RVO，要么返回一个按值形参，从而并不属于以上的那些情况。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 针对右值引用的最后一次使用实施<code>std::move</code>，针对万能引用的最后一次使用实施<code>std::forward</code>。</td>
</tr>
<tr>
<td>2. 作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为。</td>
</tr>
<tr>
<td>3. 若局部对象可能适用于返回值优化，则请勿针对其实施<code>std::move</code>或<code>std::forward</code>。</td>
</tr>
</tbody></table>
<h2 id="条款26-避免对万能引用类型进行重载"><a href="#条款26-避免对万能引用类型进行重载" class="headerlink" title="条款26 避免对万能引用类型进行重载"></a>条款26 避免对万能引用类型进行重载</h2><h3 id="1-一个常见的使用背景"><a href="#1-一个常见的使用背景" class="headerlink" title="1. 一个常见的使用背景"></a>1. 一个常见的使用背景</h3><p>假设一个业务场景是这样的：</p>
<p>取用一个名字作为形参，然后记录下当前时间，在把该名字添加到一个全局数据结构中。也许你会这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; names;       <span class="comment">//全局数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">const</span> std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = </span><br><span class="line">    std::chrono::system_clock::<span class="built_in">now</span>();   <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);              <span class="comment">//制备日志条目</span></span><br><span class="line">    names.<span class="built_in">emplace</span>(name);                <span class="comment">//将名字添加到全局数据结构中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑正确，但是效率可能不如人意，考虑如下调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">logAndAdd</span>(petName);                     <span class="comment">//传递左值std::string ①</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));   <span class="comment">//传递右值std::string ②</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);                 <span class="comment">//传递字符串字面量     ③</span></span><br></pre></td></tr></table></figure>

<p>在情况①中，<code>logAndAdd</code>的形参<code>name</code>绑定到了变量<code>petName</code>。在<code>logAndAdd</code>内部，<code>name</code>最终被传递给了<code>names.emplace</code>。由于<code>name</code>是个左值，它是被复制入<code>names</code>的。没有任何办法避免这个复制操作，因为传递给<code>logAndAdd</code>的是个左值(petName)。</p>
<p>在情况②中，形参<code>name</code>绑定到一个右值(从<code>Persephone</code>显式构造的<code>std::string</code>类型的临时变量)。name自身是个左值，所以它是被复制入names的。但我们能够认识到，原则上该值是可以被移动入names的。所以在这个调用中，我们付出了一个复制的成本，但是我们可以用一次移动来达成同样的目标。</p>
<p>在情况③中，形参<code>name</code>还是绑定到一个右值，但这次这个<code>std::string</code>类型的临时对象是从<code>Patty Dog</code>隐式构造的。和第二个调用语句的情况一样，<code>name</code>是被复制入<code>names</code>的，但在本语句中，传递给<code>logAndAdd</code>的实参是个字符串字面量。如果该字符串字面量是被直接传递给<code>emplace</code>，那就完全没有必要构造一个<code>std::string</code>类型的临时对象。<code>emplace</code>完全可以利用这个字符串字面量在<code>std::multiset</code>内部直接构造一个<code>std::string</code>对象。这里我们付出了复制一个<code>std::string</code>对象的成本，但实际上我们连一次移动的成本都没有必要付出，更别说复制了。</p>
<p>我们可以解决第二个和第三个调用语句的效率低下问题，只需重写<code>logAndAdd</code>，让它接收一个万能引用（见Item 24），并且根据Item 25，对该引用实施<code>std::forward</code>给到<code>emplace</code>。重写结果不言自明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(petName);                     <span class="comment">//这里和上面一样，左值进行复制到multiset</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));   <span class="comment">//这里对右值实施移动而非复制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);                 <span class="comment">//在multiset中直接构造一个std::string对象，</span></span><br><span class="line">                                        <span class="comment">//而非复制一个std::string类型的临时对象</span></span><br></pre></td></tr></table></figure>

<p>非常完美，效率达到极致了！</p>
<h3 id="2-万能引用类型进行重载"><a href="#2-万能引用类型进行重载" class="headerlink" title="2. 万能引用类型进行重载"></a>2. 万能引用类型进行重载</h3><p>但实际上，该函数的客户并不总能直接访问到<code>logAndAdd</code>所需要的名字。有些客户只能访问到一个索引，<code>logAndAdd</code>需要根据该索引来查询一张表才能找到对应的名字。为了支持这样的客户，<code>logAndAdd</code>提供了重载版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;       <span class="comment">//返回索引对应的名字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">int</span> idx)</span>                 <span class="comment">//新的重载函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(<span class="built_in">nameFromIdx</span>(idx));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时的重载决议符合期望：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(petName);                     <span class="comment">//和forward版本行为一致</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));   <span class="comment">//和forward版本行为一致</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);                 <span class="comment">//和forward版本行为一致</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="number">22</span>);                          <span class="comment">//本句调用了形参类型为int的重载版本</span></span><br></pre></td></tr></table></figure>

<p>但事情不是总是想象的那么美好，假设客户使用了一个<code>short</code>类型的变量来持有这个索引值，并将该变量传递给了<code>logAndAdd</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> nameIdx;          <span class="comment">//赋值给nameIdx</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">logAndAdd</span>(nameIdx);     <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>这里解释一下，为何会错误：</p>
<p><code>logAndAdd</code>有两个重载版本。形参类型为<code>T&amp;&amp;</code>的版本可以将T推导为<code>short</code>，从而产生一个精确匹配。而形参类型为<code>int</code>的版本却只能在类型提升以后才能匹配到<code>short</code>类型的实参。按照普适的重载决议规则，精确匹配优先于提升后才能匹配。所以，形参类型为万能引用的版本才是被调用到的版本。</p>
<p>调用执行后，形参<code>name</code>被绑定到传入的<code>short</code>类型变量上。然后，<code>name</code>被<code>std::forward</code>传递给<code>names</code>（一个<code>std::multiset&lt;std::string&gt;</code>）的<code>emplace</code>成员函数，然后，又被转发给<code>std::string</code>的构造函数。而在<code>std::string</code>的构造函数并不存在以<code>short</code>为传参的版本。这一切的原因归根结底在于，对于<code>short</code>的类型实参来说，万能引用产生了比<code>int</code>更好的匹配。</p>
<p><strong>形参为万能引用的函数，是C++中最贪婪的</strong>。他们会在具现过程中，和几乎任何实参类型都会产生精确匹配（例外情况详见Item 30）。这就是为何把重载和万能引用两者结合起来，几乎总是馊主意：<em><strong>一旦万能引用成为重载候选，他就会吸引走大批的实参类型，远比撰写重载代码的程序猿期望的要多</strong></em>。</p>
<h3 id="3-构造函数使用万能引用"><a href="#3-构造函数使用万能引用" class="headerlink" title="3. 构造函数使用万能引用"></a>3. 构造函数使用万能引用</h3><blockquote>
<p>填上这个坑的一个简单办法，是撰写一个带完美转发的构造函数。<br><code>请记住这话是个挖下了一个更大的坑。但我们继续看为什么这个坑更大</code></p>
</blockquote>
<p>对<code>logAndAdd</code>这个示例做了一点点修改，就暴露了问题。我们先不去撰写一个自由函数来同时取用<code>std::string</code>或一个用以查表返回<code>std::string</code>的索引，而是先考虑一个<code>Person</code>类，它的构造函数有相同的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span> : name(std::forward&lt;T&gt;(n))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;                                  <span class="comment">//完美转发构造函数，初始化数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> indx)</span> : name(nameFromIdx(idx))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;                                  <span class="comment">//形参为int的构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>logAndAdd</code>的情景中，传入一个非int类型的整型（例如<code>std::size_t</code>、<code>short</code>、<code>long</code>等）都会导致调用形参为万能引用的构造函数重载版本，从而引发编译失败。但是上例中都的情景则要糟糕的多，因为在<code>Person</code>中还有比我们肉眼所见更多的重载版本。Item 17解释了，在适当条件下，C++会同时生成复制和移动构造函数，并且这一点在即使类中包含着一个模板化的构造函数，且它可以具现出复制和移动构造函数的前面来的前提下也依然成立。假如<code>Person</code>中真的如此生成了复制和移动构造函数，那么它实际上会是呈现成这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span> :name(std::forward&lt;T&gt;(n))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;                              <span class="comment">//完美转发构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span></span>;       <span class="comment">//形参为int的构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);      <span class="comment">//复制构造函数（由编译器生成）</span></span><br><span class="line">    <span class="built_in">Person</span>(Person&amp;&amp; rhs);           <span class="comment">//移动构造函数（由编译器生成）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只有花费了大量时间与编译器和写编译器的人打交道，才能形成对于程序行为的直觉，并忘记普通人的思维方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;       <span class="comment">//从p触发创建新的Person类型对象，</span></span><br><span class="line">                        <span class="comment">//上述代码无法通过编译！</span></span><br></pre></td></tr></table></figure>

<p>在这里我们尝试从一个<code>Person</code>出发，创建另一个<code>Person</code>，看起来再明显不过会是调用复制构造的情况（p是个左值，这就足以打消一切机会将“复制”通过移动完成的想法）。但这段代码竟没有调用复制构造函数，而是调用了完美转发构造函数。该函数是在尝试从一个<code>Person</code>类型的对象（p）出发来初始化另个一个<code>Person</code>类型的对象的<code>std::string</code>类型的数据成员。而<code>std::string</code>类型却不具备接受<code>Person</code>类型形参的构造函数，你的编译器只能举手投降，也许会丢出一堆冗长且无法理解的错误信息作为发泄。</p>
<p>你可能感觉到莫名其妙，“这是怎么回事？怎么会调用的是完美转发构造函数而不是复制构造函数呢？这不是明明在用一个<code>Person</code>类型的对象初始化另一个<code>Person</code>类型的对象吗？”确实是在做这件事，但是编译器是宣誓效忠C++规则的，而这里用到的规则关于调用重载函数时的决议。</p>
<p>编译器是这么思考问题的：</p>
<p><code>cloneOfP</code>被非常量左值（p）初始化，那意味着模板构造函数可以实例化来接受<code>Person</code>类型的非常量左值形参。如此实例化后，<code>Person</code>的代码应该变成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(Person&amp; n)</span> :name(std::forward&lt;Person&amp;&gt;(n))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;                              <span class="comment">//完美转发构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span></span>;       <span class="comment">//形参为int的构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);      <span class="comment">//复制构造函数（由编译器生成）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在下述语句中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>p</code>既可以传递给复制构造函数，也可以传递给实例化了的模板。但是调用复制构造的话，就要先对<code>p</code>添加<code>const</code>修饰。因而，模板生成的重载版本是更加匹配，所以编译器的做法完全符合设计：它调用了符合更加匹配原则的函数。这么一来，“复制”一个非常量左值的左值<code>Person</code>类型对象，会由完美转发构造函数，而不是复制构造函数来完成。</p>
<p>如果我们稍微修改一下代码，使得复制之物成为一个常量对象，反响就完全不同了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;    <span class="comment">//对象成为常量了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;           <span class="comment">//这回调用的是复制构造函数了！</span></span><br></pre></td></tr></table></figure>

<p>因为想要复制的对象是个常量，就形成了对复制构造函数形参的精确匹配。另一方面，那个模板化的构造函数可以经由实例化得到的同样的签名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> Person&amp; n)</span></span>;  <span class="comment">//从模板触发实例化</span></span><br><span class="line">                                    <span class="comment">//而得到的构造函数</span></span><br><span class="line"> <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);         <span class="comment">//复制构造函数（由编译器生成）</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这并不要紧，因为C++重载决议规则中有这么一条：<strong>若在函数调用时，一个模板实力化函数和一个非函数模板（即，一个“常规”函数）具备相等的匹配程度，则优先选用常规函数</strong>。</p>
<p>根据这一条，在签名相同时，复制构造函数（它是个普通函数）就会压过实例化了的函数模板。</p>
<p>（如果你想知道，为什么明明实例化了的模板构造函数已经生成了和复制构造函数一模一样的签名，编译器还会生成复制构造函数，请参考Item 17）</p>
<h3 id="4-当继承遇上完美转发构造函数模板时"><a href="#4-当继承遇上完美转发构造函数模板时" class="headerlink" title="4. 当继承遇上完美转发构造函数模板时"></a>4. 当继承遇上完美转发构造函数模板时</h3><p>完美转发构造函数与编译器生成的复制和移动操作之间的那些错综复杂的关系，再加上继承以后就变的让人更加眉头紧锁。特别的，派生类的复制和移动操作的平凡实现会表现出让人大跌眼镜的行为。请看好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) <span class="comment">//复制构造函数：</span></span><br><span class="line">    :<span class="built_in">Person</span>(rhs)                            <span class="comment">//调用的是基类的完美转发函数！</span></span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    <span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs)      <span class="comment">//移动构造函数：</span></span><br><span class="line">    :<span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs))                 <span class="comment">//调用的是基类的完美转发函数！</span></span><br><span class="line">    &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注释说的很明白，派生类的复制和移动构造函数并未调用到基类的移动和复制构造函数，调用到的是基类的完美转发构造函数！要理解背后的原因，<strong>请注意，派生类函数把类型为<code>SpecialPerson</code>的实参传递给了基类，然后在Person类的构造函数中完成模板实例化和重载决议</strong>。最终，代码无法通过编译，因为<code>std::string</code>的构造函数中没有任何一个会接受<code>SpecialPerson</code>类型的形参。</p>
<h3 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5.  总结"></a>5.  总结</h3><p>我希望我已经说服了你去尽可能避免以把万能引用类型作为重载函数的形参选项。不过，如果使用万能引用进行重载是个糟糕的思路，而你有需要针对绝大多数的实参类型实施转发，只针对某些实参类型实施特别处理，这时应该怎么做呢？解决的办法多种多样，后续Item 27将详细展开。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 把万能引用作为重载候选类型，几乎总会让该重载版本在始料未及的情况下被调用。</td>
</tr>
<tr>
<td>2. 完美转发构造函数的问题尤其严重，因为对于非常量的左值类型而言，他们一般都会形成相对于复制构造函数的更加匹配，并且他们还会劫持派生类中对于基类的复制和移动构造函数的调用。</td>
</tr>
</tbody></table>
<h2 id="条款27-万能引用进行重载的替代方案"><a href="#条款27-万能引用进行重载的替代方案" class="headerlink" title="条款27 万能引用进行重载的替代方案"></a>条款27 万能引用进行重载的替代方案</h2><p>Item 26说过，万能引用和重载在一起总会产生各种各样的问题，无论是独立函数，成员函数，都最好不要和万能引用放一起重载，其中构造函数和万能引用放一起问题最为严重。不过实际业务中其实的确有这样的真实需求。本条款对这种需求的解决方案进行了探讨。提出了几种合适的解决方案。目的在于获得期望的行为，方法。</p>
<p>以下各个手法均以Item 26中构建的代码为基础的，如果没看或者不熟悉，那么先了解一下再继续下去。</p>
<h3 id="1-几种替代方案"><a href="#1-几种替代方案" class="headerlink" title="1. 几种替代方案"></a>1. 几种替代方案</h3><h4 id="1-1-放弃重载"><a href="#1-1-放弃重载" class="headerlink" title="1.1 放弃重载"></a>1.1 放弃重载</h4><p>Item 26的第一个例子，<code>logAndAdd</code>，可以作为很多函数的代表，这样的函数只需把本来准备进行重载的函数换个名字就可以避免被万能引用进行重载。以<code>logAndAdd</code>为例，可以分别叫<code>logAndAddName</code>和<code>logAndAddNameIdx</code>。<br>很可惜的是，这种方式并不适合第二个例子—————Person 类的构造函数，因为构造函数的名字是由语言固化的。而且彻底放弃重载也不是长久之计。</p>
<h4 id="1-2-传递const-T-类型的形参"><a href="#1-2-传递const-T-类型的形参" class="headerlink" title="1.2 传递const T&amp;类型的形参"></a>1.2 传递const T&amp;类型的形参</h4><p>一种替代方法是回归 C++98，使用传递左值常量引用类型代替传递万能引用类型。其实，这就是Item 26做的第一种问题解决尝试。这种方案的缺点是达不到我们想要的高效率。不过在已知万能引用类型进行重载会带来的不良效果后，放弃部分效率来保持简洁性不失为一种有吸引力的权衡结果。</p>
<h4 id="1-3-传值"><a href="#1-3-传值" class="headerlink" title="1.3 传值"></a>1.3 传值</h4><p>一种经常能够提升性能，却不用增加一点复杂性的方法，就是把传递的形参从引用类型转换成值类型，<strong>尽管这样做是反直觉的</strong>。这种设计遵循了Item 41的建议————当你知道肯定需要复制形参时，考虑按值传递对象。<br>书中把相关的运行原理和效率提升的细节推迟到Item 41讨论，而在此仅仅展示一下该技术在 Person 例子里的应用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string n)</span>  <span class="comment">//替换掉T&amp;&amp;类型的构造函数</span></span></span><br><span class="line"><span class="function">        : name(std::move(n)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span>        <span class="comment">//同前</span></span></span><br><span class="line"><span class="function">        : name(nameFromIdx(ix)) &#123;</span>&#125;</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>std::string</code>类型并没有只接受单个整形形参的构造函数，所有的<code>int</code>或者类<code>int</code>类型（例如 <code>short</code>，<code>long</code>，<code>std::size_t</code>）的实参都会汇集到接受<code>int</code>的那个构造函数重载版本的调用。类似，所有<code>std::string</code>类型的实参（包含可以构造出<code>std::string</code>类型的对象物，例如字面量<code>&quot;HHAA&quot;</code>）都会被传递给接受<code>std::string</code>的那个构造函数重载版本的调用。</p>
<h4 id="1-4-标签分派"><a href="#1-4-标签分派" class="headerlink" title="1.4 标签分派"></a>1.4 标签分派</h4><p>无论是传递左值常量还是传值，都不支持完美转发。如果业务里就是要使用完美转发，那么只能采用万能引用，别无他法。但重载也不想舍弃的时候，应该怎么办呢。</p>
<p>其实解决之道并不是很难。<br><strong>重载函数在调用时的决定逻辑如下：</strong></p>
<blockquote>
<p>考察所有重载版本的形参，以及调用端传入的实参，然后选择全局最佳匹配的函数，这个步骤需将所有的形参&#x2F;实参组合都考虑在内。</p>
</blockquote>
<p>一个万能引用形参通常会导致的后果是无论传入了什么都给出一个精确匹配结果，不过，如果万能引用仅仅是形参列表的一部分，该列表中还有其他非万能引用类型的形参的话，那么只要该非万能引用形参具备充分差（sufficiently poor）的匹配能力，则它就足以将这个带有万能引用形参的重载版本踢出局。这个想法就是标签分派手法的基础，为便于后续理解，先看一个例子。</p>
<p>先看看之前的<code>logAndAdd</code>的例子试试标签分派的改造，这里把代码重新列一次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; names; <span class="comment">//全局数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就此函数本身而言，一切运作正常。可是一旦引入接受int的重载版本，以按索引查找对象时，就会重回Item26的麻烦境地。本条款的目的，就在于避免那些问题，方法是不在添加重载版本，而是重新实现<code>logAndAdd</code>，把它委托给另外两个函数，一个接受整型值，另一个接受其他所有类型。而<code>logAndAdd</code>本身则接受所有类型的实参。</p>
<p>这两个完成了实际工作的函数名字为<code>logAndAddImpl</code>，所以我们重载的实际是<code>logAndAddImpl</code>。而这两个函数中，还有第二个形参，该形参用来判断传入的实参是否为整型。正是这第二个形参组织了我们落入Item26所描述的陷阱中。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name), </span><br><span class="line">                    std::<span class="built_in">is_integral</span>&lt;T&gt;()); <span class="comment">//不够正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数实际上把他的形参转发给了<code>logAndAddImpl</code>，但它还传递了另一个实参，用来表示那个形参的类型（T）是否为整型。至少，它应该做到这件事。若传给<code>logAndAdd</code>的实参是右值整型，它就做到了。</p>
<p><strong>为何不够正确</strong></p>
<p>但是，如Item28所言，如果传给万能引用name的实参是个左值，那么T就会被推导为左值引用。所以，如果传递给<code>logAndAdd</code>的是个左值int，则T就会被推导为int&amp;。这不是个整型，因为引用类型都不是整型。这意味着<code>std::is_intergral&lt;T&gt;</code>在函数接受了任意左值实参时，会得到结果“假”，尽管这样的实参确实表示了一个整型值。</p>
<p><strong>应该如何修改</strong></p>
<p>意识到问题所在，也就相当于已经解决了问题。<code>std::remove_reference</code>，正如其名，也正如所需：它会移除类型所附加的一切引用饰词。因此，正确的<code>logAndAdd</code>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(</span><br><span class="line">        std::forward&lt;T&gt;(name),</span><br><span class="line">        std::is_intergral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这才算完成了整套戏法（C++14中可以少敲几下键盘，因为可以把typename后面的换成<code>std::remove_reference_t&lt;T&gt;</code>代替。欲知详情，参见Item 9。）</p>
<p>完成<code>logAndAdd</code>以后，就可以把注意力放在<code>logAndAddImpl</code>上了。这个函数有两个重载版本，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span>       <span class="comment">//非整型实参，将名字添加到全局数据结构中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译期的true和false</strong></p>
<p>只要你理解了<code>std::flase_type</code>的形参背后的运行机制，就能看出来这段直接了当的代码。概念上，<code>logAndAdd</code>会向<code>logAndAddImpl</code>传递一个布尔值，用来表示传递给<code>logAndAdd</code>的实参是否为整型。不过，<code>true</code>和<code>false</code>都是运行期值，可是我们需要利用的是重载决议（一种编译现象）来选择正确的<code>logAndAddImpl</code>重载版本。这就意味着我们需要一个对应于<code>true</code>的类型，和一个对应于<code>false</code>的的不同类型。这个需求足够朴实，所以C++标准库提供了名为<code>std::true_type</code>和<code>std::false_type</code>的一对类型来满足之。若T是整型，则经由<code>logAndAdd</code>传递给<code>logAndAddImpl</code>的实参就会是个继承自<code>std::true_type</code>的对象。反之，若T不是整型，该实参就会是个继承自<code>std::false_type</code>的对象。总的结果是，只有当T不是整型时，<code>logAndAdd</code>发起的调用才会从候选中选定上面这个<code>logAndAddImpl</code>的版本。<br>第二个重载版本则包含了T是整型的相反情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;               <span class="comment">//同Item26</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span>     <span class="comment">//整型实参：</span></span></span><br><span class="line"><span class="function"></span>&#123;                                               <span class="comment">//查找名字并用它调用</span></span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));                <span class="comment">//logAndAdd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过让<code>logAndAddImpl</code>按索引查找对应名字，然后传递给<code>logAndAdd</code>（在那里，它会经由std::forward转发到另一个<code>logAndAddImpl</code>重载版本）。就可以避免在两个重载版本都放入记录日志的代码。</p>
<h3 id="2-什么是标签分派"><a href="#2-什么是标签分派" class="headerlink" title="2. 什么是标签分派"></a>2. 什么是标签分派</h3><p>在上述设计中，类型<code>std::true_type</code>和<code>std::false_type</code>就是所谓的“标签”，运用他们的唯一目的在于强制重载决议按照我们想要的方向推进。值得注意的是，这些形参甚至没有名字。他们在运行期不起任何作用，实际上，我们希望编译器能识别出这些标签形参并未使用过，从而将他们从程序执行镜像中优化掉（某些编译器的确会这样做，至少有时会）。针对<code>logAndAdd</code>内的重载实现函数发起的调用把工作“分派”到正确的重载版本的手法就是创建适当的标签对象。这种设计因而得名：标签分派。它是模板元编程的标准构件，所以你越是深入地查看当下的C++库代码，你也就越是会频繁的看到这种设计。那么这一小部分，更重要的不在于标签分派的工作细节，而是它让我们得以<strong>将万能引用和重载组合却不会引发Item26所描述的问题的能力</strong>。</p>
<h4 id="2-1-万能引用下，标签分派设计思路"><a href="#2-1-万能引用下，标签分派设计思路" class="headerlink" title="2.1 万能引用下，标签分派设计思路"></a>2.1 万能引用下，标签分派设计思路</h4><p>分派函数<code>logAndAdd</code>接受的是个不受限制的万能引用形参，但该函数并未重载。实现函数<code>logAndAddImpl</code>则实施了重载，每个重载版本都接受一个万能引用形参，但重载决议却并不仅对这个万能引用形参有依赖，还对标签有依赖，这个标签值则设计保证可以命中匹配的函数不超过一个。<br>这样设计的结果是，只有标签值才决定了调用的是哪个重载版本。万能一样弄形参总是给出精确匹配这个事实，也就无关紧要了。</p>
<h4 id="2-2-对接受万能引用的模板加以限制"><a href="#2-2-对接受万能引用的模板加以限制" class="headerlink" title="2.2 对接受万能引用的模板加以限制"></a>2.2 对接受万能引用的模板加以限制</h4><p>标签分派能够发挥作用的关键在于，存在一个单版本（无重载）函数作为客户端API。此单版本函数会把待完成的工作分派到实现函数。创建无重载的分派函数通常并不难，但Item26 所关注的第二个问题，即关于Person类的完美转发构造函数的那个问题，却是个例外。<strong>编译器可能会自行生成复制和移动构造函数</strong>，所以如果仅仅撰写一个构造函数，然后在其中运用标签分派，那么有些针对构造函数调用就可能会由编译器生成的构造函数接手处理，<strong>从而绕过了标签分派系统</strong>。</p>
<p>实际上，真正的问题并不在于编译器生成的函数有时候会绕过标签分派设计，而在于<strong>编译器生成的函数<code>并不能</code>保证一定会绕过标签分派设计</strong>。当收到使用左值对象进行同类型对象的复制请求时，你机会总会期望调用到的是复制构造函数。但是，就如Item26所演示的那样，只要提供了一个接受万能引用形参的构造函数，会导致复制非常量左值时，总会调用到万能引用构造函数（而非复制构造函数）。并且此条款也解释了，如果基类中声明了一个完美转发构造函数，则派生类以传统方式实现其复制和移动构造函数时，总会调用到该构造函数，尽管正确行为应该是调用到基类的复制和移动构造函数。</p>
<p>对于这样的情况，也就是接受了<strong>万能引用形参的重载函数比你想要的程度更加贪婪，而却又未贪婪到能够独当一面成为单版本分派函数的程度</strong>，<code>标签分派就不是</code>你想寻找的好伙伴了。这里应该是使用另一个方法，它可以让你把含有万能引用部分的函数模板被允许采用的条件砍掉一部分。</p>
<h3 id="3-解决标签分派无法搞定问题的方式-std-enable-if"><a href="#3-解决标签分派无法搞定问题的方式-std-enable-if" class="headerlink" title="3. 解决标签分派无法搞定问题的方式 std::enable_if"></a>3. 解决标签分派无法搞定问题的方式 std::enable_if</h3><p><code>std::enable_if</code>可以强制编译器表现出来的行为如同特定的模板不存在一般。这样的模板称为禁用的。默认的，所有模板都是启用的。可是，实施了<code>std::enable_if</code>的模板只会在满足了<code>std::enable_if</code>指定的条件的前提下才会启用。</p>
<p>看看我们的例子如何实现</p>
<p>需求：</p>
<blockquote>
<p>仅在传递给完美转发构造函数的类型不是Person的时候才启用它。<br>如果传递的类型是Person，我们就会想要禁用完美转发构造函数（即，让编译器忽略它）</p>
</blockquote>
<p>想实现这样的需求其实并不难，不过语法是在让人望而却步，尤其如果以前从没有见过就更是如此。<br><code>std::enable_if</code>的条件部分可以套用公式，以下是<code>Person</code>类的完美转发构造函数声明，仅展示了使得<code>std::enable_if</code>的得以运作的够用成功。之所以仅展示该构造函数的声明部分，是因为<code>std::enable_if</code>对实现毫无影响，该函数的实现和Item26中的一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">             <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;condition&gt;::type&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果想知道突出表示部分的代码到底怎么运作的，机理是什么，解释起来有点复杂，但是可以给你一个线索（去了解“SFINAE”）。这里，焦点集中放在控制该构造函数是否被弃用的条件表达式上。</p>
<h4 id="3-1-std-is-same"><a href="#3-1-std-is-same" class="headerlink" title="3.1 std::is_same"></a>3.1 std::is_same</h4><p>我们想要指定的条件是，T不是<code>Person</code>类型，即，仅当T是<code>Person</code>以外的类型时，才启用该模板构造函数。正好有个类型特征能够判断两个类型是否同一（std::is_same），这么一来，我们想要的条件好像是<code>!std::is_same&lt;Person, T&gt;::value</code>。然而这个表达式已经接近正确，原因是使用左值初始化万能引用时，T的类型推导结果总是左值引用。这就意味着，对于这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;   <span class="comment">//从左值触发进行初始化</span></span><br></pre></td></tr></table></figure>

<p>万能引用构造函数中的T的类型会被推到成<code>Person&amp;</code>，类型<code>Person</code>和<code>Person&amp;</code>不相同，即<code>std::is_same&lt;Person, Person&amp;&gt;::value</code>的值为false。</p>
<p>如果我们更加精细地加以烦死，我们说仅当T不是<code>Person</code>类型时才启用<code>Person</code>类中模板构造函数到底是什么意思的话，我们就会意识到，在审查T的时候，我们需要忽略以下因素：</p>
<ul>
<li><strong>它是否是个引用</strong>。为判定万能引用构造函数是否应该被启用，类型<code>Person</code>，<code>Person&amp;</code>，<code>Person&amp;&amp;</code>都应该与<code>Person</code>做相同处理。</li>
<li><strong>它是否带有const和volatile饰词</strong>。对目前关注的目的而言，<code>const Person</code>， <code>volatile Person</code>和<code>const volatile Person</code>都应该与<code>Person</code>做相同处理。</li>
</ul>
<h4 id="3-2-std-decay"><a href="#3-2-std-decay" class="headerlink" title="3.2 std::decay"></a>3.2 std::decay</h4><p>这意味着在判定T是否与Person相同之间，需要一种手段来移除T类型带有的所有引用，cv饰词。再一次的，标准库为我们准备好了工具，叫做<code>std::decay</code>。这个工具的作用是移除T的引用和cv饰词（注：这个词就是退化的意思）。也就是说<code>std::decay&lt;T&gt;::type</code>和T的类型相同，只是移除了引用和cv饰词。</p>
<p>有了这些工具，我们判定构造函数是否启动的条件就变成了如下这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!std::is_same&lt;Person, <span class="keyword">typename</span> std::decay&lt;T&gt;::type&gt;::value</span><br><span class="line"><span class="comment">//同样，如果你是顺着一条一条看下来的，你会明白，c++14里可以写的更简单</span></span><br><span class="line"><span class="comment">// in C++14</span></span><br><span class="line">!std::is_same&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;&gt;::value</span><br></pre></td></tr></table></figure>

<p>把上述条件表达式套到上面的公式中去，再把得到的代码结果重排一下格式，这样就能够更容易看清楚各个部分是如何就为的，最后得出Person类的完美转发构造函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">            !std::is_same&lt;Person, </span><br><span class="line">            <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::value</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果之前你没看过这样的代码，也不必自惭。如果你有可能使用其他技术来避免万能引用和重载的混合（<strong>你几乎总是可以选择其他技术</strong>），你就应该使用之。然而，一旦习惯了函数式语法和无处不在的尖括号，就会发现他们也没那么糟糕。而且，在历经千辛万苦后，它确确实实实现了你的期望行为。给定了上述构造函数，当我们用一个Person类型的对象（无论是左右值，cv饰词）来构造另一个Person类型的对象时，将永不会调用到接受万能引用的构造函数。成功了对吧？完工了！</p>
<p>等等，还差一点点。Item26的还有一个地方有点松动，我们得把这个地方扎牢了。<br>给定一继承Person的类，以传统的方式实现其复制和移动构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span>: <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) <span class="comment">//复制构造函数；</span></span><br><span class="line">    : <span class="built_in">Person</span>(rhs)                           <span class="comment">//调用的是</span></span><br><span class="line">    &#123;...&#125;                                   <span class="comment">//基类的完美转发构造函数！</span></span><br><span class="line">    <span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs)      <span class="comment">//移动构造函数</span></span><br><span class="line">    : <span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs))                <span class="comment">//调用的是</span></span><br><span class="line">    &#123;...&#125;                                   <span class="comment">//基类的完美转发构造函数！</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上和Item26展示的是同一段代码，连注释都未改一字，并且这注释仍然成立。<br>原因在于：<br>当复制或者移动一个<code>SpecialPerson</code>类型的对象时，我们会期望通过基类的复制或 移动构造函数来完成该对象基类部分的复制或移动，不过在这些函数中，我们传递给基类构造函数的是<code>SpecialPerson</code>类型的对象，因为<code>SpecialPerson</code>和<code>Person</code>类型不同（实施过std::decay仍然不同），基类的万能引用构造函数会启用，后者很乐意在精确匹配了<code>SpecialPerson</code>类型的实参后执行实例化。原因在于，这个精确匹配比<code>Person</code>累中的复制和移动构造函数所要求的从派生类到基类的强制转换才能把<code>SpecialPerson</code>类型的对象绑定到<code>Person</code>类型的形参来说，是更好的匹配。所以，我们现有的代码在复制和移动<code>SpecialPerson</code>类型的对象是，会使用<code>Person</code>类的完美转发构造函数来复制和移动它们的基类部分。</p>
<h3 id="4-继承参与后的解决方案"><a href="#4-继承参与后的解决方案" class="headerlink" title="4. 继承参与后的解决方案"></a>4. 继承参与后的解决方案</h3><p>因为派生类只是遵从正常规则在实现其复制和移动构造函数，所以问题的解决还须在基类中完成。更准确的说，就<strong>在那个决定了Person类的万能引用构造函数是否启用的条件</strong>中。</p>
<p>我们现在有了新的意识：</p>
<ul>
<li>我们想要的是为与<code>Person</code>或者<code>继承自Person</code>的类型都不同一的实参类型才启用模板构造。</li>
</ul>
<h4 id="4-1-std-is-base-of"><a href="#4-1-std-is-base-of" class="headerlink" title="4.1 std::is_base_of"></a>4.1 std::is_base_of</h4><p>这个工具就是用来解决上述问题的。若T2由T1派生而来，则<code>std::is_base_of&lt;T1, T2&gt;::value</code>是真。所有类型都可以认为是从它自身派生而来，所以<code>std::is_base_of&lt;T, T&gt;::value</code>也是真。</p>
<p>有了上述工具，解决问题就简单了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                        !std::is_base_of&lt;Person,</span><br><span class="line">                                <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                                        &gt;::value</span><br><span class="line">                                       &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到这里，才算终于完工了。当然，如果用的是C++14，可以写更简单点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>                                        <span class="comment">//C++14</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;                    <span class="comment">//这里代码更少</span></span><br><span class="line">                !std::is_base_of&lt;Person,</span><br><span class="line">                                std::<span class="type">decay_t</span>&lt;T&gt;     <span class="comment">//还有这里</span></span><br><span class="line">                                &gt;::value</span><br><span class="line">                &gt;                                   <span class="comment">//还有这里</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后一点修补</p>
<p>之前的需求中还有剃刀，对于实参是整型和非整型需要有区分。<br>我们整理一下我们需要做的：</p>
<ol>
<li>为Person类添加一个处理整型实参的</li>
<li>构造函数重载版本。</li>
<li>进一步限制模板构造函数，在接受整型实参时，禁用之。</li>
</ol>
<p>最终完成的代码如图所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>                                        </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;                    </span><br><span class="line">                !std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;::value     </span><br><span class="line">                &amp;&amp;</span><br><span class="line">                !std::is_intergral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">                &gt;</span><br><span class="line">                               </span><br><span class="line">            &gt;                                  </span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n): <span class="built_in">name</span>(std::forward&lt;T&gt;(n)) </span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(<span class="type">int</span> idx): <span class="built_in">name</span>(<span class="built_in">nameFromIdx</span>(idx)) </span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>终于，以上代码实现了所有需求的功能。实际上，这个方法不仅能够运作，还表现出一种独特的从容。这么说的理由：</p>
<ol>
<li>它利用了完美转发，达成了最高效率。</li>
<li>它又控制了万能引用和重载的组合，而非简单地禁用之。</li>
</ol>
<p>该技术可以实施于重载无法避免的场合（如构造函数）。</p>
<h3 id="5-完美转发的优缺点"><a href="#5-完美转发的优缺点" class="headerlink" title="5. 完美转发的优缺点"></a>5. 完美转发的优缺点</h3><p>本Item关注的头三种技术（<code>舍弃重载</code>，<code>传递const T&amp;类型的形参</code>和<code>传值</code>）都需要对带调用的函数形参指定类型，而后两种技术（<code>标签分派</code>和<code>对模板的启用资格加以限制</code>）则利用了完美转发，因此无需指定形参类型。这个基础决定（指定，还是不指定类型）不无后果。</p>
<p><strong>按理说，完美转发效率更高，因为它出于和形参声明时的类型严格保持一致的目的，会避免创建临时对象。</strong></p>
<p>在Person类的构造函数一例中，完美转发就允许把型如”Nancy”的字符串字面量转发给某个接受std::string的构造函数。而未使用完美转发的技术则一定得先从字符串字面量出发创造一个临时std::string对象，方能满足Person类的构造函数形参规格。</p>
<p>但完美转发也有不足：</p>
<ol>
<li><p>针对某些类型无法实施完美转发，尽管他们可以被传递到接受特定类型的函数，Item30探索了这些完美转发失败案例。</p>
</li>
<li><p>在客户传递了非法形参时，错误信息的可理解性不足。</p>
</li>
</ol>
<p>例如，假设在创建Person类型的对象时，传递的是个<code>char16_t</code>类型（C++11引进的16比特字符类型）而非char类型的字符组成的字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span> <span class="params">(u <span class="string">&quot;Konrad Zuse&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果是<code>使用前三种技术</code>，编译器会发现，可用的构造函数只能接受<code>int</code>或<code>std::string</code>。所以，他们会产生出多少算是<strong>直截了当的错误信息来解释</strong>：无法将<code>const char16_t[12]</code>强制转型到<code>int</code>或<code>std::string</code>。</p>
<p>而如果<code>使用的是基于完美转发的技术时</code>，情况大不一样。<code>const char16_t</code>类型的数组在绑定到构造函数的形参时，会一声不吭。接着，它又被转发到<code>Person</code>的<code>std::string</code>类型的成员变量构造函数中。唯有在那里，调用者的传递之物（一个<code>const char16_t</code>类型的数组）与所要求的形参（<code>std::string</code>的构造函数可接受的形参类型）之间的不匹配才会被发现。如此产生的结果错误信息，<strong>很可能，嗯，会一眼难忘</strong>。在我使用的某个编译器上，它有160多行。</p>
<p>为何呢？在本例中，万能引用值转发了一次（从<code>Person</code>类的构造函数到<code>std::string</code>类的构造函数）。但系统越是复杂，就越有可能某个万能引用要经由数层函数调用完成转发，才能到达决定实参类型是否可接受的的场所。<code>万能引用转发的次数越多，某些地方出错时给出的错误信息就越让人摸不着头脑</code>。许多程序猿都发现，<strong>即使性能是首要的关注因素</strong>，在接口中<strong>也不去使用万能引用</strong>形参，根本原因就在于这一问题。</p>
<p><strong>一个可能缓解上述问题的方法<code>static_assert*</code></strong></p>
<p>在<code>Person</code>例子中，我们了解到转发函数的万能引用形参应该用做<code>std::string</code>类型的对象初始化物，所以可以使用<code>static_assert</code>来验证其能够扮演这个角色。并且<code>std::is_constructible</code>这个类型特征能够在编译期间判定具备某个类型的对象是否从另一类型的对象触发完成构造，所以这个断言会写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>                                        </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;                    </span><br><span class="line">                !std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt;::value     </span><br><span class="line">                &amp;&amp;</span><br><span class="line">                !std::is_intergral&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">                &gt;</span><br><span class="line">                               </span><br><span class="line">            &gt;                                  </span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n): <span class="built_in">name</span>(std::forward&lt;T&gt;(n)) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">static_assert</span>(std::is_constructible&lt;std::string, T&gt;::value,</span><br><span class="line">      <span class="string">&quot;Parameter n can&#x27;t be used to construct a std::string&quot;</span>);  </span><br><span class="line">    ...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span>: name(nameFromIdx(idx)) </span></span><br><span class="line"><span class="function">    &#123;</span>...&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样写会在客户代码尝试从一个无法构造出<code>std::string</code>类型的对象的类型触发来创建一个<code>Person</code>类型的对象时，产生出该指定错误的信息。不幸的是，在本例中，<code>static_assert</code>位于构造函数体内，而转发代码属于成员初始化列表的一部分，位于它之前。所以产生自&#96;static_assert&#96;&#96;&#96;的提示信息，仅仅会在通常错误信息（那160多行）发生完后才姗姗来迟。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字、传递const T&amp;类型的形参、传值和标签分派。</td>
</tr>
<tr>
<td>2. 经由<code>std::enable_if</code>对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。</td>
</tr>
<tr>
<td>3. 万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。</td>
</tr>
</tbody></table>
<h2 id="条款28-理解引用折叠"><a href="#条款28-理解引用折叠" class="headerlink" title="条款28 理解引用折叠"></a>条款28 理解引用折叠</h2><p>Item 23曾经提到，实参在传递给函数模板时，推导出来的模板形参会将实参是左值还是右值的信息编码到结果类型中。但此条款未曾提到，这个编码操作只有在实参被用以初始化的形参为万能引用时，才会发生。不过，有一个充分的理由来解释为什么当时不提及这些：万能引用是在Item24中才介绍。把万能引用和左右值编码信息的论述综合起来，意思就是，按照下面这个模板为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>模板形参T的推导结果类型中，会把传递给param的实参是左值还是右值的信息给编码进去。</p>
<p>编码机制是直截了当的：</p>
<blockquote>
<p>如果传递的实参是个左值，T的推导结果就是个左值引用类型。<br>如果传递的实参是个右值，T的推导结果就是个非引用类型。</p>
</blockquote>
<p><em>注意，这里的非对称性：左值的编码结果为左值引用类型，但右值的编码结果却是非引用类型</em>。</p>
<p>所以有如下的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>;         <span class="comment">//返回右值的函数</span></span><br><span class="line">Widget w;                       <span class="comment">//变量（左值）</span></span><br><span class="line"><span class="built_in">func</span>(w);                        <span class="comment">//调用func并传入左值，T的推导结果类型为Widget &amp;</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">widgetFactory</span>())           <span class="comment">//调用func并传入右值，T的推导结果类型为Widget </span></span><br></pre></td></tr></table></figure>

<p>两个对<code>func</code>的调用，传递的实参类型都为<code>Widget</code>。不同之处仅在于，一个是左值而另一个是右值，也正是这两个不同之处导致了针对模板形参T得到了不同的类型推导结果。这个机制，正如我们将很快看到的，这就是决定了万能引用是变成左值引用还是右值引用的机制，也是<code>std::foward</code>得以运作的机制。</p>
<h3 id="1-什么是引用折叠"><a href="#1-什么是引用折叠" class="headerlink" title="1. 什么是引用折叠"></a>1. 什么是引用折叠</h3><p>在我们以更深入的视角来观察<code>std::foward</code>和万能引用之前，我们必须了解一个事实，在C++中，<strong>“引用的引用”是非法的</strong>。如果你敢尝试申明一个，则编译器会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span>&amp; &amp; rx = x;     <span class="comment">//错误！不可以声明“引用的引用”！</span></span><br></pre></td></tr></table></figure>

<p>但如果仔细琢磨一下， 当左值被传递给接受万能引用的函数模板时，会发生下面的状况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;       <span class="comment">//同前</span></span><br><span class="line"><span class="built_in">func</span>(w);                    <span class="comment">//调用func并传入左值：T的推导结果类型为Widget &amp;</span></span><br></pre></td></tr></table></figure>

<p>如果把T的推导结果类型（即Widget&amp;）代码实例化模板，不就得到下面的结果了吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; &amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>引用的引用！然而编译器却不报错。Item24告诉过我们，由于万能引用param是用左值初始化的，其推导结果类型理应是个左值引用，但编译器是如何取用了T的推导结果类型的，并代入模板，从而使它拥有了下面这个终极版函数签名的呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>答案就是引用折叠。是的，你是被禁止声明引用的引用，但编译器却可以在<strong>特殊的语境</strong>中产生引用的引用。<strong>模板实例化就是这样特殊的语境之一</strong>。当编译器生成引用的引用时，引用折叠机制变支配了接下来发生的事情。</p>
<p>有两种引用（左值和右值），所以就有四种可能的引用——引用组合（左值-左值，左值-右值，右值-左值，右值-右值）。如果引用的引用出现在允许的语境（例如，在模板实例化过程中），该双重引用会折叠成单个引用，规则如下：</p>
<blockquote>
<p>如果任一引用为左值 引用，则结果为左值引用。否则（即两个皆为右值引用），结果为右值引用。</p>
</blockquote>
<p>在上述例子中，将推导结果类型<code>Widget&amp;</code>代入函数模板<code>func</code>后，产生了一个指涉到左值引用的右值引用。然后，根据引用折叠规则，结果是个左值引用。</p>
<h3 id="2-std-forward-详解"><a href="#2-std-forward-详解" class="headerlink" title="2. std::forward 详解"></a>2. std::forward 详解</h3><p>引用折叠是使<code>std::forward</code>得以运作的关键。如同Item 25所解释的那样，<code>std::forward</code>会针对万能引用实施，这么一来，就会出现如下的常见用例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...                                 <span class="comment">//完成一些操作</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">someFunc</span>(std::forward&lt;T&gt;(fParam));  <span class="comment">//将fParam转发至someFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于fParam是个万能引用，我们就知道，传递给f的实参（即用以初始化fParam的表达式）是左值还是右值的信息会被编码到类型形参T中。<code>std::forward</code>的任务是，<strong>当且仅当编码T中的信息表明传递给实参的是个右值，即T的推导结果类型是个非引用类型时，对fParam（左值）实施到右值的强制类型转换。</strong></p>
<p>以下，是<code>std::forward</code>的一个能够完成任务的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenaem T&gt;                                <span class="comment">//在namespace std中</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> </span></span></span><br><span class="line"><span class="params"><span class="function">                remove_refernece&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现和标准并不完全符合（省去了若干接口细节），不过，那些有差异的部分对于理解<code>std::forward</code>的行为并无干系。</p>
<h4 id="2-1-std-forward-传入左值时的推导"><a href="#2-1-std-forward-传入左值时的推导" class="headerlink" title="2.1 std::forward 传入左值时的推导"></a>2.1 std::forward 传入左值时的推导</h4><p>假设传递给函数<code>f</code>的实参的类型是个左值<code>Widget</code>，则T会被推导为<code>Widget&amp;</code>类型，然后对std::forward的调用就会实例化为<code>std::forward&lt;Widget&amp;&gt;</code>。而将<code>Widget&amp;</code>插入<code>std::forward</code>的实现就会产生如下效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> </span></span></span><br><span class="line"><span class="params"><span class="function">                    remove_reference&lt;Widget&amp;&gt;::type &amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);&#125;</span><br></pre></td></tr></table></figure>

<p>由于类型特征<code>remove_renference&lt;Widget&amp;&gt;::type</code>的产生结果是Widget类型，详见Item 9，所以<code>std::forward</code>又变成了下面的样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget &amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用折叠效果同样在返回值和强制类型转换的语境下，得到了实施，导致实际调用结果是这样的终极版本<code>std::forward</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span>                  <span class="comment">//在namespace std中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，当左值实参被传递给函数模板f时，<code>std::forward</code>实例化结果是：接受一个左值引用，并返回一个左值引用。而<code>std::forward</code>内部的强制类型转换未做任何事，因为param的类型已经是<code>Widget&amp;</code>了，所以再把它强制转换到<code>Widget&amp;</code>类型不会产生什么效果。</p>
<p>综上，被传递给<code>std::forward</code>的左值实参会返回一个左值引用。根据定义，左值引用时左值，所以传递左值给<code>std::forward</code>会导致返回一个左值，符合认知。</p>
<h4 id="2-2-std-forward-传入右值时的推导"><a href="#2-2-std-forward-传入右值时的推导" class="headerlink" title="2.2 std::forward 传入右值时的推导"></a>2.2 std::forward 传入右值时的推导</h4><p>假设传递给f的实参是右值的<code>Widget</code>类型。在此情况下，f的形参类型T的推导结果是个光秃秃的Widget。因此，f内部的<code>std::forward</code>就成了<code>std::forward&lt;Widget&gt;</code>，在<code>std::forward</code>的视线中，在T之处用Widget代入，就得出了下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> </span></span></span><br><span class="line"><span class="params"><span class="function">                    remove_reference&lt;Widget&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对非引用Widget类型实施<code>std::remove_renference</code>会产生和起始类型相同的结果（Widget），所以<code>std::forward</code>又成了下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有发生引用的引用，所以也就没有发生引用折叠，所以这也就已经是本次<code>std::forward</code>调用的最终实例化版本了。</p>
<p>由函数返回的右值引用是定义为右值的，所以在此情况下，<code>std::forward</code>会把f的形参fParam（左值）转换为右值。最终的结果是，传递给函数f的右值实参会作为右值转发到<code>someFunc</code>函数，这也精确地符合认知。</p>
<p>在C++14中，有了<code>std::remove_renference_t</code>，从而<code>std::forward</code>的实现的以变得更加简明扼要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_renference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-引用折叠语境的四种情况"><a href="#3-引用折叠语境的四种情况" class="headerlink" title="3. 引用折叠语境的四种情况"></a>3. 引用折叠语境的四种情况</h3><p>引用折叠会出现的语境有四种：</p>
<h4 id="3-1-第一种，最常见的一种就是模板实例化。"><a href="#3-1-第一种，最常见的一种就是模板实例化。" class="headerlink" title="3.1 第一种，最常见的一种就是模板实例化。"></a>3.1 第一种，最常见的一种就是模板实例化。</h4><h4 id="3-2-第二种，是auto变量的类型生成。"><a href="#3-2-第二种，是auto变量的类型生成。" class="headerlink" title="3.2 第二种，是auto变量的类型生成。"></a>3.2 第二种，是auto变量的类型生成。</h4><p>技术细节本质上和模板实例化一模一样，因为auto变量的类型推导和模板的类型推导在本质上就是一模一样的Item2。重新反思下本条款介绍前面出现过的一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>;             <span class="comment">//返回右值</span></span><br><span class="line"></span><br><span class="line">Widget w;                           <span class="comment">//变量（左值）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(w);                        <span class="comment">//以左值调用函数，T的推导结果类型为Widget &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">widgetFactory</span>())           <span class="comment">//以右值调用函数，T的推导结果类型为Widget </span></span><br></pre></td></tr></table></figure>

<p>这一切都能以auto形式模仿。下面这个声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure>

<p>初始化w1的是个左值，因此auto的类型推导结果为<code>Widget &amp;</code>。在w1声明中，以<code>Widget &amp;</code>代入auto，就产生了以下这段设计引用的引用的代码，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; &amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure>

<p>引用折叠之后，又变成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; w1 = w;</span><br></pre></td></tr></table></figure>

<p>这就是结果：w1乃是左值引用。</p>
<p>再看一个例子，下述声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;&amp; w2 = <span class="built_in">widgetFactory</span>();</span><br></pre></td></tr></table></figure>

<p>以右值初始化w2，auto的类型推导结果为非引用类型<code>Widget</code>。将<code>Widget</code>代入auto就得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;&amp; w2 = <span class="built_in">widgetFactory</span>();</span><br></pre></td></tr></table></figure>

<p>这里并无引用的引用，所以到此结束：w2乃是右值引用。</p>
<p>话说到这里，我们才真正地理解了Item24中介绍的万能引用。<strong>万能引用并非一种新的引用类型</strong>，其实它就是满足了下面两个条件的语境中的右值引用：</p>
<ul>
<li><strong>类型推导的过程会区别左值和右值</strong>。T类型的左值推导结果为T&amp;，而T类型的右值则推导结果为T。</li>
<li><strong>会发生引用折叠</strong>。</li>
</ul>
<p><em>万能引用的概念是有用的</em>，有了这个概念以后，就避免了需要识别出存在引用折叠的语境，根据左值和右值的不同脑补推导过程，然后在脑补针对推导的结果类型代入引用折叠发生的语境后应用引用折叠规则。</p>
<h4 id="3-3-第三种语境是生成和使用typedef和别名声明-Item9-。"><a href="#3-3-第三种语境是生成和使用typedef和别名声明-Item9-。" class="headerlink" title="3.3 第三种语境是生成和使用typedef和别名声明(Item9)。"></a>3.3 第三种语境是生成和使用typedef和别名声明(Item9)。</h4><p>如果在typedef的创建或者评估求值的过程中出现了引用的引用，引用折叠就会起到作用。</p>
<p>例如，假设我们有个类模板Widget，内嵌一个右值引用类型的typedef。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T &amp;&amp; RvalueRefToT;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再假设我们以左值引用类型来实例化该Widget：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&lt;<span class="type">int</span>&amp;&gt; w;</span><br></pre></td></tr></table></figure>

<p>在<code>Widget</code>中以<code>int&amp;</code>代入T的位置，则得到如下的typedef：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; &amp;&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure>

<p>引用折叠又将上述语句简化得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure>

<p>这个结果显然表明，我们为typedef选择的名字也许有些名不副实：当以左值引用类型实例化Widget时，<code>RvalueRefToT</code>其实成了个左值引用的typedef。</p>
<h4 id="3-4-第四种会发生引用折叠的语境decltype的运用中。"><a href="#3-4-第四种会发生引用折叠的语境decltype的运用中。" class="headerlink" title="3.4 第四种会发生引用折叠的语境decltype的运用中。"></a>3.4 第四种会发生引用折叠的语境decltype的运用中。</h4><p>如果分析一个涉及<code>decltype</code>的类型过程中出现了引用的引用，则引用折叠亦会介入。(Item3)</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 引用折叠会在四种语境中发生：模板实例化，auto类型生成，创建和运用typedef和别名声明，以及decltype。</td>
</tr>
<tr>
<td>2. 当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用。</td>
</tr>
<tr>
<td>3. 万能引用就是在类型的过程中会区别左值和右值，以及会发生引用折叠的语境中的右值引用。</td>
</tr>
</tbody></table>
<h2 id="条款29-假定移动操作不存在，成本高，未使用"><a href="#条款29-假定移动操作不存在，成本高，未使用" class="headerlink" title="条款29 假定移动操作不存在，成本高，未使用"></a>条款29 假定移动操作不存在，成本高，未使用</h2><h3 id="1-传说中高效的移动操作"><a href="#1-传说中高效的移动操作" class="headerlink" title="1. 传说中高效的移动操作"></a>1. 传说中高效的移动操作</h3><p>移动语义在C++11的所有语言特性中，占据首要地位。</p>
<blockquote>
<p>移动容器现在和复制指针一样成本低廉了！</p>
</blockquote>
<p>你很有可能听说过，类似的说法还有：</p>
<blockquote>
<p>复制临时对象现在已经如此高效，如果可以在撰写代码中避免它，就无异于犯了过早优化的禁忌！</p>
</blockquote>
<p>这些情绪化的言辞不难理解。移动语义确实是个重要的语言特性。语言不只是允许编译器使用成本相对低廉的移动操作来代替昂贵的复制操作，实际上语言会要求编译器这样做（<strong>只要满足适当条件就必须这样做</strong>）。调出你的C++98版本代码，然后只需要一字不改地使用符合C++11标准的编译器和标准库重新编译一遍，你的软件便更快了。</p>
<p>移动语义的确有此功能，所以这个语言特性一传十，十传百，渐渐变成了传奇。但传奇，一般也都是夸大其词的结果。此条也是想让你对这个语言特性的期望得到纠正。</p>
<h3 id="2-实际上的移动操作"><a href="#2-实际上的移动操作" class="headerlink" title="2. 实际上的移动操作"></a>2. 实际上的移动操作</h3><p>让我们从为何很多类型不能支持移动语义的观察开始。整个C++98标准库都已为C++11彻底修改过，目的是为那些类型移动的可以实现成比复制更快的类型增添移动操作，而且库组件的实现也已完成修订以充分利用这些移动操作，不过问题在于，客户层面的代码并不一定完成修订从而充分利用C++11的良好特性。<strong>若你的应用中的（或者库中）类型没有为C++11做过修改，那么仅仅在编译器中有着对移动操作的支持也并不会给你带了什么特别显著的好处。</strong></p>
<h3 id="3-有些情况移动操作根本没办法生效"><a href="#3-有些情况移动操作根本没办法生效" class="headerlink" title="3. 有些情况移动操作根本没办法生效"></a>3. 有些情况移动操作根本没办法生效</h3><p>虽然，C++愿意为这些缺少移动操作的类生成移动操作，但这仅适用于那些未声明复制操作、移动操作以及析构函数的类（详见Item17）。类型若是有数据成员或者基类禁用了移动（例如，通过将移动操作删除的方式（详见Item 11），也将导致编译器生成的移动操作被抑制掉。如果类型并不提供对移动的显示支持，也不符合编译器生成移动操作的条件，当然也就没有理由期望它在C++11下比在C++98下有任何性能提升了。</p>
<p>即使对于那些显示支持移动操作的类型，也可能不会像大家希望的那样带来那么大的好处。举个栗子，在标准的C++11库中，所有的容器都支持移动操作，但是如果因此就断言所有的容器移动都是成本低廉的，那就贻笑大方了。<strong>对于有些容器而言，根本没有什么成本低廉的途径来移动其内容。</strong>而对于另一些容器而言，他们虽然有着确实成本低廉的移动操作，但却又有一些附加条件造成其元素不能满足。</p>
<h3 id="3-1-举个例子-std-array"><a href="#3-1-举个例子-std-array" class="headerlink" title="3.1 举个例子 std::array"></a>3.1 举个例子 std::array</h3><p>考虑一下<code>std::array</code>这个C++11中引入的新容器类型，它实质上就是带有STL接口的内建数组。这一点和其他标准库容器存在根本差异，<strong>因为其他标准容器都是将其内容存放在堆上的</strong>，从而在概念上，只需（以数据成员的方式）持有一个指涉到存放容器内容的堆内存指针（实际情况当然比这个更复杂些，但出于这里的分析目的，这些差异并不重要）。由于该指针的存在，把整个容器的内容在常数时间内加以移动就有可能了：仅仅把那个指涉到容器内容的指针从源容器复制到目标容器，然后把源容器包含的指针置空即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw1;</span><br><span class="line"><span class="comment">// 将数据放入vw1</span></span><br><span class="line"><span class="comment">//  ..</span></span><br><span class="line"><span class="comment">// 移动vw1入vw2</span></span><br><span class="line"><span class="comment">// 完成执行仅需常数时间</span></span><br><span class="line"><span class="comment">// 仅仅是包含在vw1和vw2中的指针被修改了</span></span><br><span class="line"><span class="keyword">auto</span> vw2 = std::<span class="built_in">move</span>(vw1);</span><br></pre></td></tr></table></figure>

<p>而<code>std::array</code>类型的对象则缺少这样一个指针，因为其内容数据是直接存储在对象内的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;Widget, 10000&gt; aw1;</span><br><span class="line"><span class="comment">// 将数据放入aw1</span></span><br><span class="line"><span class="comment">//  ..</span></span><br><span class="line"><span class="comment">// 移动aw1入aw2</span></span><br><span class="line"><span class="comment">// 完成执行需要线性时间</span></span><br><span class="line"><span class="comment">// 需要把aw1中的所有元素移动入aw2</span></span><br><span class="line"><span class="keyword">auto</span> aw2 = std::<span class="built_in">move</span>(aw1);</span><br></pre></td></tr></table></figure>

<p>请注意，aw1中的元素是被移入aw2中的。假定<code>Widget</code>类型的移动比复制快，则移动一个元素类型为<code>Widget</code>的<code>std::array</code>自然也会比复制一个同样的<code>std::array</code>更快。毫无疑问，<code>std::array</code>当然提供移动支持。然而无论是移动还是复制<code>std::array</code>类型的对象都还是需要<strong>线性时间的计算复杂度</strong>，因为容器中的每个元素都必须逐一复制或移动。这可比人们有时会听说的<strong>移动容器现在和赋值一堆指针一样成本低廉了</strong>这类说法，要超出太多了。</p>
<h4 id="3-2-再来看看-std-string"><a href="#3-2-再来看看-std-string" class="headerlink" title="3.2 再来看看 std::string"></a>3.2 再来看看 <code>std::string</code></h4><p>作为对比，<code>std::string</code>类型提供的是<strong>常数时间的移动</strong>和<strong>线性时间的复制</strong>。这听起来，<strong>好像是说移动比复制更快，但可能并非如此</strong>。许多<code>string</code>的实现都采用了小型字符串优化<code>small string optimization， SSO</code>。采用了SSO以后，“小型”字符串（例如，容量不超过15个字符的字符串）会存储在的std::string对象内的某个缓冲区内，而不去使用堆上分配的存储。在使用了基于SSO的实现的前提下，对小型字符串实施移动并不比复制更快，因为通常在移动的性能优于复制背后“仅复制一个指针”的把戏会失灵。</p>
<p><strong>有着发明SSO的动机，就充分表明段字符串是许多应用程序的标配</strong>。使用一个内部缓冲区来存储这样的字符串，就解决了他们动态分配内存的需要，这种操作可以提升效率。而这样做的后果是，移动不并不复制更快，换句话说，复制并不比移动更慢。</p>
<h4 id="3-3-再看看即便支持快速移动操作的类型"><a href="#3-3-再看看即便支持快速移动操作的类型" class="headerlink" title="3.3 再看看即便支持快速移动操作的类型"></a>3.3 再看看即便支持快速移动操作的类型</h4><p>即使是那些支持快速移动操作的类型，一些看似万无一失的移动场景还是以复制副本告终。Item 14解释过，标准库中一些容器操作提供了强异常安全保证，并且为了确保依赖于这样的保证的那些C++98的遗留代码在升级到C++11时不会破坏这样的保证，底层的复制操作只有在已知移动操作不会抛出异常的前提下，才会使用移动操作将其替换。这么做导致的一个后果是:</p>
<blockquote>
<p><strong>即使某个类型的移动操作比对应的复制操作更搞笑，甚至在代码的某个特定位置，移动操作一般肯定不会有问题（例如，源对象是个右值的情况下），编译器仍会强制去调用一个复制操作，只要对应的移动操作并未加上<code>noexcept</code>声明</strong>。</p>
</blockquote>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>在这几个场景中，C++11的移动语义不会给你带来什么好处：</p>
<ul>
<li>没有移动操作：待移动的对象未能提供移动操作。因此，移动请求就变成了复制请求。</li>
<li>移动未能更快：待移动的对象虽然有移动操作，但并不比复制操作更快。</li>
<li>移动不可用：移动本可以发生的语境下，要求移动操作不可发射异常。但该操作未加上<code>noexcept</code>声明。</li>
</ul>
<p>值得一提的是，还有另一种场景是的移动语义无法提供效率增益：</p>
<p>但本条款的标题是，假定移动操作不存在，成本高，未使用。这比较典型地合适于通常代码的情形，<strong>例如，写模板的时候，因为你还不知道将要与哪些类型配合</strong>。在这种情况下，你必须像在使用C++98一样保守地去复制对象，正如移动语义尚不存在那样。同样也符合“不稳定”代码的情形，即代码中所涉及类型的特征会比较频繁的加以修改。</p>
<p>然而，<strong>通常你已知代码中会使用的类型，也可以肯定他们的特性不会改变（例如。他们是否支持成本低廉的移动操作）。如果是这样的情况，你就不需要前面那些假定</strong>。你可以直接查阅所使用的类型对移动的支持细节。如果涉及的类型能够提供成本低廉的移动操作，并且是在这些移动操作会被调用的语境中使用对象，则可以放心大胆地依靠移动语义来将复制操作替换成相对不那么昂贵的对应移动操作。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 假定移动操作不存在，成本高，未使用。</td>
</tr>
<tr>
<td>2. 对于那些类型或对于移动语义的支持情况已知的代码，则无需作已上假定。</td>
</tr>
</tbody></table>
<h2 id="条款30-熟悉完美转发的失败情形"><a href="#条款30-熟悉完美转发的失败情形" class="headerlink" title="条款30 熟悉完美转发的失败情形"></a>条款30 熟悉完美转发的失败情形</h2><p>在C++11的中最引人瞩目的语言特性之一，就是完美转发。完美转发，可是完美的哟！不过，解开这完美的外表，你才会发现理想和现实有差距。C++11的完美转发相当不错，但如果一定要说达到了完美，那还是有一定差距的。本节主要介绍这些差距的地方。</p>
<h3 id="1-转发介绍"><a href="#1-转发介绍" class="headerlink" title="1. 转发介绍"></a>1. 转发介绍</h3><p><strong>转发的背景</strong></p>
<p>先考虑一下完美转发的确切含义。“转发”的含义不过是一个函数把自己的形参传递（转发）给另一个函数而已。其目的是为了让第二个函数（转发目的函数）接受第一个函数（转发发起函数）所接受的同一对象。<strong>这就排除了按值传递形参，因为他们只是原始调用者锁传递之物的副本</strong>。我们想要转发目的函数能够处理原始传入对象。<strong>指针形参也只能出局，因为我们不想强迫调用者传递指针</strong>。所以，一般意义上的转发时，都是在处理形参为引用类型的情形。</p>
<p><strong>转发想要达到的效果</strong></p>
<p>完美转发的含义是，我们不仅需要转发对象，还要转发其特征：<strong>类型</strong>，<strong>是左值还是右值</strong>，以及<strong>是否带有const或者volatile修饰</strong>等。结合前面的观察分析，即我们一般是会和引用形参打交道，这就是说，我们会运用万能引用Item 24，因为只有万能引用形参才会将传入的实参是左值还是右值这一信息加以编码。</p>
<p>假设某个函数<code>f</code>，然后我们打算写一个函数（其实是函数模板）将<code>f</code>作为转发目标。欲达此目的，我们需要核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span>             <span class="comment">//接受任意实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T&gt;(param));  <span class="comment">//转发该实参到f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转发函数，天然就应该是泛型的。<code>fwd</code>模板就是个例子。它接受任意类型的实参，然后无论接受了什么都要加以转发。对于这样的泛型，一种符合逻辑的拓展就是，使得转发函数不只是模板，而且是可变长形参模板，从而能够接受任意数量的实参，可变长形参形式的<code>fwd</code>长成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... param)</span>             <span class="comment">//接受任意实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;Ts&gt;(param)...);  <span class="comment">//转发所有实参到f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种形式你可以在很多地方见到，包括标准容器的置入函数（参见Item 42），以及智能指针的工厂函数<code>std::make_shared</code>和<code>std::make_unique</code>，参见Item 21。</p>
<h3 id="2-什么叫完美转发失败"><a href="#2-什么叫完美转发失败" class="headerlink" title="2. 什么叫完美转发失败"></a>2. 什么叫完美转发失败</h3><p>给定目标函数<code>f</code>和转发函数<code>fwd</code>，当以某特定实参调用<code>f</code>会执行操作，而用同一实参调用fwd会执行不同的操作，则称完美转发失败：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(expression);      <span class="comment">//如果本语句执行了某操作</span></span><br><span class="line"><span class="built_in">fwd</span>(expression);    <span class="comment">//而本语句执行了不同的操作，</span></span><br><span class="line">                    <span class="comment">//则称fwd完美转发express到f失败</span></span><br></pre></td></tr></table></figure>

<h3 id="3-不能实施完美转发的场景"><a href="#3-不能实施完美转发的场景" class="headerlink" title="3. 不能实施完美转发的场景"></a>3. 不能实施完美转发的场景</h3><p>有若干种实参会导致该失败，更重要的在于知道这几种实参是什么，以及如何绕过它们。现在就来理解一下不能实施完美转发的实参。</p>
<h4 id="3-1-大括号初始化"><a href="#3-1-大括号初始化" class="headerlink" title="3.1 大括号初始化"></a>3.1 大括号初始化</h4><p>假设<code>f</code>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在此情况下，以大括号初始化物调用<code>f</code>可以通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);       <span class="comment">//没问题，</span></span><br><span class="line">                    <span class="comment">//“&#123;1, 2, 3&#125;”会隐式转换为std::vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>但如果把同一大括号初始化物传递给fwd则无法通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);     <span class="comment">//错误！无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>原因在于，大括号初始化的运用，就是一种完美转发失败的情形。</p>
<p>凡是归类于此的失败，原因都一模一样。在对于<code>f</code>的直接调用中（如f({1, 2, 3})），编译器先接收了调用端的实参类型，又接收了<code>f</code>所声明的形参类型。编译器会比较这两个类型来确定他们是否兼容，然后，如有必要，会实施隐式类型转换来使得调用的以成功。在上面的例子中，编译器从<code>&#123;1,2,3&#125;</code>触发生成一个临时的<code>std::vector&lt;int&gt;</code>类型对象，从而<code>f</code>的形参就有了一个<code>std::vector&lt;int&gt;</code>对象得以绑定。</p>
<p>但经由转发函数模板<code>fwd</code>来对<code>f</code>实施间接调用时，编译器就不再会比较<code>fwd</code>的调用处传入的实参和<code>f</code>中所声明的形参了。取而代之的是，<em>编译器会采用推**导的手法来取得传递给<code>fwd</code>实参的类型结果</em>，然而他会比较推导类型结果和f声明的形参类型。<strong>完美转发会在下面两个条件中的任意一个成立时失败</strong>：</p>
<ul>
<li><strong>编译器无法为一个或多个<code>fwd</code>的形参推导出类型结果</strong>。在此情况下，代码无法编译通过。</li>
<li><strong>编译器为一个或多个<code>fwd</code>的形参推导出了“错误的”类型结果</strong>。这里所谓错误的，既可以指<code>fwd</code>根据类型推导结果的实例化无法通过编译，也可以指以<code>fwd</code>推导而得的类型调用<code>f</code>与直接以传递给<code>fwd</code>的实参调用<code>f</code>行为不一致。而这种分裂行为的源泉之一，可能是在于<code>f</code>乃是个重载函数的名字，然后依据“不正确”的推导类型，<code>fwd</code>里调用到的<code>f</code>重载版本，就与直接调用<code>f</code>的版本有差别。</li>
</ul>
<p>在上述“<code>fwd(&#123;1,2,3&#125;)</code>”这句调用中，问题在于向未声明为<code>std::initalizer_list</code>类型的函数模板形参传递了大括号初始化物，因为这样的语境按规定，用标准委员会的行话说，叫做“非推导语境”。通俗的说，这个词的意思是，由于fwd的形参未声明为<code>std::initalizer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>&#123;1, 2, 3&#125;</code>出发来推类型。而既然从<code>fwd</code>的形参出发进行推导是被阻止的行为，所以编译器拒绝这个调用也是合情合理的。</p>
<p><strong>大括号初始物的绕行方法</strong></p>
<p>有意思的事情来了，Item 2曾经说过，<code>auto</code>变量在以大括号初始化物完成初始化时，类型推导可以成功。这样的变量会被视为<code>std::initalizer_list</code>类型对象，这么一来，如果转发函数的形参的推导类型结果应为<code>std::initalizer_list</code>的话，就有一个简而易行的绕行手法——先用<code>auto</code>声明一个局部变量，然后将该局部变量传递给转发函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;        <span class="comment">//il的类型推导结果为</span></span><br><span class="line">                            <span class="comment">//std::initalizer_list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">fwd</span>(il);                    <span class="comment">//没问题，将il完美转发给f</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-0-和-NULL用做空指针"><a href="#3-2-0-和-NULL用做空指针" class="headerlink" title="3.2 0 和 NULL用做空指针"></a>3.2 0 和 NULL用做空指针</h4><p>Item 8曾经说明过，若尝试把0和NULL以空指针之名传递给模板，类型推导就会发生行为扭曲，推导结果会是整型（一般情况下会是int）而非所传递实参的指针类型。结论就是，0和NULL都不能用做空指针以进行完美转发。不过，修正方案也破简单：传递<code>nullptr</code>，而非0或者NULL。</p>
<h4 id="3-3-仅有声明的整型-static-const成员变量"><a href="#3-3-仅有声明的整型-static-const成员变量" class="headerlink" title="3.3 仅有声明的整型 static const成员变量"></a>3.3 仅有声明的整型 static const成员变量</h4><p>有这么一个普适的规定：不需要给出类中的整型<code>static const</code>成员变量的定义，仅需声明之。因为编译器会根据这些成员的值实施常数传播，从而就不必再为它们保留内存。举个例子，考虑下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>;      <span class="comment">//给出了MinVals的声明</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line">......                                          <span class="comment">//未给出MinVals的声明</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; widgetData; </span><br><span class="line">widgetData.<span class="built_in">reserve</span>(Widget::MinVals);            <span class="comment">//此处用到了MinVals</span></span><br></pre></td></tr></table></figure>

<p>这里，尽管<code>Widget::MinVals</code>(以下简称<code>MinVals</code>)并无定义，我们还是利用了<code>MinVals</code>来指定<code>widgetData</code>的初始容量。编译器绕过了<code>MinVals</code>缺少定义的事实(编译器的行为是这样规定的)，手法是把值28塞到所有提及<code>MinVals</code>之处。未为<code>MinVals</code>的值保存存储这一事实并不会带来问题。如果产生了对<code>MinVals</code>实施取址的需求（例如，有人创建了一个指涉到<code>MinVals</code>的指针），<code>MinVals</code>就得要求存储地址，然后上面这段代码虽然仍能够通过编译，但是如果不为<code>MinVals</code>提供定义，它在链接期就会遭遇失败。</p>
<p>记住了上述预备知识，然后想象<code>f</code>(<code>fwd</code>转发实参的目的函数)声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals);             <span class="comment">//没问题，当&quot;f(28)&quot;处理</span></span><br></pre></td></tr></table></figure>

<p>哎呀，如果想经由<code>fwd</code>来调用<code>f</code>，便会碰壁了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(Widget::MinVals);           <span class="comment">//错误！应该无法链接</span></span><br></pre></td></tr></table></figure>

<p>上面的代码能够通过编译，却不能完成链接。如果这能提醒你想起在对<code>MinVals</code>实施取址所发生过的失败，这就对了，因为其底层原理相同。</p>
<p>尽管源代码看上去并没有对<code>MinVals</code>实施取址，但注意到<code>fwd</code>的形参是个万能引用，而引用这个东西，在编译器生成的机器码中，通常是当指针处理的。程序的二进制代码（从硬件角度），指针和引用在本质上是同一事物。在此层次，有一句老话说得对：引用不过是会提领的指针罢了。既然如此，<code>MinVals</code>按引用传递和按指针传递结果也就没有什么区别了。基于同样的理由，也得准备某块内存以供指针去指涉。按引用传递整型<code>static const</code>成员变量通常要求其加以定义，而这个需求就会导致代码完美转发失败，未使用完美转发的代码能成功。</p>
<p><strong>一点额外需要注意的</strong></p>
<p>你可能已经注意到，在先前的讨论中，我在有些地方闪烁其词，<strong>代码“应该无法”链接</strong>，<strong>引用“通常”是当指针处理的</strong>，<strong>按引用传递整型static const成员变量通常要求其加以定义</strong>。仿佛我知道一些事情。</p>
<p>的确是这样。依据标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义，但并不是所有实现都服从了这个需求。因此，你很可能发现有时是能够完美转发未加定义的<code>static const</code>成员变量的，这取决于具体的编译器和链接器。如果真是这样，恭喜，不过没有理由期望这样的代码能够一直。若想添加可移植性，只需<code>static const</code>成员变量提供定义即可。对于<code>MinVals</code>，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::<span class="type">size_t</span> Widget::MinVals;      <span class="comment">//在Widget的.cpp文件中</span></span><br></pre></td></tr></table></figure>

<p>注意，定义语句没有重复指定初始化物（对于本例中的MinVals，就是值28），不过，该细节不用死记硬背。如果忘记了这一点，两处都提供了初始化物，编译器一定会发出警告的。</p>
<h4 id="3-4-重载的函数名称和模板名称"><a href="#3-4-重载的函数名称和模板名称" class="headerlink" title="3.4 重载的函数名称和模板名称"></a>3.4 重载的函数名称和模板名称</h4><p>假设<code>f</code>（我们一直变着法子经由<code>fwd</code>转发各种东西的目标函数）想通过传入一个执行部分操作函数来自定义其行为。假定该函数接受并返回的类型int，那么<code>f</code>可以声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>;     <span class="comment">//pf是`processing function`的简称</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，<code>f</code>也可以使用平凡的非指针语法来声明。这样的声明长成下面这样，尽管它与上面的声明含义相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> pf(<span class="type">int</span>))</span></span>;        <span class="comment">//声明与上面含义相同的f</span></span><br></pre></td></tr></table></figure>

<p>无论哪种方式声明都可以吧，再假设又有重载函数<code>processVal</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>processVal就可以传递给<code>f</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(processVal);          <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>这样做居然没问题，有点意外吧。f要求的实参是个指涉到函数的指针，可是<code>processVal</code>既非函数指针，甚至连函数都不是，它是两个不同函数的名字。无论如何，编译器还是知道他们需要的是哪个<code>processVal</code>：匹配f形参类型的那个。总之，编译器会选择接受一个int那个版本的<code>processVal</code>，然后把那个函数地址传递给f。</p>
<p>这里之所以能够运作，就在于f的声明式使得编译器弄清楚了哪个版本的<code>processVal</code>是所要求的。fwd就不行了，因为作为一个函数模板，它没有任何关于类型需求的信息，这也使得编译器不可能决议应该传递哪个函数重载版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal);            <span class="comment">//错误！哪个processVal重载版本？</span></span><br></pre></td></tr></table></figure>

<p>光秃秃的processVal并无类型。没有类型，类型推导无从谈起；而没有类型推导，也会导致完美转发失败。</p>
<p>同一个问题，会出现在使用函数模板来代替（或附加于）重载函数名字的场合。函数模板不是只代表一个函数，而是代表许许多多函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">workOnVal</span><span class="params">(T param)</span>            <span class="comment">//处理值的模板</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(workOnVal);                 <span class="comment">//错误！workOnVal的哪个实例？</span></span><br></pre></td></tr></table></figure>

<p><strong>绕行方法（实际不好的方式）</strong></p>
<p>欲让像fwd这种实施完美转发的函数接受重载函数名字或者模板名字，只有手动指定需要转发的那个重载版本或者实例。例如，可以创建一个与<code>f</code>的形参同一类型的函数指针，然后用processVal和workOnVal初始化那个指针（这可以使得适当的prcessVal重载版本的以选择或适当的workOnValue实例得以生成），再后将指针传递给<code>fwd</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PrcessFuncType = <span class="built_in">int</span> (*)(<span class="type">int</span>);            <span class="comment">//相当于创建一个typedef</span></span><br><span class="line"></span><br><span class="line">ProcessFuncType processValPtr = processVal;     <span class="comment">//指定了需要的processVal签名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(processValPtr);                             <span class="comment">//没问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(<span class="built_in">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));   <span class="comment">//也没问题</span></span><br></pre></td></tr></table></figure>

<p>当然，这要求你知道fwd转发的函数指针类型到底应该是什么。完美转发函数一般来说不会在文档中写明这个信息。毕竟，完美转发函数是被设计用来接受任何类型的，但这么一来，没有文档告知你要传递的类型，那你又如何知道呢？</p>
<h4 id="3-5-位域"><a href="#3-5-位域" class="headerlink" title="3.5 位域"></a>3.5 位域</h4><p>最后一种完美转发失败情形，是位域被用于函数实参。为考察在实践中如何表现，观察如下这个可以表示IPv4头部的模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct IPv4Header &#123;</span><br><span class="line">    std::uint32_t  version:4,</span><br><span class="line">                   IHL:4,</span><br><span class="line">                   DSCP:6,</span><br><span class="line">                   ECN:2,</span><br><span class="line">                   totalLength:16;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们被虐了千万遍的函数<code>f</code>(转发函数<code>fwd</code>万年不变的目标)的声明式中接受<code>std::size_t</code>类型的形参，然后用<code>IPv4Header</code>对象的，比如说，<code>totalLength</code>字段来调用<code>f</code>吧，编译器会乖乖放行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> sz)</span></span>;         <span class="comment">//待调用的函数</span></span><br><span class="line"></span><br><span class="line">IPv4Header  h;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength);               <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>但是，入股欧式经由<code>fwd</code>把<code>h.totalLength</code>转发给<code>f</code>，就是另一回事了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(h.totalLength);             <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>问题在于fwd的形参是个引用，而<code>h.totalLength</code>是个非const的位域。乍听之下，这也没什么。但是C++标准却对于这么个组合以异乎寻常的口吻严加禁止：“<strong>非const引用不得绑定到位域</strong>”，该条禁令倒是有极其充分的理由。位域是由机器字的若干任意部分组成的（例如，32位int的第3到第5个比特），但是这样的尸体是不可能有办法对其直接取址的。我前面曾提及，在硬件层次，引用和指针本是同一事物。这么一来，既然<strong>没有办法创建指涉到任意比特的指针</strong>（C++硬性规定，可以指涉到的最小实体是单个char），那自然也就没有办法把引用绑定到任意比特了。</p>
<p><strong>绕行方法</strong></p>
<p>要将完美转发位域的不可能转化为可能，也简单不过。一旦你意识到接受位域实参的任意函数都实际上只会收到位域值的副本。毕竟，没有函数可以把位域绑定到引用，也不可能有函数接受指涉到位域的指针，因为根本不存在指涉到位域的指针。可以传递位域的仅有的形参种类就只有按值传递，以及，有点匪夷所思的常量引用。在按值传递的形参这种情况下，被电泳的函数显然接收到的是位域内的值的副本，而在常量引用形参这种情况下，标准要求这时引用实际绑定到存储在某种标准整型（例如int）中的位域值的副本。常量引用不可能绑定到位域，他们绑定到的是“常规”对象，其中复制了位域的值。</p>
<p>这么一来，把位域传递给完美转发函数的关键，就是利用转发目的函数接收的总是位域值的副本这一事实。你可以自己制作一个副本，并以该副本调用转发函数。例如，在IPv4Header一例中，下述diamante即演示了该技巧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制位域值，初始化形式参见Item 6</span></span><br><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength)；</span><br><span class="line"><span class="built_in">fwd</span>(length);                <span class="comment">//转发该副本</span></span><br></pre></td></tr></table></figure>

<h3 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h3><p>在绝大多数情况下，完美转发就如规定所言的方式运作。你很少需要特别留意什么。但当它无法运作时，也就是当一些看上去合理的代码编译失败，或者更讨厌的情况，可以通过编译，行为却表现的和预料不同。重要的是，要了解完美转发的不完美之所在，同样重要的是知道如何规避他们。在绝大多数情况下，这些规避手法都是直截了当的。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 完美转发的失败情形，是源于模板类型推导失败，或推导结果是错误的类型。</td>
</tr>
<tr>
<td>2. 会导致完美转发失败的实参种类有大括号初始物，以值0或NULL表达的空指针，仅有声明的整型static const成员变量，模板或重载的函数名字，以及位域。</td>
</tr>
</tbody></table>
<h1 id="第六章-Lambda表达式"><a href="#第六章-Lambda表达式" class="headerlink" title="第六章 Lambda表达式"></a>第六章 Lambda表达式</h1><h2 id="条款31-lambda避免默认捕获模式"><a href="#条款31-lambda避免默认捕获模式" class="headerlink" title="条款31 lambda避免默认捕获模式"></a>条款31 lambda避免默认捕获模式</h2><p>C++11中有两种默认捕获模式：按引用或按值。按引用的默认捕获模式可能导致<strong>空悬引用</strong>，按<strong>值的默认捕获模式会忽悠你</strong>，好像可以对空悬引用免疫（<strong>其实并没有</strong>），还让你认为你的闭包是独立的（<strong>事实上它们可能不是独立的</strong>）。</p>
<p>以上就是本条的重点内容。</p>
<h3 id="1-默认捕获模式的危害"><a href="#1-默认捕获模式的危害" class="headerlink" title="1.  默认捕获模式的危害"></a>1.  默认捕获模式的危害</h3><p>按引用捕获会导致闭包包含指涉到局部变量的引用，或者指涉到定义lambda式的作用于内的形参的引用。<strong>一旦由lambda式锁创建的闭包越过了该局部变量或形参的生命期，那么闭包内的引用就会空悬</strong>。</p>
<p>例如，我们有一个元素为筛选函数的容器，其中每个筛选函数都接受一个int，并返回一个bool以表示传入的值是否满足筛选条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer =                         <span class="comment">//关于&quot;using&quot;，参见Item 9</span></span><br><span class="line">    std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;      <span class="comment">//关于std::function，参见Item 2</span></span><br></pre></td></tr></table></figure>

<p>我们可以像下面这样添加一个筛选5的倍数的函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(           <span class="comment">//欲知emplace_back，参见Item 42</span></span><br><span class="line">    [](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % <span class="number">5</span> == <span class="number">0</span>;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但，我们可能需要在运行期计算出除数，而不是硬编码”5”写入lambda式中。所以代码可能就改成下面这样了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisiorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(                   <span class="comment">//危险！</span></span><br><span class="line">        [&amp;](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    )                                       <span class="comment">// 对divsior的引用可能空悬！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码随时会出错。lambda式是指涉到局部变量<code>divisor</code>的引用，但该变量在<code>addDivisorFilter</code>返回时即不再存在。换言之，该变量的销毁就是紧接着<code>filters.emplace_back</code>返回的那一刻。所以这就等于，添加到筛选器聚集的那个函数刚刚被添加完就消亡了。使用这个筛选器，从它刚被创建的那一刻起，就会产生未定义行为。</p>
<p>就算不这样做，换作以显式方式安引用捕获<code>divisor</code>，问题依旧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(                   <span class="comment">//危险！</span></span><br><span class="line">        [&amp;divisor](<span class="type">int</span> value)</span><br><span class="line">         &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    )                                       <span class="comment">// 对divsior的引用仍然可能空悬！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，通过显式捕获，确实较为容易看出lambda式的生存依赖于<code>divisor</code>的生存期。而且，明白地写出名字<code>divisor</code>还提醒了我们，再次确认divisor至少和该lambda式的闭包具有一样长的生命期。比起“<code>[&amp;]</code>”所表达的这种不痛不痒的“<strong>要保证没有空悬哟</strong>”式的劝告，显式指名更加让人印象深刻。</p>
<h3 id="2-默认捕获不会出问题的前提"><a href="#2-默认捕获不会出问题的前提" class="headerlink" title="2. 默认捕获不会出问题的前提"></a>2. 默认捕获不会出问题的前提</h3><p>如果你知道闭包会被<strong>立即使用</strong>（例如，传递给STL算法）并且<strong>不会被复制</strong>，那么引用比它持有的局部变量或形参生命期更长，就不存在风险。</p>
<h4 id="2-1-即便满足了前提依旧不推荐的原因"><a href="#2-1-即便满足了前提依旧不推荐的原因" class="headerlink" title="2.1 即便满足了前提依旧不推荐的原因"></a>2.1 即便满足了前提依旧不推荐的原因</h4><p>你可能会争论说，这样的情况下，既然没有引用空悬风险，也就没有理由要避免使用按默认引用捕获模式。</p>
<p>例如，我们的筛选器lambda式仅用作C++11的<code>std::all_of</code>的实参，后者的作用是否返回某作用域内的严肃是否都满足某条件的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithContainer</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();       <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();       <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);    <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ConElemT = <span class="keyword">typename</span> C::value_type;    <span class="comment">//为实现泛型算法</span></span><br><span class="line">                                                <span class="comment">//取得容器中的元素类型，参见Item 13</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> std::begin;</span><br><span class="line">    <span class="keyword">using</span> std::end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(</span><br><span class="line">        <span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),       <span class="comment">// 如果所有容器中的元素</span></span><br><span class="line">        [&amp;](<span class="type">const</span> ConElemT&amp; value)              <span class="comment">// 值都是divisor的倍数</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    ))&#123;                                         <span class="comment">// 若全是，则执行这里</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                    <span class="comment">// 若至少有一个不是，执行这里</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不错，这样使用的确安全，但是<strong>这样的安全可谓朝不保夕</strong>！如果返现该lambda式在其他语境中有用（例如，加入到filters容器中成为一个函数元素），然后被复制并黏贴到其他闭包比divisor生命期更长的语境中的话，你就又被拖回空悬的困境了。<strong>这一回，在捕获语句中，可没有任何让你对divisor进行生命期分析的提示之物了</strong>。</p>
<p>从长远观点看来，显式地列出lambda式所依赖的局部变量或形参是更好的软件工程实现。</p>
<h4 id="2-2-C-14-提供了lambda中用auto"><a href="#2-2-C-14-提供了lambda中用auto" class="headerlink" title="2.2 C++14 提供了lambda中用auto"></a>2.2 C++14 提供了lambda中用auto</h4><p>C++14提供了lambda式的形参声明中使用<code>auto</code>的能力，这意味着上面的代码在C++14中可以简化，ConElemT的声明可以删去，而if条件可以更加如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::<span class="built_in">all_of</span>(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),</span><br><span class="line">                [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; value)               <span class="comment">//C++14</span></span><br><span class="line">                &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="3-再看看按值捕获"><a href="#3-再看看按值捕获" class="headerlink" title="3. 再看看按值捕获"></a>3. 再看看按值捕获</h3><p>解决上述问题的一种方式是对divisor采用按值的默认捕获方式。即，我们这样向容器中添加lambda式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(       <span class="comment">//现在divisor不会空悬</span></span><br><span class="line">    [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于本例而言，这样做的确已经足够。但，总的来说，<strong>按值的默认捕获并非你想的那样是能够避免空悬的灵丹妙药</strong>。</p>
<h4 id="3-1-按值捕获的陷阱"><a href="#3-1-按值捕获的陷阱" class="headerlink" title="3.1 按值捕获的陷阱"></a>3.1 按值捕获的陷阱</h4><p>按值捕获了一个指针以后，在lambda式创建的闭包中持有的是这个指针的副本，但你并没有办法阻止lambda式之外的代码去针对该指针实施delete操作所导致的指针副本空悬。</p>
<p>你也许会说：</p>
<blockquote>
<p><em>这种事情根本不会发生，你抗议道，我已经看完了第4章，智能指针是我的崇拜，只有没有前途的C++98程序猿才会使用裸指针和delete</em>。</p>
</blockquote>
<p>可能的确如此，但你很难脱离干系，因为事实上，有时你真的会使用裸指针，还有的时候，它们会在你眼皮底下实施delete操作。只不过现代C++编程风格中，在源码中很难看到裸指针。</p>
<p>来一个例子：</p>
<p>假设<code>Widget</code>类可以实施的一个操作是向筛选器容器添加条目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...                         <span class="comment">// 构造函数等</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 向filters添加一个条目</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> divisor;                <span class="comment">//用于Widget的filter元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Widget::addFilter</code>可能做如下定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">      [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在满心欢喜的外行看来，这像是安全代码。虽然该lambda式对<code>divisor</code>有所依赖，但按值的默认捕获模式会确保<code>divisor</code>被复制到该lambda式创建的任何闭包里，对吗？</p>
<p><strong>错！错的彻底！错的离谱！错的无可救药！</strong></p>
<p><strong>因为：</strong> <strong>【重点来了】</strong></p>
<blockquote>
<p><strong>捕获只能针对在创建lambda式的作用域内可见的非静态局部变量（包括形参）</strong>。</p>
</blockquote>
<p>在<code>Widget::addFilter</code>的函数体内，<code>divisor</code>并非局部变量，而是<code>Widget</code>类的成员变量。它压根无法被捕获。这么一来，如果默认捕获模式被消除，代码就不会通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(       <span class="comment">//错误！ 没有可捕获的divisor</span></span><br><span class="line">        [](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且，如果试图显式捕获<code>divisor</code>（无论按值还是按引用，这都无关紧要），这个捕获语句都不能通过编译，因为<code>divisor</code>既不是局部变量，也不是形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(       <span class="comment">//错误！ 局部没有可捕获的divisor</span></span><br><span class="line">        [divisor](<span class="type">int</span> value) </span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果在按值的默认捕获语句中捕获的并非divisor，并且如果这句按值的默认捕获语句不存在，代码不能编译。那么到底实际发生了什么呢？</p>
<h4 id="3-2-背后的原因"><a href="#3-2-背后的原因" class="headerlink" title="3.2 背后的原因"></a>3.2 背后的原因</h4><p>在<code>Widget::addFilter</code>的按值默认捕获版本中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">      [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是divisor。从编译器视角来看，上述代码相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> currentObjectPtr = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(      </span><br><span class="line">        [currentObjectPtr](<span class="type">int</span> value) </span><br><span class="line">        &#123; <span class="keyword">return</span> value % currentObjectPtr-&gt;divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解了这一点，也就相当于理解了lambda闭包的存活与它含有其<code>this</code>指针副本的<code>Widget</code>对象的生命期是绑定在一起的。特别的，考虑下面的代码，它掌握了第4章的精髓，仅使用了智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer =                     <span class="comment">//同前</span></span><br><span class="line">    std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters；                   <span class="comment">//同前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pw =       <span class="comment">//创建Widget，关于std::make_unique参见Item 21</span></span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line">    <span class="comment">// 添加使用了Widget::divisor的筛选函数</span></span><br><span class="line">    pw-&gt;<span class="built_in">addFilter</span>();</span><br><span class="line">    ...             <span class="comment">//Widget被销毁，filters现在持有空悬指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>doSomeWork</code>时创建了一个筛选函数，它依赖于<code>std::make_unique</code> 创建的<code>Widget</code>对象，即，一个含有指向<code>Widget</code>指针（<code>Widget</code>的<code>this</code>指针的副本）的筛选函数。该函数被添加到<code>filters</code>中，不过当<code>doSomeWork</code>执行结束后，<code>Widget</code>对象就被<code>std::unique_ptr</code>销毁了，参见Item 18。所以，从那一刻起，filters中就含有了一个带有空悬指针的元素。</p>
<h4 id="3-3-解决办法"><a href="#3-3-解决办法" class="headerlink" title="3.3 解决办法"></a>3.3 解决办法</h4><p>这个特定问题可以通过将你想捕获的成员变量赋值到局部变量中，然后捕获局部变量副本加以解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;     <span class="comment">//复制成员变量</span></span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(      </span><br><span class="line">        [divisorCopy](<span class="type">int</span> value)    <span class="comment">//捕获副本</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;&#125; <span class="comment">//使用副本</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实话实说，如果你采用这种方法，那么按值的默认捕获也能够运作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;     <span class="comment">//复制成员变量</span></span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(      </span><br><span class="line">        [=](<span class="type">int</span> value)    <span class="comment">//捕获副本</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;&#125; <span class="comment">//使用副本</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是为何要冒此不必要的奉献？按值的默认捕获才是最开始造成意外地捕获了<code>this</code>指针，而不是期望中的<code>divisor</code>的始作俑者。</p>
<h3 id="4-C-14-广义lambda捕获"><a href="#4-C-14-广义lambda捕获" class="headerlink" title="4. C++14 广义lambda捕获"></a>4. C++14 广义lambda捕获</h3><p>在C++14中，捕获成员变量的一种更好的方法是使用广义lambda捕获（generalized lambda capture）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(               <span class="comment">//C++14将</span></span><br><span class="line">        [divisor = divisor](<span class="type">int</span> value)  <span class="comment">//divisor复制入闭包</span></span><br><span class="line">        &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125; <span class="comment">//使用副本</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对广义lambda捕获而言，没有按默认捕获模式一说，但是，就算在C++14中，本条款的建议（避免使用默认捕获模式）依然成立。</p>
<h3 id="5-默认捕获静态变量的一个缺点"><a href="#5-默认捕获静态变量的一个缺点" class="headerlink" title="5. 默认捕获静态变量的一个缺点"></a>5. 默认捕获静态变量的一个缺点</h3><p>另外一个缺点：它<strong>似乎表明</strong>闭包是自洽的，与闭包外的数据变化绝缘。</p>
<p>作为一般的结论，这是不正确的。因为lambda式可能不仅依赖于局部变量和形参（他们可以被捕获），他们还会依赖于静态存储期（<code>static storage duration</code>）对象。这样的对象定义在全局或名字空间作用域中，又或在类中，在函数中，在文件中以static饰词声明。这样的对象可以在lambda内使用，但他们不能被捕获。但如果使用了按默认值捕获模式，这些对象就会给人以错觉，认为他们可以加以捕获。思考下面这个前面见过的<code>addDivisiorFilter</code>函数的修改版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisiorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();    <span class="comment">//现在以static饰词声明</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();    <span class="comment">//现在以static饰词声明</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2); <span class="comment">//现在以static饰词声明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(                   <span class="comment">// 未捕获任何东西！</span></span><br><span class="line">        [=](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    )                                       <span class="comment">// 指涉到前述以static饰词声明的对象</span></span><br><span class="line">    ++divisor++;                            <span class="comment">// 意外修改了divisor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一目十行的读者，在看到代码中有”<code>[=]</code>“后，就会想当然地认为，“很好，lambda式复制了它内部使用的对象，因此lambda式是自洽的。” 这无可厚非，但该lambda式是在并不独立，因为它没有使用任何的非静态局部变量和形参，所以它没能捕获任何东西。更糟糕的是lambda式的代码中设置了静态变量<code>divisor</code>。因而，每次调用<code>addDivisiorFilter</code>的最后<code>divisor</code>都会被递增，从而在把好多个lambda式添加到<code>filters</code>时，每个lambda式的行为都不一样（对应于<code>divisor</code>的新值）。从实际效果来说，这个lambda式实现的效果是按引用捕获<code>divisor</code>，和按值默认捕获所暗示的含义有着直接的矛盾。如果从一开始就远离按值的默认捕获模式，也就能消除代码被如此误读的风险了。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 按引用的默认捕获会导致空悬指针问题。</td>
</tr>
<tr>
<td>2. 按值的默认捕获极易受空悬指针影响（尤其是<code>this</code>），并会误导人们认为lambda式是自洽的。</td>
</tr>
</tbody></table>
<h2 id="条款32-使用初始化捕获将对象移入闭包"><a href="#条款32-使用初始化捕获将对象移入闭包" class="headerlink" title="条款32 使用初始化捕获将对象移入闭包"></a>条款32 使用初始化捕获将对象移入闭包</h2><p>有时，按值的捕获和按引用的捕获皆非你所欲。如果你想要把一个只移对象（例如，<code>std::unique_ptr</code>或<code>std::future</code>类型的对象）放入闭包，C++11未提供任何办法做到此事。如果你有一个对象，其复制操作开销昂贵，而移动操作成本低廉（例如，大部分标准库容器），而你又需要把该对象放入闭包，那么你肯定更愿意移动该对象，而非复制它。但是，C++11中也还是没有让你实现这一点的途径。</p>
<h3 id="1-C-14-提供的移动捕获，与C-11的模拟移动捕获"><a href="#1-C-14-提供的移动捕获，与C-11的模拟移动捕获" class="headerlink" title="1. C++14 提供的移动捕获，与C++11的模拟移动捕获"></a>1. C++14 提供的移动捕获，与C++11的模拟移动捕获</h3><p>但那只是<code>C++11</code>，<code>C++14</code>则有云泥之别。它为对象移动入闭包提供了直接支持。如果你的编译器兼容<code>C++14</code>，则只需欢呼雀跃后继续读就好。但如果还在使用<code>C++11</code>的编译器，则你仍可以欢呼雀跃后继续读就好，因为<code>C++11</code>中提供了近似移动捕获行为的做法。</p>
<h3 id="2-C-14-提供移动捕获的由来"><a href="#2-C-14-提供移动捕获的由来" class="headerlink" title="2. C++14 提供移动捕获的由来"></a>2. C++14 提供移动捕获的由来</h3><p>移动捕获的缺失即使在C++11标准被刚接受时，也被是为一种缺憾。最直接的不就措施是在C++14中添加这一特性，但是标准委员会却<strong>另辟蹊径</strong>。</p>
<p>委员会提出了一种全新的捕获机制，它是如此灵活，按移动的捕获只不过是属于该机制能够实现的多种效果之一。这种全新的能力被称为初始化捕获（<code>init capture</code>）。实际上，它可以做到C++11的捕获形式能够做到的所有事情，而且还不光如此。初始化捕获不能表示的，则是默认捕获模式，但是Item 31解释过，这是无论何时都应该远离的一种模式（对于将C++11捕获可以实现的情况，若用初始化捕获语法则稍显啰嗦，所以若使用C++11捕获已能解决问题，则大可以使用之）。</p>
<h3 id="3-C-14-初始化捕获的好处"><a href="#3-C-14-初始化捕获的好处" class="headerlink" title="3. C++14 初始化捕获的好处"></a>3. C++14 初始化捕获的好处</h3><p>使用初始化捕获，则你会得到机会指定：</p>
<ol>
<li>由lambda生成的闭包类中的成员变量名字。</li>
<li>一个表达式，用以初始化该成员变量。</li>
</ol>
<h3 id="4-C-14-看看初始化捕获怎么用"><a href="#4-C-14-看看初始化捕获怎么用" class="headerlink" title="4. C++14 看看初始化捕获怎么用"></a>4. C++14 看看初始化捕获怎么用</h3><p>以下是如何使用初始化捕获将<code>std::unqiue_ptr</code>移动到闭包内：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                  <span class="comment">//一些有用的类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidted</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isProcessed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isArchived</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();   <span class="comment">//创建Widget</span></span><br><span class="line">                                        <span class="comment">//关于std::make_unique，参见Item 21</span></span><br><span class="line"></span><br><span class="line">...                                     <span class="comment">//配置*pw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">move</span>(pw)]                <span class="comment">//采用std::move(pw)</span></span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp;   <span class="comment">//初始化闭包类的数据成员</span></span><br><span class="line">                    pw-&gt;<span class="built_in">isArchived</span>();&#125;;</span><br></pre></td></tr></table></figure>

<p>[] 中的那段代碼就是初始化捕获，位于“&#x3D;”左边的，是你所指定的闭包类成员变量的名字，而位于其右侧是初始化表达式。</p>
<p>值得注意的是：</p>
<blockquote>
<p>等号左边和右边处于不同的作用域！</p>
</blockquote>
<p>左侧作用域就是闭包类的作用域，右侧的作用域与lambda式加以定义之处的作用域相同。在上述例子中，左侧<code>pw</code>指涉的是闭包类的成员变量，而右侧<code>pw</code>指涉的则是在lambda式上面一行声明的对象，即经由调用<code>make_unique</code>所初始化的对象。</p>
<p>所以，</p>
<p><code>pw=std::move(pw)</code>表达了“<em>在闭包中创建一个成员变量pw，然后使用针对局部变量pw实施std::move的结果来初始化该成员变量</em>”。</p>
<p>和平常一样，lambda式体内代码的代码作用域位于闭包类内，所以在那里用到的pw指涉的也是闭包类的成员变量。</p>
<p>如果配置*pw的需求都没有，那么代码还可以更简单一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]   <span class="comment">//用表达式初始化pw</span></span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp;       <span class="comment">//初始化闭包类的数据成员</span></span><br><span class="line">                    pw-&gt;<span class="built_in">isArchived</span>();&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-来看看C-11怎么办，不用沮丧"><a href="#5-来看看C-11怎么办，不用沮丧" class="headerlink" title="5. 来看看C++11怎么办，不用沮丧"></a>5. 来看看C++11怎么办，不用沮丧</h3><p>但如果你使用的编译器缺少对C++14的初始化捕获的支持，那么在C++11中应该怎么办呢？</p>
<p>回想一下，lambda的本质是什么：</p>
<blockquote>
<p>一个lambda表达式不过是生成一个类并且创建一个该类的对象的手法罢了。并不存在lambda能做，而你手工做不到的事情。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsValAndArch</span> &#123;            <span class="comment">//表示“已校验并且已归档”</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">using</span> DataType = std::unqiue_ptr&lt;Widget&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IsValAndArch</span><span class="params">(DataType&amp;&amp; ptr)</span> <span class="comment">// Item 25解释过</span></span></span><br><span class="line"><span class="function">    : pw(std::move(ptr)) &#123;</span>&#125;               <span class="comment">// std::move的用法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="keyword">return</span> pw—&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType pw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">IsValAndArch</span>(std::<span class="built_in">make_unique</span>&lt;Widget&gt;());</span><br></pre></td></tr></table></figure>

<p>比起撰写一个lambda式长了不少，但是它并未改变一个事实，即在C++11中，如果你想要一个支持对成员变量实施移动初始化的类，那么也只需多花一些时间敲键盘，就能达到目的。</p>
<p>如果你非要用lamda式（考虑到他们的便利性，你极可能如此），按移动捕获在C++11中可以采用以下方法模拟，只需要：</p>
<ol>
<li><p><strong>把需要捕获的对象移动到<code>std::bind</code>产生的函数对象中。</strong></p>
</li>
<li><p><strong>给到lambda式一个指涉到欲“捕获”的对象的引用。</strong></p>
</li>
</ol>
<p>如果你本来就熟悉<code>std::bind</code>，代码就显得十分直截了当。如果你还不熟悉<code>std::bind</code>，则代码需要一些时间来习惯，但这些投入是值得的。</p>
<h3 id="6-std-bind配合std-move实现移动捕获"><a href="#6-std-bind配合std-move实现移动捕获" class="headerlink" title="6. std::bind配合std::move实现移动捕获"></a>6. std::bind配合std::move实现移动捕获</h3><p>假如你想创建一个局部的std::vector对象，向其放入一组值，然后将其移动入闭包。在C++14，就是举手之劳：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;       <span class="comment">//欲移入闭包的对象</span></span><br><span class="line">...                             <span class="comment">//灌入数据</span></span><br><span class="line"><span class="keyword">auto</span> func = [data = std::<span class="built_in">move</span>(data)]    <span class="comment">//C++14的初始化捕获</span></span><br><span class="line">            &#123;<span class="comment">/* 对数据加以运用 */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样的相同代码在C++11里应该如何写呢：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;       <span class="comment">//同前</span></span><br><span class="line">...                             <span class="comment">//同前</span></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">            [](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data)    <span class="comment">//C++11中模拟移动捕获的部分</span></span><br><span class="line">            &#123;<span class="comment">/* 对数据加以运用 */</span>&#125;,</span><br><span class="line">            std::<span class="built_in">move</span>(data)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<h4 id="6-1-std-bind是干什么的"><a href="#6-1-std-bind是干什么的" class="headerlink" title="6.1 std::bind是干什么的"></a>6.1 std::bind是干什么的</h4><p>和lambda表达式类似地，<code>std::bind</code>也生成函数对象。我们称<code>std::bind</code>返回的函数对象为绑定对象（<code>bind object</code>）。<code>std::bind</code>的第一个实参是个可调用对象，接下来的素有实参表示传给该对象的值。</p>
<p><strong>绑定对象含有传递给std::bind所有实参的副本</strong>。</p>
<h4 id="6-2-为什么std-bind可以模拟移动捕获"><a href="#6-2-为什么std-bind可以模拟移动捕获" class="headerlink" title="6.2 为什么std::bind可以模拟移动捕获"></a>6.2 为什么std::bind可以模拟移动捕获</h4><blockquote>
<p>对于每个左值实参，在绑定对象内的对应的对象内对其实施的是复制构造，而对每个右值实参，实施的则是移动构造。</p>
</blockquote>
<p>在这个例子中，第二个实参是个右值（即<code>std::move</code>的结果，参见Item 23)，所以<code>data</code>在绑定对象中实施的是移动构造。而该<strong>移动构造动作正是实现模拟移动捕获的核心所在</strong>，因为把右值移入绑定对象，正是绕过C++11无法将右值移入闭包的手法。</p>
<h4 id="6-3-std-bind模拟移动捕获的逐步分析"><a href="#6-3-std-bind模拟移动捕获的逐步分析" class="headerlink" title="6.3 std::bind模拟移动捕获的逐步分析"></a>6.3 std::bind模拟移动捕获的逐步分析</h4><p>当一个绑定对象被“调用”（即，其函数调用运算符被唤起）时，它所存储的实参会传递给原先传递给<code>std::bind</code>的那个可调用对象。在本例中，也就是当func（绑定对象）被调用时，func内经由移动构造出所得到的<code>data</code>的副本就会作为实参传递给那个原先传递给<code>std::bind</code>的lambda式。</p>
<h4 id="6-4-模拟移动捕获怎么写"><a href="#6-4-模拟移动捕获怎么写" class="headerlink" title="6.4 模拟移动捕获怎么写"></a>6.4 模拟移动捕获怎么写</h4><p>这个lambda和C++14版本的lambda长得有一样，但是多加了一个形参<code>data</code>，它对应于我们的伪移动捕获对象。该形参是个指涉到绑定对象内的data副本的左值引用（注意：而不是右值引用，因为虽然初始化<code>data</code>副本的表达式是std::move(data)，但data的副本本身是一个左值）。这么一来，在lambda内对<code>data</code>做的操作，都会实施在绑定对象内移动构造而得的<code>data</code>的副本之上。</p>
<h4 id="6-5-带mutable和不带的情况下如何模拟"><a href="#6-5-带mutable和不带的情况下如何模拟" class="headerlink" title="6.5 带mutable和不带的情况下如何模拟"></a>6.5 带mutable和不带的情况下如何模拟</h4><p>默认情况下，lambda生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>饰词。但是，绑定对象里的移动构造得到的<code>data</code>副本却并不带有<code>const</code>饰词。所以，为了<strong>防止</strong>该<code>data</code>的副本在lambda式内<strong>被意外修改</strong>，lambda的形参就<strong>声明</strong>为<strong>常引用</strong>。但如果lambda声明带有<code>mutable</code>饰词，闭包里的<code>operator()</code>函数就不会在声明时带有<code>const</code>饰词，相应的适当做法，就是在lambda声明中略去<code>const</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">            [](std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="keyword">mutable</span>   <span class="comment">//C++11中模拟移动捕获的部分</span></span><br><span class="line">            &#123;<span class="comment">/* 对数据加以运用 */</span>&#125;,</span><br><span class="line">            std::<span class="built_in">move</span>(data)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<h4 id="6-6-进一步分析一下合理性"><a href="#6-6-进一步分析一下合理性" class="headerlink" title="6.6 进一步分析一下合理性"></a>6.6 进一步分析一下合理性</h4><ul>
<li>移动构造一个对象入C++11闭包是不可能实现的，但是移动构造一个对象入绑定对象则是可能实现的。</li>
<li>欲在C++11中模拟移动捕获包括以下步骤：先移动构造一个对象入绑定对象，然后按引用把该移动构造所得的对象传递给lambda式。</li>
<li>因为绑定对象的生命期和闭包相同，所以针对绑定对象中的对象和闭包里的对象可以采用同样手法加以处理。</li>
</ul>
<p>再来一个前面的例子的C++11实践：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++14</span></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]   <span class="comment">//用表达式初始化pw</span></span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp;       <span class="comment">//初始化闭包类的数据成员</span></span><br><span class="line">                    pw-&gt;<span class="built_in">isArchived</span>();&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">            [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; pw)   </span><br><span class="line">            &#123; <span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();&#125;</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;Widget&gt;()</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 使用C++14的初始化捕获将对象移入闭包。</td>
</tr>
<tr>
<td>2. 在C++11中，经由手工实现的类或者<code>std::bind</code>去模拟初始化捕获。</td>
</tr>
</tbody></table>
<h2 id="条款33-使用decltype调用std-forward移动auto-参数"><a href="#条款33-使用decltype调用std-forward移动auto-参数" class="headerlink" title="条款33 使用decltype调用std::forward移动auto&amp;&amp;参数"></a>条款33 使用decltype调用std::forward移动auto&amp;&amp;参数</h2><h3 id="1-你有完美转发lambda入参的需求么"><a href="#1-你有完美转发lambda入参的需求么" class="headerlink" title="1 你有完美转发lambda入参的需求么"></a>1 你有完美转发lambda入参的需求么</h3><p>泛型lambda式（<code>generic lambda</code>）是C++14最振奋人心的特征之一————lambda可以在形参规格中使用<code>auto</code>。这个特性的实现十分直接了当：闭包]类中的<code>operator()</code>采用模板实现。例如，给定下述lambda式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x));&#125;;</span><br></pre></td></tr></table></figure>

<p>则闭包类的函数调用运算符如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeComilerGeneratedClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">//auto类型的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="type">const</span>          <span class="comment">//参见Item 3</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x));&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;                                      <span class="comment">//闭包类的其他功能</span></span><br></pre></td></tr></table></figure>

<p>在本例中，lambda式对<code>x</code>实施的位移动作就是将其转发给<code>normalize</code>。如果<code>normalize</code>区别对待左值和右值，则可说该lambda式撰写的是有问题的，因为，lambda总会传递左值（形参x）给<code>normalize</code>，即使传递给lambda式的实参是个右值。</p>
<p>该lambda式的正确撰写方式是把<code>x</code>完美转发给<code>normalize</code>，这就要求代码中修改两处，首先，<code>x</code>要改成万能引用（参见Item 24)；其次，使用<code>std::forward</code>(参见Item 25)把x转发给<code>normalize</code>。概念上不难理解，这两处的修改都是举手之劳：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x)&#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;???&gt;(x)));&#125;;</span><br></pre></td></tr></table></figure>

<p>可是问题就出在，上面代码里面的<code>???</code>应该怎么办呢？</p>
<h3 id="2-怎么完美转发lambda函数的入参"><a href="#2-怎么完美转发lambda函数的入参" class="headerlink" title="2. 怎么完美转发lambda函数的入参"></a>2. 怎么完美转发lambda函数的入参</h3><p>通常情况下，在使用完美转发的时候，你是在一个接受类型形参T的模板函数中，所以，你写<code>std::forward&lt;T&gt;</code>就好。但是在泛型lambda式中，却没有可用的类型形参T。在lambda式生成的闭包内的模板化<code>operator()</code>函数中的确有个T，但是在lambda式中无法指涉，所以没有用。</p>
<p>Item 28解释过，如果把左值传递给万能引用的形参，则该形参的类型会作为左值引用，如果传递是右值，则该形参会成为右值引用。那意味着在我们的lambda式中，我们可以通过探查<code>x</code>的类型，来判断传入的实参是左值还是右值。</p>
<p><code>decltype(x)</code>将会产生左值引用类型，如果传入的是个右值，<code>decltype(x)</code>将会产生右值引用。</p>
<p>Item 28还解释了，使用<code>std::forward</code>时惯例是：<strong>用类型形参为左值引用表明想要返回左值，而用非引用类型时来表达想要返回的右值。</strong></p>
<p>再看看我们的lambda式，如果<code>x</code>绑定了左值，<code>decltype(x)</code>将产生左值引用类型。这符合惯例。不过，如果<code>x</code>绑定的是个右值，<code>decltype(x)</code>将会产生右值引用惯例，而非符合惯例的非引用。</p>
<h3 id="3-模板实例化分析"><a href="#3-模板实例化分析" class="headerlink" title="3. 模板实例化分析"></a>3. 模板实例化分析</h3><p>但是，再看下Item 28中的<code>std::forward</code>的C++14实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                            <span class="comment">//在名字空间std中</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果客户代码欲完美转发Widget类型的右值，按照惯例，它应该采用Widget类型（即非引用类型）来实例化<code>std::forward</code>，然后<code>std::forward</code>模板会产生如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span>             <span class="comment">//T取Widget时</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);    <span class="comment">//std::forward的实例化结束 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果客户代码想要完美转发<code>Widget</code>的同一右值，但是这次没有遵从惯例将T指定为非引用类型，而是将T指定为右值引用，这会导致什么结果？这就是需要思考的问题，T指定为<code>Widget&amp;&amp;</code>将会发生什么事情。在<code>std::forward</code>完成初步的实例化并实施了<code>std::remove_reference_t</code>之后，但在引用折叠（再参见Item 28）发生之前，<code>std::forward</code>如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span>          <span class="comment">//T取Widget&amp;&amp;时</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp; &amp;&amp;&gt;(param);     <span class="comment">//std::forward的实例化结束 </span></span><br><span class="line">                                                <span class="comment">//(在引用折叠发生之前)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，发生引用折叠，右值引用的右值引用结果是单个右值引用，实例化结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span>          <span class="comment">//T取Widget&amp;&amp;时</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);     <span class="comment">//std::forward的实例化结束 </span></span><br><span class="line">                                             <span class="comment">//(在引用折叠发生之后)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比之前，发现一样的。<strong>这意味着，实例化<code>std::forward</code>时，使用一个右值引用类型和使用一个非引用类型，会产生相同结果</strong>。</p>
<h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h3><p>这个结果非常不错，因为如果传递给lambda式的形参<code>x</code>是个右值，<code>decltype(x)</code>产生的是右值引用类型，我们之前已经知道了，传递左值给我们的lambda式时，<code>decltype(x)</code>会产生传递给<code>std::forward</code>符合惯例的类型，而现在，我们又知道对右值而言，虽然<code>decltype(x)</code>产生的类型并不符合传递给<code>std::forward</code>的类型形参的管理。但是产生的结果殊途同归。所以，这里无论左值右值都能够符合要求。</p>
<p>所以我们可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单一变量</span></span><br><span class="line"><span class="keyword">auto</span> f = </span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp; param)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalizer</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//多变量</span></span><br><span class="line"><span class="keyword">auto</span> f = </span><br><span class="line">    [](<span class="keyword">auto</span>&amp;&amp;... param)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalizer</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)...));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 对auto&amp;&amp;类型的形参使用decltype，以std::forward之。</td>
</tr>
</tbody></table>
<h2 id="条款-34-优先选用lambda式，而非std-bind"><a href="#条款-34-优先选用lambda式，而非std-bind" class="headerlink" title="条款 34 优先选用lambda式，而非std::bind"></a>条款 34 优先选用lambda式，而非std::bind</h2><h3 id="1-std-bind历史资料"><a href="#1-std-bind历史资料" class="headerlink" title="1. std::bind历史资料"></a>1. std::bind历史资料</h3><p>std::bind是C++98中std::bind1st和std::bind2nd的后继特性，但是作为一种非标准特性而言，std::bind在2005年就已经是标准库的组成部分了。正是在那时，标准委员会接受了名称TR1的文档，里面就包含了std::bind的规格（在TR1中，bind位于不同的名字空间，所以是std::tr1::bind而非std::bind，还有一些借口细节与现在有所不同）。</p>
<p><strong>在C++11中，相对于bind，lambda式几乎总会是更好的选择。到了C++14，lambda不仅优势变大，更成为了不二之选。</strong></p>
<h3 id="2-优劣势比较"><a href="#2-优劣势比较" class="headerlink" title="2. 优劣势比较"></a>2. 优劣势比较</h3><h4 id="2-1-可读性更好"><a href="#2-1-可读性更好" class="headerlink" title="2.1 可读性更好"></a>2.1 可读性更好</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示时刻的类型typedef（语法参见Item 9）</span></span><br><span class="line"><span class="keyword">using</span> Time = std::chrono::steady_clock::time_point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于“enum class”，参见Item 10</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Sound</span> &#123;Beep, Siren, Whistle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示时长的类型typedef</span></span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::steady_clock::duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在时刻t，发出声音s，持续时长d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里进一步假设，在程序的某处，我们想要设置在一小时之后，发出警报并持续30秒。警报的具体声音，却尚未确定。这么一来，我们可以撰写一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=lambda&spm=1001.2101.3001.7020">lambda</a>式，修改<code>setAlarm</code>的接口，这个新的接口只需要指定声音即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setSoundL(&quot;L&quot;表示Lambda)是个函数对象</span></span><br><span class="line"><span class="comment">// 它接受指定一个声音</span></span><br><span class="line"><span class="comment">// 该声音将在设定后一小时发出，并持续30秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundL = </span><br><span class="line">        [](Sound s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使std::chrono组件不加限定饰词即可使用</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">            <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="built_in">hours</span>(<span class="number">1</span>),    <span class="comment">//报警发出的时刻为1小时后</span></span><br><span class="line">                     s,</span><br><span class="line">                     <span class="built_in">seconds</span>(<span class="number">30</span>));                      <span class="comment">//持续30秒</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>如果是在C++14里，那么上述的代码可以写的更具可读性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL = </span><br><span class="line">        [](Sound s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;          <span class="comment">//C++14支持实现后缀</span></span><br><span class="line">            <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,      <span class="comment">//这里直接用1h表示</span></span><br><span class="line">                     s,</span><br><span class="line">                     <span class="number">30</span>s);                          <span class="comment">//30s表示</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>std::bind</strong>来表达甚至很容易错</p>
<p>那么如果用<code>std::bind</code>来写会是什么样呢？下面的代码其实包含了一个错误，我们后续会修复它，先看看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;      <span class="comment">//这里是因为要用bind对应的占位符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB =                        <span class="comment">//B表示bind</span></span><br><span class="line">        std::<span class="built_in">bind</span>(setAlarm, </span><br><span class="line">                  steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,    <span class="comment">//这里有个错误！</span></span><br><span class="line">                  _1,</span><br><span class="line">                  <span class="number">30</span>s);</span><br></pre></td></tr></table></figure>

<p>对于初学者而言，这种“_1”占位符简直好比天书，但即使是行家，也许脑补出从占位符中数字到它在std::bind形参列表位置的映射关系，才能理解，在调用setSoundB时传入的第一个参数，会作为第二个实参传递给setAlarm。而且你还不知道这个实参的类型是什么，需要查看setAlarm的声明。</p>
<p>接下来看看错误在哪里：</p>
<p>在lambda式中，表达式steady_clock::now() + 1h是setAlarm的实参之一，这一点清清楚楚，该表达式会在setAlarm被调用的时刻评估求值。这样做合情合理，我们就是想要在setAlarm被调用后的一个小时之后启动报警。</p>
<p>在std::bind的调用中，steady_clock::now() + 1h作为实参被传递给了std::bind，而非setAlarm。意味着表达式评估求值的时刻是在调用std::bind的时刻，并且求得的时间结果会被存储在结果绑定对象中。<strong>最终导致的结果是，报警被设定的启动时刻是在调用std::bind的时刻之后的一个小时，而并非调用setAlarm的时刻之后的一个小时！。</strong></p>
<p><strong>std::bind</strong>来表达应该怎么对</p>
<p>想解决这个问题，就像需要让<code>std::bind</code>来延迟表达式的评估求值到调用<code>setAlarm</code>的时候，而实现这一点的途径是在原来的<code>std::bind</code>上再嵌套一个<code>std::bind</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++14，标准运算符模板的模板类型实参大多数情况可以不写</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = </span><br><span class="line">    std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">              std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),</span><br><span class="line">              _1,</span><br><span class="line">              <span class="number">30</span>s);</span><br><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB = </span><br><span class="line">    std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">                std::<span class="built_in">bind</span>(std::<span class="built_in">plus</span>&lt;steady_clock::time_point&gt;(),            </span><br><span class="line">                          steady_clock::<span class="built_in">now</span>(), </span><br><span class="line">                          <span class="built_in">hours</span>(<span class="number">1</span>)),</span><br><span class="line">              _1,</span><br><span class="line">              <span class="built_in">seconds</span>(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>

<p>事情到这里，已经很明显的显示出lambda的优势了，可读性强了不少。</p>
<h4 id="2-2-遇到重载也没事"><a href="#2-2-遇到重载也没事" class="headerlink" title="2.2 遇到重载也没事"></a>2.2 遇到重载也没事</h4><p>一旦对<code>setAlarm</code>实施了重载，新的问题就会马上出现。</p>
<p>假如有个重载版本会接受第四个形参，用以指定报警的音量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Volume</span> &#123;Normal, Loud, LoudPlusPlus&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d, Volume v)</span></span>;</span><br></pre></td></tr></table></figure>

<p>之前的lambda表示没问题，可以正常调用3形参版本重载。</p>
<p>但是对<code>std::bind</code>的调用，就无法通过编译了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = </span><br><span class="line">    std::<span class="built_in">bind</span>(setAlarm,     <span class="comment">//错误！这里不知道如何选择了</span></span><br><span class="line">                std::<span class="built_in">bind</span>(std::<span class="built_in">plus</span>&lt;steady_clock::time_point&gt;(),            </span><br><span class="line">                          steady_clock::<span class="built_in">now</span>(), </span><br><span class="line">                          <span class="built_in">hours</span>(<span class="number">1</span>)),</span><br><span class="line">              _1,</span><br><span class="line">              <span class="built_in">seconds</span>(<span class="number">30</span>));  </span><br></pre></td></tr></table></figure>

<p>错误的根因在于编译器只拿到一个函数名，但是这个函数本身是多义的。</p>
<p>如果还是要让<code>std::bind</code>能运作，那么要写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SetALarm3ParamType = <span class="built_in">void</span>(*)(Time t, Sound s, Duration d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = </span><br><span class="line">    std::<span class="built_in">bind</span>(<span class="built_in">static_cast</span>&lt;SetALarm3ParamType&gt;(setAlarm),</span><br><span class="line">                std::<span class="built_in">bind</span>(std::<span class="built_in">plus</span>&lt;steady_clock::time_point&gt;(),            </span><br><span class="line">                          steady_clock::<span class="built_in">now</span>(), </span><br><span class="line">                          <span class="built_in">hours</span>(<span class="number">1</span>)),</span><br><span class="line">              _1,</span><br><span class="line">              <span class="built_in">seconds</span>(<span class="number">30</span>)); </span><br></pre></td></tr></table></figure>

<h4 id="2-3-可读性更高的生成更快的代码"><a href="#2-3-可读性更高的生成更快的代码" class="headerlink" title="2.3 可读性更高的生成更快的代码"></a>2.3 可读性更高的生成更快的代码</h4><p>但即便你觉得这样写好，多写几行没什么问题，但这么写还是带来了更大的问题：<br>在<code>SetSoundL</code>的函数中，调用<code>setAlarm</code>采用的是常规的函数唤起方式，这么一来，编译器就可以用惯常的手法将其内联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setSoundL</span>(Sound::Siren);        <span class="comment">//这里，setAlarm的函数体大可以被内联</span></span><br></pre></td></tr></table></figure>

<p>可是，std::bind的调用传递了一个指涉到setAlarm的函数指针，而那就意味着setAlarm的调用是通过函数指针发生的。编译器不太会内联掉通过函数指针发起的函数调用，所以后一种写法被内联的几率大大降低。所以lambda式形式的调用被优化的可能性更高。</p>
<p>而不仅如此，上面的例子仅仅涉及一个函数调用，如果你想做的事情比这更复杂，使用lambda式的好处会急剧增大。</p>
<p>看下面一个例子，需求是判断某个参数是否在最大值和最小值之间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++14</span></span><br><span class="line"><span class="keyword">auto</span> betweenL = </span><br><span class="line">    [lowVal, highVal]</span><br><span class="line">    (<span class="type">const</span> <span class="keyword">auto</span>&amp; val)</span><br><span class="line">    &#123; <span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::bind C++14</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">auto</span> betweenB = </span><br><span class="line">    std::<span class="built_in">bind</span>(std::logical_and&lt;&gt;(),</span><br><span class="line">            std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), lowVal, _1),</span><br><span class="line">            std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), _1, highVal));</span><br></pre></td></tr></table></figure>

<p>C++11还不支持模板泛型自动推导，还要改成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::bind C++11</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">auto</span> betweenB = </span><br><span class="line">    std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">            std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), lowVal, _1),</span><br><span class="line">            std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, highVal));</span><br></pre></td></tr></table></figure>

<p>这么一对比，已经太明显不过了。</p>
<h4 id="2-4-std-bind的劣势"><a href="#2-4-std-bind的劣势" class="headerlink" title="2.4 std::bind的劣势"></a>2.4 std::bind的劣势</h4><p>试想这样一个场景，需要压缩一个类，然后返回这个类的副本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">CompLevel</span> &#123; Low, Normal, High&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">compress</span><span class="params">(<span class="type">const</span> Widget&amp; w, CompLeve lev)</span>l</span></span><br></pre></td></tr></table></figure>

<p>然后写了个函数对象包装一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, w, _1);</span><br></pre></td></tr></table></figure>

<p>但是这里w是按值传递的还是按引用传递的，就让人很迷惑了。（这里有个前提，std::bind默认就是按值传递的，如果要用按引用，要显示写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, std::<span class="built_in">ref</span>(w), _1);</span><br></pre></td></tr></table></figure>

<p>而lambda就很明显是按值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto compressRateL = </span><br><span class="line">    [w](CompLeve lev)</span><br><span class="line">    &#123; return compress(w, lev);&#125;;</span><br></pre></td></tr></table></figure>

<p>不仅仅是这里声明和定义的地方让人迷惑，调用的形式也让人不清不楚：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda式</span></span><br><span class="line"><span class="built_in">compresssRateL</span>(CompLevel::High);        <span class="comment">//实参按值传递</span></span><br><span class="line"><span class="comment">//bind式</span></span><br><span class="line"><span class="built_in">compresssRateB</span>(CompLevel::High);        <span class="comment">//这里是按照什么呢？</span></span><br></pre></td></tr></table></figure>

<p>答案又会让你出乎意料，而且还是死记硬背没有原因的：</p>
<p>std::bind的工作原理，<strong>绑定对象的所有实参都是按引用传递的，因为此种对象的函数调用运算符利用了完美转发</strong>。</p>
<h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h3><p>C++14里已经可以忘记std::bind了。</p>
<p>C++11里还有两种受限场合可以使用：</p>
<p>移动捕获：C++11语言不支持初始化捕获，只能用bind来模拟，详见Item 32</p>
<p>多态函数对象： 因为绑定对象的函数调用运算符利用了完美转发，它就可以接受任何类型的实参（除了在Item 30中提到的受限情况外）。这个特点再你想要绑定的对象具有一个函数调用运算符模板是，是有利用价值的。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PolyWidget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里来个bind：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PolyWidget pw;</span><br><span class="line"><span class="keyword">auto</span> boundPw = std::<span class="built_in">bind</span>(pw, _1);</span><br></pre></td></tr></table></figure>

<p>这样一来，<code>boundPw</code>就可以通过任意类型的实参加以调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boundPw</span>(<span class="number">1995</span>);</span><br><span class="line"><span class="built_in">boundPw</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">boundPw</span>(<span class="string">&quot;Adam Xiao&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在C++11中的lambda式是办不到的，因为不支持泛型，但是C++14里依旧可以做到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++14</span></span><br><span class="line"><span class="keyword">auto</span> boundPw = [pw](<span class="type">const</span> <span class="keyword">auto</span>&amp; param)</span><br><span class="line">                &#123;<span class="built_in">pw</span>(param);&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. lambda式比起使用<code>std::bind</code>而言，可读性更好，表达力更强，可能运行效率更高。</td>
</tr>
<tr>
<td>2. 仅在C++11中，<code>std::bind</code>在实现移动捕获，或是多态函数对象的时候，还有余热可以发挥。</td>
</tr>
</tbody></table>
<h1 id="第七章-并发API"><a href="#第七章-并发API" class="headerlink" title="第七章 并发API"></a>第七章 并发API</h1><h2 id="条款-35-优先选用基于任务而非基于线程的程序设计"><a href="#条款-35-优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款 35 优先选用基于任务而非基于线程的程序设计"></a>条款 35 优先选用基于任务而非基于线程的程序设计</h2><h3 id="1-异步执行"><a href="#1-异步执行" class="headerlink" title="1. 异步执行"></a>1. 异步执行</h3><p>如果你想以异步方式运行函数<code>doAsyncWork</code>，有两种方法。</p>
<ol>
<li>你可以创建一个<code>std::thread</code>，并在其上运行<code>doAsyncWork</code>，这种方式属于基于线程的途径(<code>thread_based</code>)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>你可以把<code>doAsyncWork</code>传递给<code>std::async</code>，这种策略叫做基于任务(<code>task_based</code>)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork);  <span class="comment">//fut是期望的缩写</span></span><br><span class="line">fut.<span class="built_in">wait</span>();</span><br><span class="line">fut.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<p><strong>基于任务的方法通常比基于线程的实现的对应版本要好</strong>，即使从刚才我们看过的这么几行代码中，已经凸显出优势</p>
<h3 id="2-优劣势比较-1"><a href="#2-优劣势比较-1" class="headerlink" title="2. 优劣势比较"></a>2. 优劣势比较</h3><h4 id="2-1-更易于获得返回值"><a href="#2-1-更易于获得返回值" class="headerlink" title="2.1 更易于获得返回值"></a>2.1 更易于获得返回值</h4><p><code>doAsyncWork</code>会产生一个返回值，我们有里有假定，调用<code>doAsyncWork</code>的代码会对该值感兴趣。在基于线程的调用中，没什么直截了当的办法能够获取该值；而在基于任务的调用中，这很容易，因为<code>std::async</code>返回的期望提供了<code>get</code>函数。如果<code>doAsyncWork</code>函数发射了一个异常，<code>get</code>函数就更重要了，因为它能访问到该异常。而如果采用基于线程的途径，在<code>doAsyncWork</code>抛出异常时，程序就会挂了（经由<code>std::terminate</code>)。</p>
<h4 id="2-2-具有更高层的抽象"><a href="#2-2-具有更高层的抽象" class="headerlink" title="2.2 具有更高层的抽象"></a>2.2 具有更高层的抽象</h4><p>基于线程和基于任务的程序设计之间更基本的区别在于，基于任务的程序设计表现着更高阶的抽象。它把你从线程管理的细节中解放出来，说到这里，有必要概述一下“线程”在带有并发的 C++软件中的三种意义：</p>
<ul>
<li>硬件线程是实际执行计算机的线程。现代计算机体系结构会为每个 CPU 内核提供一个或多个硬件线程。</li>
<li>软件线程（又称操作系统线程或者系统线程）是操作系统用以实施跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程会比硬件线程要多，因为当一个软件线程阻塞了（例如，阻塞在 I&#x2F;O 操作上，或者需要等待互斥量或者条件变量等），运行另外的非阻塞线程能够提升吞吐率。</li>
<li><code>std::thread</code>是 C++进程里的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表示为<code>null</code>句柄，对应于“无软件线程”，可能的原因有：它们处于默认构造状态（因此没有待执行的函数），或被移动了（作为移动目的的 <code>std::thread</code> 对象成为了底层线程的句柄），或者被联结了（待运行的函数已运行结束），或者被分离了（<code>std::thread</code> 对象与其底层软件线程的连接被切断了）。</li>
</ul>
<p>软件线程是一种有限的资源，如果你试图创建的线程数量多于系统能够提供的数量，就会抛出<code>std::system_error</code>异常。这一点无论如何都会成立，即使待运行函数不能抛出异常。例如，即使<code>doAsyncWork</code>带有<code>noexcept</code>声明饰词</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;     <span class="comment">//关于noexcept，参见Item 14</span></span><br></pre></td></tr></table></figure>

<p>这条语句还是可能会抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;     <span class="comment">//若已无可用线程，则抛出异常</span></span><br></pre></td></tr></table></figure>

<p>写得好的软件必须采取某种办法来处理这样的可能性，但如何解决呢？</p>
<p><strong>两种解决方案</strong></p>
<p>一个办法是，在当前线程中运行<code>doAsyncWork</code>，但这会导致负载不均衡，而且如果当前线程是个GUI线程，会导致不能响应。</p>
<p>另一个办法是，等待某些已存在的软件线程完成工作，然后再尝试创建一个新的<code>std::thread</code>对象，但是有可能发生这种事情：已存在的线程在等待应该由<code>doAsyncWork</code>执行的某个动作（例如，产生返回值，或者向条件变量发送通知等）。</p>
<p><strong>超订问题</strong></p>
<p>即使没有用尽线程，还是会发生超订（oversubscription）问题。也就是，就绪状态（即非阻塞）的软件线程超过了硬件线程数量时候。这种情况发生以后，线程调度器（通常是操作系统的一部分）会为软件按线程在硬件线程之上分配CPU时间片。当一个线程时间片用完，另一个线程启动时，就会执行语境切换。这种语境切换会增加系统的总体线程管理开销，尤其在一个软件线程的这一次和下一次被调度器切换到不同的CPU内核上的硬件线程时会发生高昂的计算成本。</p>
<ol>
<li><p>在那种情况下，那个软件线程通常不会命中CPU缓存（即，它们几乎不会包含对于那软件线程有用的任何数据和指令）；</p>
</li>
<li><p>CPU内核运行的“新”软件线程还会“污染”CPU缓存上为“旧”线程所准备的数据，它们曾经在该CPU内核上运行过，并且很可能再次被调度到同一内核运行。</p>
</li>
</ol>
<p><strong>超订问题为什么不可避免</strong></p>
<p>避免超订是困难的，因为软件线程和硬件线程的最佳比例取决于软件线程变成可运行状态的频繁程度，而这会是动态地改变的，例如，当一个线程从I&#x2F;O密集型转换为计算密集型的时候。软件线程和硬件线程的最佳比例也依赖于语境切换的成本，以及软件线程使用CPU缓存时的命中率。而硬件线程的数量和CPU缓存的细节（例如，缓存尺寸大小，以及相对速度）又取决于计算体系结构，所以即使你再一个平台上调优好了你的应用，避免了超订（同时保持硬件满载工作），也无法保证在另一种机器上你的方案还是能高效工作。</p>
<p><strong>应该怎么面对这些问题</strong></p>
<p>如果把这些问题抛给别人去做，你的生活就可以轻松起来。用<code>std::async</code>正是做到了这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork); <span class="comment">//由标准库的实现者负责线程管理</span></span><br></pre></td></tr></table></figure>

<p>这句调用把线程管理的责任转交给了C++标准库的实现者。</p>
<p>例如，收到线程耗尽异常的可能性会大幅度地减小，因为这句调用可能从不产生该异常。“这怎么可能呢？”你可能会好奇，</p>
<p><strong>“如果我申请的软件线程数量多于系统可以提供的，使用std::thread和使用std::async有什么关系呢？”</strong></p>
<p>这还真的有关系，因为当这种形式（即默认启动策略，参见Item 36）调用<code>std::async</code>时，系统不保证会创建一个新的软件线程。相反，它允许调度器把指定函数(本例中指的是<code>doAsyncWork</code>)运行在请求<code>doAsyncWork</code>结果的线程中（例如，对<code>fut</code>调用了<code>get</code>或者<code>wait</code>的线程），如果系统发生了超订或者线程耗尽，合理的调度器就可以利用这个自由度。</p>
<p><strong>但是你自己来做呢？</strong></p>
<p>如果你需要自己来玩“在需求函数结果的线程上运行”的把戏，曾说明过这会导致负载失衡，这问题并不会消失，只是由<code>std::async</code>和运行时调度器来代替你来面对它们。当谈到负载均衡时，运行时调度器很可能对于当前机器上正在发生什么比你有个更加全面的了解，因为它管理的是所有进程的线程，而非只是运行着你的代码的那个。</p>
<p>即使使用<code>std::async</code>，GUI线程的响应性也会有问题，因为调度器没有办法知道哪个线程在响应性方面需求比较紧迫。在那种情况下，你可以把<code>std::lanuch::async</code>的启动策略换递给<code>std::async</code>。那样做可以保证你想要运行的函数确实会在另一个线程中执行（参见Item 36）。</p>
<p><strong>交给别人来做，别人到底会怎么做呢</strong></p>
<p>最高水平的线程调度器会使用<strong>全系统范围的线程池</strong>来避免超订，而且还会通过运用<strong>工作窃取算法</strong>来提高硬件内核间的负载均衡。C++标准库并未要求一定使用线程池或者工作窃取算法，而且，实话实说，C++11并发规格的一些技术细节让我们不能像希望的那样去利用它们。但是，一些厂商还是会在它们的标准库实现中利用该技术，并且我们有理由期待这一领域会继续进步。如果你使用基于任务的方法进行编程，则在相关技术普及之时你会自动地享受到好处。如若不然，你直接使用了<code>std::thread</code>进行程序设计，则要自行承担处理线程耗尽，超订和负载均衡的重任，更不用提你在程序中的解决方案能否应用在同一台机器的另一个进程上，从而使问题变得雪上加霜了。</p>
<p><strong>目前看来，只有少数情况适合直接使用基于线程的编程方式</strong></p>
<p>比起基于线程编程，基于任务的设计能够分担你手工管理线程的艰辛，而且它提供了一种很自然的方式，让你检查异步执行函数的结果（即，返回值或者异常）。但是仍有几种情况下，直接受用线程会更合适，他们包括：</p>
<ul>
<li><p>你需要访问底层线程实现的API： C++并发API通常会采用特定平台的低级API来实现，经常使用的有pthread或者Windows线程库。它们提供的API比C++提供的更丰富（例如，C++没有线程优先级和亲和性的概念）。为了访问底层线程实现的API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::future</code>则没有该功能的对应物。</p>
</li>
<li><p><strong>你需要且有能力为你的应用优化线程用法</strong>：这也是有可能的，例如，你开发的是个服务器软件，执行时的性能剖析情况已知，并且作为唯一的主要进程部署在一种硬件特性固定的机器平台上。</p>
</li>
<li><p><strong>你需要实现超越C++并发API的线程技术</strong>: 例如，在C++实现中并未提供的线程池的平台上实现线程池。</p>
</li>
</ul>
<p>无论如何，这些都是不常见的情况。大多数时候，你应该选择基于任务的设计，而非直接进行线程相关的程序设计。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>std::thread</code>的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。</td>
</tr>
<tr>
<td>2. 基于线程的程序设计要求手动管理线程耗尽，超订，负载均衡，以及新平台适配。</td>
</tr>
<tr>
<td>3. 经由应用了默认启动策略的<code>std::async</code>进行基于任务的程序设计，大部分这类问题都能找到解决之道。</td>
</tr>
</tbody></table>
<h2 id="条款-36-如果异步是必要的，则指定-std-launch-async"><a href="#条款-36-如果异步是必要的，则指定-std-launch-async" class="headerlink" title="条款 36 如果异步是必要的，则指定 std::launch::async"></a>条款 36 如果异步是必要的，则指定 std::launch::async</h2><h3 id="1-启动策略"><a href="#1-启动策略" class="headerlink" title="1. 启动策略"></a>1. 启动策略</h3><p>当调用<code>std::async</code>来执行一个函数（或可调用对象）时，你基本上都会想让函数以异步方式运行。但仅仅通过<code>std::async</code>来运行，你实际上要求的并非一定会达成异步运行的结果，你要求的仅仅是让该函数以符合<code>std::async</code>的启动策略来运行。</p>
<p>标准策略有两个，他们都是用限定作用域的枚举类型<code>std::launch</code>中的枚举量（关于限定作用域的枚举，参见Item 10）来表示的。假设函数<code>f</code>要传递给<code>std::async</code>以执行，则：</p>
<ul>
<li><p><code>std::launch::async</code>启动策略意味着函数<code>f</code>必须以异步方式运行，即，在另一个线程之上执行。</p>
</li>
<li><p><code>std::launch::deferred</code>启动策略意味着函数<code>f</code>只会在<code>std::async</code>所返回的期待值的<code>get</code>或<code>wait</code>得到调用时才运行。即，执行会推迟至其中另一个调用发生的时刻。当调用<code>get</code>或<code>wait</code>时，<code>f</code>会同步运行。即，调用方会阻塞至<code>f</code>运行结束为止。如果<code>get</code>或<code>wait</code>都没有得到调用，<code>f</code>是不会运行的。</p>
</li>
</ul>
<h3 id="2-默认设定"><a href="#2-默认设定" class="headerlink" title="2. 默认设定"></a>2. 默认设定</h3><p><code>std::async</code>的默认启动策略，也就是你如果不积极指定一个的话，<strong>它采用的并非以上两者中的一者</strong>。相反的，它采用的是对两者进行<strong>或运算</strong>的结果。下面两个调用有着<strong>完全相同</strong>的意义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(f);              <span class="comment">//采用默认启动策略运行f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut2 = std::<span class="built_in">async</span>(std::launch::async |</span><br><span class="line">                        std::launch::deferred,</span><br><span class="line">                        f);             <span class="comment">//采用或者异步或者推迟的方式运行f</span></span><br></pre></td></tr></table></figure>

<p>这么一来，默认启动策略就允许<code>f</code>以异步或同步的方式运行皆可，正如Item 35所制定出的那样，这种弹性使得<code>std::async</code>与标准库的线程管理组件能够承担得起线程的创建和销毁、避免超订，以及负载均衡的责任。这也是使用<code>std::async</code>来做并发程序设计如此方便的诸多因素的一部分。</p>
<p>但以默认启动策略来使用<code>std::async</code>会触及一些意味深长的暗流。给定线程t执行一语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);           <span class="comment">//采用默认启动策略运行f</span></span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>无法预知<code>f</code>是否会和<code>t</code>并发运行，因为<code>f</code>可能会被调度为推迟运行。</li>
<li>无法预知<code>f</code>是否运行在与调用<code>fut</code>的<code>get</code>或<code>wait</code>函数的线程不同的某线程之上。如果那个线程是<code>t</code>，那就是说无法预知<code>f</code>是否会运行在与<code>t</code>不同的某线程之上。</li>
<li>连<code>f</code>是否运行这件起码的事情都是无法预知的，这是因为无法保证在程序的每条路径上，<code>fut</code>的<code>get</code>或<code>wait</code>都会得到调用。</li>
</ul>
<p>默认启动策略在调度上的弹性常会在使用<code>thread_local</code>变量时导致不明不白的混淆，因为这意味着如果<code>f</code>读或写此线程级局部存储（thread-local storage，TLS）时，无法预知会取到的是哪个线程的局部存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);       <span class="comment">//f的TLS可能是和一个独立线程相关，</span></span><br><span class="line">                                <span class="comment">//但是也可能是和调用fut的get或wait的线程相关</span></span><br></pre></td></tr></table></figure>

<p><strong>来看一个出乎意料的例子</strong></p>
<p>它也会影响那些基于<code>wait</code>的循环中以超时为条件者，因为对任务（参见Item 35）调用<code>wait_for</code>或者<code>wait_until</code>会产生<code>std::launch::deferred</code>一值。这意味着以下循环虽然貌似会最终停止，但是，实际上，可能会永远运行下去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;  <span class="comment">//关于C++14持续时长后缀，参见Item 34</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span>                        <span class="comment">//f睡眠1秒后返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);       <span class="comment">//以异步方式运行f(说说而已)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready) <span class="comment">//循环至</span></span><br><span class="line">&#123;                                                       <span class="comment">//f完成运行....</span></span><br><span class="line">    .....                                               <span class="comment">//但此事可能永远不会发生！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>f</code>与调用<code>std::async</code>的线程是并发执行的（即选用了<code>std::launch::async</code>启动策略），这就没问题（假定<code>f</code>最终会完成执行）。</p>
<p>但如果<code>f</code>被推迟执行，则<code>fut.wait_for</code>将总会返回<code>std::future_status::deferred</code>。而那永远也不会取值<code>std::future_status::ready</code>，所以循环也就永远不会终止。</p>
<p>但是，这一类缺陷在开发或者单元测试中很容易被忽略，因为它只会在运行负载很重时，才会现身。这样的负载是把计算机逼向超订或线程耗尽的条件，而那就是任务很可能会被推迟的时机了。毕竟，如果硬件层面没有面临超订或者线程耗尽的威胁，运行期系统并无理由不去调度任务以并发方式执行。</p>
<p><strong>如果还想坚持默认，需要做的鲁棒性考量代码</strong></p>
<p>修正这个问题的方式并不难：<strong>校验<code>std::async</code>返回的期望值，确定任务是否被推迟，然后如果确实被推迟了，则避免进入基于超时的循环</strong>。</p>
<p>不幸的是，没有直接的办法来询问期望值任务是否被推迟了。作为替代手法，必须先调用一个基于超时的函数，例如<code>wait_for</code>。在此情况下，你其实并不是要等待任何事情，而只是要查看返回值是否为<code>std::future_status::deferred</code>，所以请搁置你的怀疑，径直调用一个超时为零的<code>wait_for</code>即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);           <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fut.<span class="built_in">wait_for</span>(<span class="number">0</span>s) ==             <span class="comment">//如果任务</span></span><br><span class="line">    std::future_status::deferred)   <span class="comment">//被推迟..</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ...             <span class="comment">//则使用fut的wait或get以异步方式调用f</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;            <span class="comment">//任务未被推迟</span></span><br><span class="line">    <span class="keyword">while</span> (fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) !=           <span class="comment">//不可能死循环</span></span><br><span class="line">            std::future_status::ready) &#123;    <span class="comment">//(前提假定f会结束)</span></span><br><span class="line"></span><br><span class="line">                ...                     <span class="comment">//任务既未被推迟，也未就绪，</span></span><br><span class="line">                                        <span class="comment">//则做并发工作，直至任务就绪</span></span><br><span class="line">            &#125;</span><br><span class="line">    ....                            <span class="comment">//fut 就绪</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>总体来说需要关注的点</strong></p>
<p>将上述诸种因素纳入考量的总体结论是：以默认启动策略对任务使用<code>std::async</code>能将正常工作需要满足以下所有条件：</p>
<ul>
<li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li>
<li>读&#x2F;写哪个线程的<code>thread_local</code>变量并无影响。</li>
<li>或者可以给出保证在<code>std::async</code>返回的期值之上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li>
<li>使用<code>wait_for</code>或<code>wait_until</code>的代码会将任务被推迟的可能性纳入考量。</li>
</ul>
<p><strong>另一种处理的视角</strong></p>
<p><strong>只要其中一个条件不满足，你就很可能想要确保任务以异步方式执行</strong>。实现这一点的手法，就是在调用时把<code>std::launch::async</code>作为第一个实参传递：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, f);       <span class="comment">//以异步方式启动f</span></span><br></pre></td></tr></table></figure>

<p>其实，如果有个函数能像<code>std::async</code>那样运作，只是它会自动使用<code>std::launch::async</code>作为启动策略，那将是个趁手的工具，而且很不错的是撰写这个函数一点不难。这是C++11版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span> std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Ts...)&gt;::type&gt;</span><br><span class="line"><span class="built_in">reallyAsync</span>(F&amp;&amp; f, Ts&amp;&amp; ... params)             <span class="comment">//返回异步所需的期值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">async</span>(std::launch::async,       <span class="comment">//调用f(params...)</span></span><br><span class="line">                        std::forward&lt;F&gt;(f),</span><br><span class="line">                        std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受一个可调用对象<code>f</code>，以及零个或多个形参params，并将后者完美转发（参见[Item 25]）给<code>std::async</code>，同时传递<code>std::launch::async</code>作为启动策略。就像<code>std::async</code>，它会返回一个类型为<code>std::future</code>的对象作为使用params调用f的结果。决定该结果的类型很容易，<code>std::result_of</code>这个类型特征就把结果给到你了（参见[Item 9]）。</p>
<p><code>reallyAsync</code>的用法就像<code>std::async</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">reallyAsync</span>(f);          <span class="comment">//以异步方式运行f</span></span><br><span class="line">                                    <span class="comment">//如果std::async会抛出异常</span></span><br><span class="line">                                    <span class="comment">//reallyAsync也会抛出异常</span></span><br></pre></td></tr></table></figure>

<p>在C++14中，对<code>reallyAsync</code>返回值进行推导类型的能力使函数声明得以简化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">auto</span>                                     <span class="comment">//C++14</span></span><br><span class="line"><span class="built_in">reallyAsync</span>(F&amp;&amp; f, Ts&amp;&amp; ... params)             </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">async</span>(std::launch::async,       </span><br><span class="line">                        std::forward&lt;F&gt;(f),</span><br><span class="line">                        std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一版本清清楚楚的显示，<code>reallyAsync</code>所做的一切，就是以<code>std::launch::async</code>启动策略来调用了<code>std::async</code>。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行。</td>
</tr>
<tr>
<td>2. 如此的弹性会导致使用<code>thread_local</code>变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的<code>wait</code>调用的程序逻辑。</td>
</tr>
<tr>
<td>3. 如果异步是必要的，则指定<code>std::launch::async</code>。</td>
</tr>
</tbody></table>
<h2 id="条款-37-使std-thread对象在所有路径上unjoinable"><a href="#条款-37-使std-thread对象在所有路径上unjoinable" class="headerlink" title="条款 37 使std::thread对象在所有路径上unjoinable"></a>条款 37 使std::thread对象在所有路径上unjoinable</h2><h3 id="1-区分是否可联结"><a href="#1-区分是否可联结" class="headerlink" title="1. 区分是否可联结"></a>1. 区分是否可联结</h3><p>每个<code>std::thread</code>对象皆处于两种状态之一：可联结（joinable）或不可联结（unjoinable）。</p>
<p><strong>哪些属于可联结</strong></p>
<p>可联结的<code>std::thread</code>对应底层以异步方式<strong>已运行</strong>或者<strong>可运行的线程</strong>。<code>std::thread</code>类型对象对应的底层线程若处于<strong>阻塞</strong>或<strong>等待调度</strong>，则它可联结。<code>std::thread</code>类型对象对应的底层线程如<strong>已运行结束</strong>，则也认为其可联结。</p>
<p><strong>哪些属于不可联结</strong></p>
<p>不可联结的<code>std::thread</code>的意思如你所想：<code>std::thread</code>不处于以上可联结的状态。不可联结的<code>std::thread</code>类型对象包括：</p>
<ul>
<li><strong>默认构造的std::thread</strong>。此类<code>std::thread</code>没有可以执行的函数，因此也没有对应的底层执行线程。</li>
<li><strong>已移动的std::thread</strong>。移动操作的结果是，一个<code>std::thread</code>所对应的底层执行线程（若有）被对应到另外一个<code>std::thread</code>。</li>
<li><strong>已联结的std::thread</strong>。联结后，<code>std::thread</code>类型对象不再对应至已结束运行的底层执行线程。</li>
<li><strong>已分离的std::thread</strong>。分离操作会把<code>std::thread</code>类型对象和它对应的底层执行线程之间的连接断开。</li>
</ul>
<h3 id="2-为何要求不可联结的直接原因"><a href="#2-为何要求不可联结的直接原因" class="headerlink" title="2. 为何要求不可联结的直接原因"></a>2. 为何要求不可联结的直接原因</h3><p><code>std::thread</code>可联结性之所以重要的原因之一是：<strong>如果可联结的线程对象的析构函数被调用，则程序的执行就终止了</strong>。</p>
<h4 id="2-1-举例说明"><a href="#2-1-举例说明" class="headerlink" title="2.1 举例说明"></a>2.1 举例说明</h4><p>举个栗子，假设我们有一个函数<code>doWork</code>，它接受一个筛选器函数<code>filter</code>和一个最大值<code>maxVal</code>作为形参。<code>doWork</code>会校验它做计算的条件全部成立，然后会针对筛选器选出的<code>0</code>到<code>maxVal</code>之间的值实施计算。如果筛选是费时的，而条件检验也是费时的，那么并发地做这两件事就是合理的。</p>
<p>我们会优先选用基于任务的设计（参见Item 35），但是让我们假定会去设置实施筛选的那个线程的优先级。Item 35解释过，这要求使用线程的低级句柄，从而只能通过<code>std::thread</code>的API来访问。基于任务的API（如期值）没有提供这个功能。</p>
<p>因此，我们只有采用基于线程的方式，基于任务在此不可行。</p>
<p>我们可能会撰写出这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10000000</span>;           <span class="comment">//关于constexpr参见Item 15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter,    <span class="comment">//返回值代表计算是否执行了</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> maxVal = tenMillion)</span>            <span class="comment">//关于function参见Item2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;filter, maxVal,&amp;goodVals]</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; i++)   </span></span></span><br><span class="line"><span class="params"><span class="function">            &#123; <span class="keyword">if</span> (filter(i))  goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">native_handle</span>();                <span class="comment">//使用t的低级句柄设定t的优先级</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">conditionsAreSatisfied</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();                               <span class="comment">//让t结束执行</span></span><br><span class="line">        <span class="built_in">performComputation</span>(goodVals);           </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                            <span class="comment">//计算已实施</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                               <span class="comment">//计算未实施</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的原型代码有诸多问题，以下一一道来：</p>
<p><strong>1. 更有可读性的写法</strong></p>
<p>在C++14中，单引号可以作为数字分隔符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10&#x27;000&#x27;000</span>;     <span class="comment">//C++14</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 线程开始之前设置优先级</strong></p>
<p>示例代码中在线程t开始执行之后才去设置它的优先级，这有点像，烈马已经脱缰跑走后才关上马厩的门。更好的设计是以暂停状态启动线程t。具体代码实例可以在Item39中进行查阅。这里为了不偏离主题，只是提到实例中的设计不好。</p>
<p><strong>3. 核心问题的地方</strong></p>
<p>如果<code>conditionsAreSatisfied()</code>返回<code>true</code>，则一切都好；但如果它返回<code>false</code>或抛出异常，那么在<code>doWork</code>的末尾调用<code>std::thread</code>类型对象t的析构函数是，它会处于可联结状态，从而<strong>导致程序执行终止</strong>。</p>
<p>你可能会想知道，<code>std::thread</code>的析构函数为何会这样运作。<strong>不终止程序难道不行吗？？</strong></p>
<p><strong>讲讲为什么析构函数要这么做</strong></p>
<p>因为别无选择，其他的选择比这么做更加糟糕，分别是：</p>
<ul>
<li><p><strong>隐式join</strong>。在这种情况下，<code>std::thread</code>的析构函数会等待底层异步执行线程完成。这听上去合理，但却可能导致<strong>难以追踪的性能异常</strong>。例如，如果<code>conditionsAreSatisfied()</code>早已返回<code>false</code>了，<code>doWork</code>却还在等待所有值上遍历筛选，这是违反直觉的。</p>
</li>
<li><p><strong>隐式detach</strong>。在这种情况下，<code>std::thread</code>的析构函数会分离<code>std::thread</code>类型对象与底层执行线程之间的连接。而该底层执行线程会继续执行。这听起来和<code>join</code>途径相比在合理性方面并不逊色，但它导致的调试问题会更加要命。例如，在<code>doWork</code>内<code>goodVals</code>是个通过引用捕获的局部变量，它会在<code>lambda</code>式内被修改（通过对<code>push_back</code>的调用）。然后，假如lambda式以异步方式运行时，<code>conditionsAreSatisfied()</code>返回了<code>false</code>。那种情况下，<code>doWork</code>会直接返回，它的局部变量（包括<code>goodVals</code>）会被销毁，<code>doWork</code>的栈帧会被弹出，可是线程却仍然在<code>doWork</code>的调用方继续运行着。</p>
</li>
</ul>
<p>在<code>doWork</code>调用方的后续语句中，在某个时刻，会调用其他函数，而至少会有一个函数可能会使用一部分或者全部<code>doWork</code>栈帧占用过的内存，假设这个函数称为<code>f</code>。当<code>f</code>运行时，<code>doWork</code>发起的lambda式依然在异步执行。该lambda式在原先的栈上对<code>goodVals</code>调用<code>push_back</code>，不过那已是在<code>f</code>的栈帧中了。这样的调用会修改过去属于<code>goodVals</code>的内存，而那意味着从<code>f</code>的视角看，栈帧上的内存内容会莫名其妙的被改变！想想看那样的问题，会多么酸爽。</p>
<p>综上所述，标准委员会意识到，销毁一个可联结的线程是在太过可怕，所以实际上<strong>已经封印了这件事</strong>（通过规定可联结的现成的析构函数导致程序异常终止）。</p>
<p><strong>你要关心的地方来了</strong></p>
<p>既然标准委员会把抉择权利给了你，如果你使用了<code>std::thread</code>类型对象，就必须确保从它定义的作用域出去的任何路径，使它成为不可联结状态。但是覆盖所有路径是复杂的，这包括正常走完作用域，还有经由<code>return</code>，<code>continue</code>，<code>break</code>，<code>goto</code>或异常跳出作用域。路径何其多。</p>
<p>任何时候，只要想在每条出向路径上都执行某动作，最常用的方法就是在局部对象的析构函数中执行该动作。这样的对象称为<code>RAII</code>对象，它们来自<code>RAII</code>类（<code>RAII</code>本身代表<code>Resource Acquistion Is Initialzation</code>，资源获取即初始化，即使该技术的关键其实在于析构而非初始化）。<code>RAII</code>类在标准库中很常见，例如STL容器（各个容器的析构函数都会析构容器内容并释放其内存）、标准智能指针（Item 18, Item 19, Item 20解释过，<code>std::unique_ptr</code>的析构函数会对它指涉的对象调用删除容器，而<code>std::shared_ptr</code>和<code>std::weak_ptr</code>的析构函数会对引用计数实施自减）、<code>std::fstream</code>类型对象（其析构函数会关闭对应的文件），还有很多。然而，没有和<code>std::thread</code>类型对象对应的标准<code>RAII</code>类，可能是<strong>因为标准委员会把join或detach用做默认选项的途径都堵死了，这么一来也就不知道真有这样的类的话该如何运作。</strong></p>
<h4 id="2-2-自己写一个RAII的std-thread"><a href="#2-2-自己写一个RAII的std-thread" class="headerlink" title="2.2 自己写一个RAII的std::thread"></a>2.2 自己写一个RAII的std::thread</h4><p>幸运的是，自己写一个也并不难。例如，下面这个类就允许调用者指定<code>ThreadRAII</code>类型对象（它是个<code>std::thread</code>对应的<code>RAII</code>对象）销毁时调用<code>join</code>还是<code>detach</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">DtorAction</span> &#123;join, detach&#125;;       <span class="comment">//关于枚举类，参见Item 10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a)   <span class="comment">//在析构函数中</span></span><br><span class="line">    : <span class="built_in">action</span>(a), <span class="built_in">t</span>(std::<span class="built_in">move</span>(t)) &#123;&#125;             <span class="comment">//在 t 上采取行动a</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;                     <span class="comment">//可联结性测试见下</span></span><br><span class="line">            <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">                t.<span class="built_in">join</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t;&#125;                  <span class="comment">//见下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DtorAction      action;</span><br><span class="line">    std::thread     t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>对于自己构建的类注意一下几点</strong></p>
<p>我希望这段代码基本上不言自明，但指出以下几点可能会有帮助：</p>
<p><strong><code>std::thread</code>是只移动类型</strong></p>
<ul>
<li>构造函数只接受右值类型的<code>std::thread</code>，因为我们想要把传入的<code>std::thread</code>类型对象移入<code>ThreadRAII</code>对象（提醒一下，<code>std::thread</code>是不可复制的）。</li>
</ul>
<p><strong>类中成员的声明顺序有讲究</strong></p>
<ul>
<li>读&#x2F;写哪个线程的<code>thread_local</code>变量并无影响。或者可以给出保证在<code>std::async</code>返回的期值之上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。使用<code>wait_for</code>或<code>wait_until</code>的代码会将任务被推迟的可能性纳入考量。构造函数的形参顺序的设计对于调用者而言是符合直觉的（指定<code>std::thread</code>作为第一个形参，而销毁行动作为第二个参数，比相反顺序更直观），但是，成员初始化列表的设计要求它匹配成员变量声明的顺序，而后者是把<code>std::thread</code>的顺序放到靠后的。在本类中，顺序不会导致不同，但作为一般讨论，一个成员变量的初始化有可能会依赖另一个成员变量，又<strong>因为<code>std::thread</code>类型对象初始化后可能会马上用来运行函数，所以把它们声明在类的最后是个好习惯</strong>。这保证了当<code>std::thread</code>类型对象在构造之时，所有在它之前的成员变量都已经完成了初始化，因而<code>std::thread</code>成员变量对应的底层异步执行线程可以安全地访问它们了。</li>
</ul>
<p><strong>提供一个<code>get</code>避免复写接口</strong></p>
<ul>
<li><code>ThreadRAII</code>提供了一个<code>get</code>函数，用以访问底层的<code>std::thread</code>类型对象。这和标准智能指针提供的<code>get</code>函数一样（后者用以访问底层裸指针）。提供<code>get</code>可以避免让<code>ThreadRAII</code>去重复<code>std::thread</code>的所有接口，也意味着<code>ThreadRAII</code>类型对象可以用于需要直接使用<code>std::thread</code>类型对象的语境。</li>
</ul>
<p><strong>析构的时候判断可联结性很重要</strong></p>
<ul>
<li><code>ThreadRAII</code>的析构函数在调用<code>std::thread</code>类型对象<code>t</code>的成员函数之前，会先实施校验，以确保<code>t</code>可联结。这是必要的，因为针对一个不可联结的线程调用<code>join</code>或者<code>detach</code>会产生未定义行为。用户有可能会构建了一个<code>std::thread</code>类型对象，然后从它出发创建一个<code>ThreadRAII</code>类型对象，再使用<code>get</code>访问<code>t</code>，接着针对<code>t</code>实施移动或是对<code>t</code>调用<code>join</code>或者<code>detach</code>，而这样的行为会使<code>t</code>变的不可联结。</li>
</ul>
<p>如果你担心下面的代码会有竞态风险：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.<span class="built_in">joinable</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由是，在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，另一个线程可能让<code>t</code>变得不可联结。你的直觉可圈可点，但你的担忧却是庸人自扰。</p>
<p>一个<code>std::thread</code>类型对象只能通过调用成员函数以从可联结状态转换为不可联结状态，例如<code>join</code>、<code>detach</code>或者移动操作。当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其他线程调用改对象的成员函数。如果同时发生多个调用，那的确会有竞态风险，但这竞态风险不是发生在析构函数内，而是发生在试图同时调用两个成员函数（一个是析构函数，一个是其他成员函数）的用户代码内。一般地，在一个对象之上同时调用多个成员函数，只有当所有这些函数都是<code>const</code>成员函数时才安全（参见Item 16）。</p>
<p>在我们的<code>doWork</code>一例中运用<code>ThreadRAII</code>，代码会长成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter,        <span class="comment">//同前</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> maxVal = tenMillion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;  goodVals;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::thread([&amp;filter, maxVal, &amp;goodVals]</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123; <span class="keyword">if</span> (filter(i)) goodVals.push_back(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;),</span></span></span><br><span class="line"><span class="params"><span class="function">            ThreadRAII::DtorAction::join</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> nh = t.<span class="built_in">get</span>().<span class="built_in">native_handle</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">conditionsAreSatisfied</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">get</span>().<span class="built_in">join</span>();</span><br><span class="line">        <span class="built_in">performComputation</span>(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该例子中，我们选择在<code>ThreadRAII</code>析构函数中对异步执行线程调用<code>join</code>。因为我们之前已经看到了，调用<code>detach</code>函数会导致噩梦般的调试。我们之前也看过<code>join</code>会导致性能异常（实话实说，<code>join</code>的调试也绝不令人愉悦），但未定义行为（<code>detach</code>导致的）、程序终止（使用裸<code>std::thread</code>产生的）和性能异常之间做出选择，性能异常也是权衡之下的弊端最小的一个。</p>
<p>可遗憾的是，使用<code>ThreadRAII</code>在<code>std::thread</code>析构中实施<code>join</code>不是仅仅会导致性能异常那么简单，而是会导致程序失去响应。这种问题的“合适的”解决方案是和异步执行的lambda式通信，当我们已经不再需要它运行，它应该提前返回，但C++11中并不支持这种可中断线程。我们可以手动实现它，但这个话题不展开，可以在《C++ Concurrency in Action》的9.2节中找到答案。</p>
<p>Item 17解释过，因为<code>ThreadRAII</code>声明了析构函数，所以不会有编译器生成的移动操作，但这里<code>ThreadRAII</code>对象没有理由实现为不可移动的。如果编译器会生成这些函数，这些函数的行为就是正确的，所以显示地请求创建它们是适当的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">DtorAction</span> &#123;join, detach&#125;;       <span class="comment">//同前</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a)   <span class="comment">//同前</span></span><br><span class="line">    : <span class="built_in">action</span>(a), <span class="built_in">t</span>(std::<span class="built_in">move</span>(t)) &#123;&#125;             <span class="comment">//同前</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;                     <span class="comment">//同前</span></span><br><span class="line">            <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">                t.<span class="built_in">join</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.<span class="built_in">detach</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ThreadRAII</span>(ThreadRAII&amp;&amp; ) = <span class="keyword">default</span>;                <span class="comment">//支持移动构造</span></span><br><span class="line">    ThreadRAII&amp; <span class="keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="keyword">default</span>;      <span class="comment">//支持移动赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t;&#125;                  <span class="comment">//同前</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DtorAction      action;</span><br><span class="line">    std::thread     t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 使<code>std::thread</code>类型对象在所有路径皆不可联结。</td>
</tr>
<tr>
<td>2. 在析构时调用<code>join</code>可能导致难以调试的性能异常。</td>
</tr>
<tr>
<td>3. 在析构时调用<code>detach</code>可能导致难以调试的未定义行为。</td>
</tr>
<tr>
<td>4. 在成员列表的最后声明<code>std::thread</code>类型对象。</td>
</tr>
</tbody></table>
<h2 id="条款-38-对变化多端的线程句柄析构函数行为保持关注"><a href="#条款-38-对变化多端的线程句柄析构函数行为保持关注" class="headerlink" title="条款 38 对变化多端的线程句柄析构函数行为保持关注"></a>条款 38 对变化多端的线程句柄析构函数行为保持关注</h2><h3 id="1-线程析构函数"><a href="#1-线程析构函数" class="headerlink" title="1. 线程析构函数"></a>1. 线程析构函数</h3><p>Item 37解释过，可联结的线程对应着一个底层系统执行线程，未推迟任务（参见Item 36）的期值和系统线程也有类似关系。这么一来，<code>std::thread</code>类型对象和<code>std::future</code>对象都可以视作系统线程的句柄。</p>
<p><strong>重温<code>std::thread</code>的析构表现</strong></p>
<p>针对可联结的<code>std::thread</code>类型对象实施析构会导致程序终止，因为另外两个显而易见的选择（隐式join或者detach）都被认为是更糟糕的选择。</p>
<p><code>std::future</code>的析构函数表现</p>
<p>期值位于信道的一端，被调方把结果通过该信道传输给调用方。被调方（通常以异步方式运行）把其计算所得的结果写入信道（通道经由一个<code>std::promise</code>类型对象），而调用方则使用一个期值来读取该结果。</p>
<p><strong>被调方的结果到底应该存在哪里</strong></p>
<ol>
<li>不是在<code>std::promise</code>中</li>
</ol>
<p>但被调方的结果要存储在哪里呢？在调用方唤起对应期值的<code>get</code>之前，被调方可能已经执行完毕，因此结果不会存储在被调方的<code>std::promise</code>对象里。那个对象，对于被调方来说是个局部量，在被调方结束后会实施析构。</p>
<ol start="2">
<li>不是在调用方的期值中</li>
</ol>
<p>该结果也不能存储在调用方的期值中，因为（出于其他种种原因）可能会从<code>std::future</code>类型对象触发创建<code>std::shared_future</code>类型对象（因此把被调方结果的所有权从<code>std::future</code>类型对象转移至<code>std::shared_future</code>类型对象），而后者可能会在原始的<code>std::future</code>析构之后复制多次。如果被调方的结果类型不都是可复制的（即只移类型），而该结果至少生存期要延至和最后一个指涉到它的期值一样长。这么多对应同一结果的期值中的哪一个，应该包含该结果呢？</p>
<p><strong>被调放的结果存在这里</strong></p>
<p>已经否定了上述两者的可能性，那么被调方实际上存在两者之外的某个位置。这个位置成为共享状态。<strong>共享状态通常使用堆上的对象来表示</strong>，但是其类型，接口和实现标准皆未指定。标准库作者可以自由地用他们的喜好的方式去实现共享状态。</p>
<p>共享状态的存在很重要，因为期值析构函数行为（这也是本条的议题）是由与其关联的共享状态决定的，总体来说：</p>
<p><strong>析构函数的行为总结</strong></p>
<ul>
<li><p><strong>指涉到经由<code>std::async</code>启动的未推迟任务的共享状态（<code>std::lauch::async</code>）的最后一个<code>std:future</code>会保持阻塞，直到该任务结束</strong>。本质上，这样一个期值的析构函数是对底层异步执行任务的线程实施了一次隐式<code>join</code>。</p>
</li>
<li><p><strong>其他所有期值对象的析构函数只仅仅将期值对象析构就结束了</strong>。对于底层异步运行的任务，这样做类似于对线程实施了一次隐式<code>detach</code>。对于那些被推迟任务而言，如果这一期值是最后一个，也就意味着被推迟的任务将不会有机会运行了。</p>
</li>
</ul>
<h3 id="2-析构函数行为"><a href="#2-析构函数行为" class="headerlink" title="2. 析构函数行为"></a>2. 析构函数行为</h3><p>这些规则听上去复杂，其实不然。我们真正要关心的，是一个平凡的“常规”行为外加一个不常见的例外而已。</p>
<p><strong>常规行为</strong>：期值的析构函数仅会析构期值对象。就这样。它不会针对任何东西实施<code>join</code>，也不会从任何东西实施<code>detach</code>，也不会<strong>运行任何东西</strong>。它仅会析构期值的成员变量。（另一个无关紧要的操作，它还多做了一件事，它针对共享状态里的引用计数实施了一次自减。该共享状态由指涉到它的期值和被调方的<code>std::promise</code>共同操纵。该引用计数使得库能够知道何时可以析构共享状态。关于引用计数材料，参见Item 19）。</p>
<p><strong>例外行为</strong>：而相对正常行为的那个例外，只有在期值满足以下<strong>全部条件</strong>时才会发挥作用。</p>
<ul>
<li><p><strong>期值所指涉的共享状态是由于调用了<code>std::async</code>才创建的</strong>。</p>
</li>
<li><p>**该任务的启动策略是<code>std::launch::async</code>**，参见Item 36，这极可能是运行时系统的选择，也可能是在调用<code>std::async</code>时指定的。</p>
</li>
<li><p><strong>该期值是指涉到该共享状态的最后一个期值</strong>。对于<code>std::future</code>类型对象而言，这一点总是成立。而对于<code>std::shared_future</code>类型对象而言，在析构时如果不是最后一个指涉到共享状态的期值，则它会遵循正常行为准则（即仅析构其成员变量）。</p>
</li>
</ul>
<p>只有当所有条件都满足，期值的析构函数才会表现出特别行为。而行为的具体表现为：</p>
<blockquote>
<p>阻塞直到异步运行的任务结束。</p>
</blockquote>
<p>从效果来看，这相当于针对正在运行的<code>std::async</code>所创建的任务的线程实施了一次隐式<code>join</code>。</p>
<p>经常会有人把这个例外和常规期望析构函数的行为的差异说成这样：</p>
<blockquote>
<p>来自<code>std::async</code>的期值会在其析构函数里被阻塞。</p>
</blockquote>
<p>如果只是<strong>最粗略的近似</strong>，这种说法也不为错。但有时候你需要比最粗略的近似了解的更深入一些。而现在，你就已经全部了解了。</p>
<h3 id="3-究其原因"><a href="#3-究其原因" class="headerlink" title="3. 究其原因"></a>3. 究其原因</h3><p>抑或你的疑问又并不同，可能会是</p>
<blockquote>
<p> “为什么要为从<code>std::async</code>触发启动的非推迟任务相关联的共享状态专门制定一条规则？”</p>
</blockquote>
<p>这个问题十分合理。根据我所知道的，标准委员会想要避免隐式<code>detach</code>相关的问题（参见Item 37），但他们又不想简单粗暴地让程序终止了事（他们针对可联结线程就是这样做的，参见Item 37），所以妥协结果就是实施一次隐式<code>join</code>。</p>
<p>这个决定并非没有争议，委员会也曾认真讨论过要在C++14中舍弃这样的行为。但是最后没有做出改变，所以期值析构函数的行为在C++11和C++14中保持了一致的。</p>
<p>期值的API没有提供任何方法判断其指涉的共享状态是否诞生于<code>std::async</code>的调用，所以<strong>给定任意期值对象的前提下，它不可能知道自己是否会在析构函数中阻塞到异步任务执行结束</strong>。</p>
<p>这个事实暗示着一些意味深长的推论：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该容器的析构函数可能会在其析构函数中阻塞</span></span><br><span class="line"><span class="comment">// 因为它所持有的期值中可能会有一个或多个</span></span><br><span class="line"><span class="comment">// 指涉到经由std::async启动未推迟任务所产生的共享状态</span></span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....         <span class="comment">// Widget类型对象可能会在其析构函数中阻塞</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_future&lt;<span class="type">double</span>&gt; fut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，如果有办法判定给定的期值不满足触发特殊析构行为的条件（例如，通过分析程序逻辑），即可断定该期值不会阻塞在其析构函数中。例如，<strong>只有因<code>std::async</code>调用而出现的共享状态才够格去展示特别行为</strong>，但还有其他方式可以创建出共享状态。</p>
<h3 id="4-回避之法"><a href="#4-回避之法" class="headerlink" title="4. 回避之法"></a>4. 回避之法</h3><p>其中一个方法就是运用<code>std::packaged_task</code>，<code>std::packaged_task</code>类型对象会准备一个函数（或其他可调用的对象）以供异步执行，手法是将它加上一层包装，把其结果置入共享状态。而指涉到该共享状态的期值则可以经由<code>std::packaged_task</code>的<code>get_future</code>函数得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcValue</span><span class="params">()</span></span>;    <span class="comment">// 待运行函数</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">pt</span><span class="params">(calcValue)</span></span>;    <span class="comment">// 给calcValue加上使之能以异步方式运行</span></span><br><span class="line"><span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>();     <span class="comment">// 取得pt的期值</span></span><br></pre></td></tr></table></figure>

<p>此时此刻，我们已知期值对象<code>fut</code>没有指涉到由<code>std::async</code>调用产生的共享状态，所以它的析构函数将表现出正常行为。</p>
<p><code>std::packaged_task</code>不能复制，所以欲将<code>pt</code>传递给<code>std::thread</code>的构造函数就一定要将它强制转型到右值（经由<code>std::move</code>，参见Item 23）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>;       <span class="comment">//在t之上运行pt</span></span><br></pre></td></tr></table></figure>

<p>此例让我们能够隐约看出一些期值的常规析构行为，但如果把这些语句都放在统一代码块中，就可以看得更清楚：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;               <span class="comment">//代码块开始</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">pt</span><span class="params">(calcValue)</span></span>;    <span class="comment">// 给calcValue加上使之能以异步方式运行</span></span><br><span class="line">    <span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>();     <span class="comment">// 取得pt的期值</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>; </span><br><span class="line">    ...             <span class="comment">//见下</span></span><br><span class="line">&#125;               <span class="comment">//代码块结束</span></span><br></pre></td></tr></table></figure>

<p>这里最值得探讨的代码是”…“部分，它位于<code>t</code>创建之后、代码块结束之前。值得探讨的是，在”…”中<code>t</code>的命运如何。基本存在三种可能：</p>
<ul>
<li><p><strong>未对t实施任何操作</strong>。在这种情况下，t在作用域结束点是可联结的，而这将导致程序终止（参见Item 37）。</p>
</li>
<li><p><strong>针对t实施了join</strong>。在此情况下，fut无需在析构函数中阻塞，因为在调用的代码已经有过join。</p>
</li>
<li><p><strong>针对t实施了detach</strong>。在此情况下，fut无需在析构函数中实施detach，因为在调用的代码已经做过这样的事情了。</p>
</li>
</ul>
<p>换句话说，当你的期值所对应的共享状态是由<code>std::packaged_task</code>产生的，则通常无需采用特别析构策略。因为，关于是终止，联结还是分离的决定，会由操纵<code>std::thread</code>的代码作出，而<code>std::packaged_task</code>通常就运行在该线程上。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 期值的析构函数在常规情况下，仅会析构期值的成员变量。</td>
</tr>
<tr>
<td>2. 指涉到经由<code>std::async</code>启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。</td>
</tr>
</tbody></table>
<h2 id="条款39-线程间一次性通信考虑使用std-future"><a href="#条款39-线程间一次性通信考虑使用std-future" class="headerlink" title="条款39 线程间一次性通信考虑使用std:future"></a>条款39 线程间一次性通信考虑使用std:future</h2><p>有时候，提供让一个任务通知另一个以异步方式运行的任务发生了特定的事件的能力，会很有用，原因可能是第二个任务在事件发生之前无法推进。这事件也许是某个数据结构完成了初始化，也许是某个计算阶段结束了，又也许是某个重要传感器取值被检测到了等等。在此情况下，用什么方式完成线程间通信会是最佳的呢？</p>
<h3 id="1-使用条件变量"><a href="#1-使用条件变量" class="headerlink" title="1. 使用条件变量"></a>1. 使用条件变量</h3><p><strong>一种明显的途径是使用条件变量</strong>，若我们把检测条件的任务成为检测任务，把对条件做出反应的任务成为反应任务，则策略表述起来很简答：反应任务等待这条件变量，而检测任务则在事件发生时，通知条件变量。给定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;     <span class="comment">//事件的条件变量</span></span><br><span class="line">std::mutex              m;      <span class="comment">//在运用cv时，给它加的互斥量</span></span><br></pre></td></tr></table></figure>

<p>检测任务的代码真的简单到不能再简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">....                            <span class="comment">//检测事件</span></span><br><span class="line">cv.<span class="built_in">notify_one</span>();                <span class="comment">//通知反应任务</span></span><br></pre></td></tr></table></figure>

<p>如果有多个反应任务需要通知到，那么使用 <code>notify_all</code> 替换 <code>notify_one</code> 才合适，但现在不妨假设只有一个反应任务。</p>
<p>反应任务的代码稍显复杂，因为在条件变量之上调用 <code>wait</code> 之前，必须通过 <code>std::unique_lock</code> 类型对象锁定互斥量（在等待条件变量之前锁定互斥量，对于线程库来说是典型操作。而通过<code>std::unique_lock</code>对象完成锁定互斥量的需求，是C++11在API中所提供的功能）。下面展示了概念上应该如何实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....                                            <span class="comment">//准备反应</span></span><br><span class="line">&#123;                                               <span class="comment">//临界区域开始</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;         <span class="comment">//为互斥量加锁</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk);                                <span class="comment">//等待通知到来</span></span><br><span class="line">    ......                                      <span class="comment">//这里会出错！</span></span><br><span class="line">                                                <span class="comment">//针对事件做出反应（m被锁定）</span></span><br><span class="line">&#125;                                               <span class="comment">//临界区域结束</span></span><br><span class="line">                                                <span class="comment">//通过lk的析构函数为m解锁</span></span><br><span class="line">....                                            <span class="comment">//继续等待反应</span></span><br><span class="line">                                                <span class="comment">//（m已解锁）</span></span><br></pre></td></tr></table></figure>

<p>这种途径的第一个问题有时被称为代码异味 <code>Code Smell</code> : <em><strong>即使代码能够一时运作，某些东西似乎也不太对劲</strong></em>。在本例中，异味源自于需要使用互斥体。互斥体是用于控制共享数据访问的，但检测和反应任务之间打有可能根本不需要这种介质。例如，检测任务可能会负责初始化一个全局数据结构，然后把它转交给反应任务使用。<strong>如果检测任务在初始化之后，从不访问该数据结构，并且在检测任务指示它已就绪之前，反应任务从不访问它，那么根据程序逻辑，这里两个任务将会相互阻止对方访问，根本不需要什么互斥量</strong>。采用条件变量这一途径却要求必须有个互斥量，这个事实就为设计留下了令人生疑和不安的气息。</p>
<p>即使对此视而不见，还有两个问题是无论如何都需要关切的：</p>
<ul>
<li><p><strong>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量</strong>，则反应任务将失去响应。为了实现通知条件变量唤醒另一个任务，该任务必须已在等待该条件变量。如果检测任务在响应任务执行<code>wait</code>之前就执行了通知动作，则反应任务就将错过该通知，并且将等待到天荒地老。</p>
</li>
<li><p><strong>反应任务的<code>wait</code>语句无法应对虚假唤醒</strong>。线程API的存在一个事实情况(很多语言中都如此，不仅仅是C++)，<strong>即使没有通知条件变量，针对该条件变量等待的代码也可能被唤醒。这样的唤醒成为虚假唤醒</strong>。正确的代码通过确认等待的条件确实已经发生，并将其作为唤醒后的收割动作来处理这种情况。C++的条件变量API使得做到一点异常简单，因为它允许测试等待条件的lambda式（或其他函数对象）被传递给<code>wait</code>。换言之，反应任务中调用<code>wait</code>事可以这样写：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> 事件是否确已发生;&#125;);</span><br></pre></td></tr></table></figure>

<p>想要利用这项能力，就要求反应任务能够确认它所等待的条件是否成立。但是在我们考虑的上述场景中，是由检测线程负责识别它所等待的条件是否因为对应的事件发生导致的。反应线程可能无法确认它正在等待的事件是否已经发生。这也是为什么它等待的是个条件变量！</p>
<p>在许多情况下，使用条件变量进行任务间通信是对于所面对问题的适当解法，但我们现在看的这问题似乎并非其中之一。</p>
<h3 id="2-使用共享的布尔标志位"><a href="#2-使用共享的布尔标志位" class="headerlink" title="2. 使用共享的布尔标志位"></a>2. 使用共享的布尔标志位</h3><p>许多软件工程师的<strong>下一个锦囊妙计是使用共享的布尔标志位</strong>。该标志位的初始值是<code>false</code>。当检测线程识别出它正在查找的事件时，会设置该标志位：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt;  <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;         <span class="comment">//共享的布尔标志位</span></span><br><span class="line">                                        <span class="comment">//关于std::atomic，详见Item 40</span></span><br><span class="line">....                                    <span class="comment">//检测事件</span></span><br><span class="line">flag = <span class="literal">true</span>;                            <span class="comment">//通知反应任务</span></span><br></pre></td></tr></table></figure>

<p>在这一途径中，反应线程只是会轮询标志位。一旦看到该标志被设置时，就知道它正在等待的事件已经发生了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">....                <span class="comment">//准备反应</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag);       <span class="comment">//等待事件</span></span><br><span class="line"></span><br><span class="line">....                <span class="comment">//针对事件作出反应</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方法没有任何基于条件变量的设计的缺点。也不需要互斥体。如果检测任务在反应任务开始之前就设置了标志位，也没有任何问题。并且虚假唤醒的毛病也不见了。这个办法的确还是很不错的。</p>
<p>可是不那么好的地方在于，<strong>反应任务的轮询成本高昂</strong>。在任务等待标志位被设置的时候，它实质上应该被阻塞，但却仍然在运行。因此，它就占用了另一个任务本应该能够利用的硬件线程，而且<strong>在每次开始运行以及其时间片结束时，都会产生语境切换的成本</strong>。它还可能会让<strong>一颗硬件核心持续运行，而那颗核心本来可以关掉以节省电能</strong>。<code>真正处于阻塞状态的任务不会耗用所有以上这些</code>。这倒是基于条件变量的途径的一个优点，因为等待调用的任务会真正地被阻塞。</p>
<h3 id="3-结合条件变量和基于标志位的设计"><a href="#3-结合条件变量和基于标志位的设计" class="headerlink" title="3. 结合条件变量和基于标志位的设计"></a>3. 结合条件变量和基于标志位的设计</h3><p>常用的手法是结合条件变量和基于标志位的设计。标志位表示是否发生了有意义的事件，但是访问该标志需要通过互斥量加以同步。因为互斥锁会阻止并发访问该标志位，所以，如<code>Item 40</code>所说，不需要该标志位采用<code>std::atomic</code>类型对象来实现，一个平凡的布尔量足矣。这么一来，检测任务会写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::condition_varialbe  cv;            <span class="comment">//同前</span></span><br><span class="line">std::mutex  m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;                       <span class="comment">//非std::atomic类型对象</span></span><br><span class="line">....                                    <span class="comment">//检测事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt;  <span class="title">g</span><span class="params">(m)</span></span>;  <span class="comment">//经由g的构造函数锁定m</span></span><br><span class="line"></span><br><span class="line">    flag = <span class="literal">true</span>;                        <span class="comment">//通知反应任务（第一部分）</span></span><br><span class="line">&#125;                                       <span class="comment">//经由g的析构函数解锁m</span></span><br><span class="line">cv.<span class="built_in">notify_one</span>();                        <span class="comment">//通知反应任务（第二部分）</span></span><br></pre></td></tr></table></figure>

<p>以下是反应任务的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">....                                        <span class="comment">//准备反应</span></span><br><span class="line">&#123;                                           <span class="comment">//同前</span></span><br><span class="line">    <span class="function">std::unqiue_lock&lt;std::mutex&gt;  <span class="title">lk</span><span class="params">(m)</span></span>;    <span class="comment">//同前</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> flag;&#125;);          <span class="comment">//使用lambda式应对虚假唤醒</span></span><br><span class="line">    .....                                   <span class="comment">//针对事件做出反应</span></span><br><span class="line">                                            <span class="comment">//(m被锁定)</span></span><br><span class="line">&#125;</span><br><span class="line">......                                      <span class="comment">//继续等待反应</span></span><br><span class="line">                                            <span class="comment">//（m已解锁）</span></span><br></pre></td></tr></table></figure>

<p>采用这一途径，可以避免我们之前讨论的问题。<strong>它能够运作，在检测任务通知之前响应任务就开始等待也没关系，在存在虚假唤醒的前提下也不影响，而且不需要轮询</strong>。然而，还是有一丝异味存在，因为探测任务和反应任务的沟通方式非常奇特。通知条件变量在这里的目的是告诉反应任务，它正在等待的事件可能已经发生了，然而反应任务必须检查标志位才能确定。设置标志位在这里的目的是告诉反应任务事件确确实实已经发生了，但是检测任务仍然需要通知条件变量才能让反应任务被唤醒并去检查标志位。这一途径是能够运作的，但是不够干净利落。</p>
<h3 id="4-让反应任务去等待检查任务设置的期值"><a href="#4-让反应任务去等待检查任务设置的期值" class="headerlink" title="4. 让反应任务去等待检查任务设置的期值"></a>4. 让反应任务去等待检查任务设置的期值</h3><p>另一种方法是摆脱条件变量，互斥量和标志位，方法是<strong>让反应任务去等待检查任务设置的期值</strong>。这看似是一种怪异的想法。毕竟，Item 38 曾经解释说，期值代表了从被调者到通常以异步方式运行的）调用者的信道接收端，在检测和反应任务之间并不存在这种调用关系和被调用者的关系。不过，Item 38又指出，发送端是<code>std::promise</code>类型对象，并且其接收端是期值的通信信道用途不止于调用者和被调用者一种。这种信道可以用于任何需要将信息从一处传输到另一处的场合。在本例中，我们将它用来将信息从检测任务传输到响应任务，传达信息则是有意义的事件已经发生。</p>
<p><strong>这种设计简单易行</strong>。检测任务有一个<code>std::promise</code>类型对象（即，信道的写入端），反应任务有对应的期值。当检测任务发现它正在查找的事件已经发生时，它会设置反应任务有对应的期值。当检测任务发现它正在查找的事件已经发生时，它会设置<code>std::promise</code>类型对象（即，向信道写入）。与此同时，反应任务调用<code>wait</code>以等待它的期值。该<code>wait</code>调用会阻塞反应任务直至<code>std::promise</code>类型对象被设置为止。</p>
<p>在这里的<code>std::promise</code>和期值（即<code>std::future</code>和<code>std::shared_future</code>）都是需要类型形参的模板。该形参表示的是要通过信道发送数据的类型。<strong>在本例中，却没有数据要传送。对于反应任务有意义的唯一事情，就是它的期值是否被设置</strong>。我们所需要的<code>std::promise</code>和期值模板是一种表示没有数据要通过信道传送的那么一种类型。那种类型就是<code>void</code>。因此，检测任务将使用<code>std::promise&lt;void&gt;</code>，并且反应任务将使用<code>std::future&lt;void&gt;</code>或 <code>std::shared_future&lt;void&gt;</code>。当有意义的事件发生时，检测任务将设置其<code>std::promise&lt;void&gt;</code>，反应任务将等待其期值。即使反应任务不会接收任何来自检测任务的数据，信道也会允许反应任务通过在其<code>std::promise</code>类型对象上调用<code>set_value</code>来了解检测任务何时<code>写入</code>了其void类型的数据。</p>
<p>所以，给定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt;  p;      <span class="comment">// 信道的约值</span></span><br></pre></td></tr></table></figure>

<p>检测任务的代码是平凡的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...                         <span class="comment">// 检测事件</span></span><br><span class="line">p.<span class="built_in">set_value</span>();              <span class="comment">// 通知反应任务</span></span><br></pre></td></tr></table></figure>

<p>而反应任务的代码也同样平平无奇：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">....                        <span class="comment">// 准备反应</span></span><br><span class="line">p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();      <span class="comment">// 等待p对应的期值</span></span><br><span class="line">...                         <span class="comment">// 针对事件作出反应</span></span><br></pre></td></tr></table></figure>

<p>就像使用标志位的途径一样，这个设计也不需要互斥量，检测任务是否在响应任务等待之前设置它的<code>std::promise</code>都可以，并且对虚假唤醒免疫（只有条件变量会不能应对虚假唤醒）。也像基于条件变量的途径一样，在调用<code>wait</code>之后，反应任务真正被阻塞，所以在等待时不会消耗系统资源。完美，对不对？</p>
<p>不对！。当然，基于期值的途径可以绕开前面那些险滩，但仍不免于其他一些陷阱。例如，Item 38就解释过，<code>std::promise</code>和期值之间是共享状态，而共享状态通常是动态分配的。因此，你就得假设这种设计会招致在堆上进行分配和回收的成本。</p>
<p><strong>可能这一点是最重要的</strong>：<code>std::promise</code>类型对象只能设置一次。<code>std::promise</code>类型对象和期值之间的通信信道是个一次性机制：<strong>它不能重复使用</strong>。这是它基于条件变量和基于标志位的设计之间的明显差异，前两者都可以用来进行多次通信（条件变量可以被重复通知，标志位可以被清除并重新设置）。</p>
<p>一次性这一约束并不像你可能想象的先知那么大。假设你想创建一个暂停状态的系统线程。也就是说，你希望一开始就把与创建线程相关的所有开销都提前付清，而后一旦要在线程上执行某些操作时即可避免常规的线程创建延迟了。又或者你可能想创建一个暂停的线程，以便在它运行之前先对其实施一些配置动作。这样的配置可能包括诸如设置其优先级或内核亲和性之类。C++并发API并未提供做这些事情的方法，但<code>std::thread</code>类型对象提供了<code>native_handle</code>成员函数，意在让你得以以访问平台的底层线程API（通常是<code>POSIX</code>线程或者<code>Windows</code>线程）。低级API通常能够配置像优先级和亲和性这样的线程特性。</p>
<h3 id="5-使用期值Demon"><a href="#5-使用期值Demon" class="headerlink" title="5. 使用期值Demon"></a>5. 使用期值Demon</h3><p>假定你只想暂停线程一次（在它创建之后，但在它运行其他线程函数之前），使用<code>void</code>期值的设计就是合理的选择。下面是该技术的重要部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt;   p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">react</span><span class="params">()</span></span>;                                   <span class="comment">// 反应任务的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span>                                   <span class="comment">// 检测任务的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]                            <span class="comment">// 创建线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                      p.get_future().wait();    <span class="comment">// 暂停 t</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      react();                  <span class="comment">// 直至其期值被设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  &#125;)</span></span>;</span><br><span class="line">    ....                                        <span class="comment">// 这里t出于暂停状态，在调用react之前</span></span><br><span class="line">    p.<span class="built_in">set_value</span>();                              <span class="comment">// 取消暂停t（调用react）</span></span><br><span class="line">    ....                                        <span class="comment">// 做其他工作</span></span><br><span class="line">    t.<span class="built_in">join</span>();                                   <span class="comment">// 置t于不可联结状态（参见Item 37）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使<code>t</code>在所有<code>detect</code>的出向路径上都置为不可联结这件事很重要，所以使用 Item 37 中像<code>ThreadRAII</code>那样的<code>RAII</code>类应该是可取的。于是，你可能会脑补出这么一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">tr</span><span class="params">(                          <span class="comment">// 使用RAII对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::thread([]</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        p.get_future().wait();</span></span></span><br><span class="line"><span class="params"><span class="function">                        react();</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;),</span></span></span><br><span class="line"><span class="params"><span class="function">        ThreadRAII::DtorAction::join        <span class="comment">// 这里以后风险！（见下）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    ....                                    <span class="comment">// tr内的线程在此处被暂停</span></span><br><span class="line">    p.<span class="built_in">set_value</span>();                          <span class="comment">// tr内的线程在此处被取消暂停</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不像看上去那么安全。问题在于第一个<code>....</code>区域（带有<code>// tr内的线程在此处被暂停</code>注释的那个），如果抛出异常的话，<code>set_value</code>便永远不会在<code>p</code>上调用。</p>
<p>这意味着，在lambda式内部调用的<code>wait</code>将永远不会返回。但这，反过来又意味着，运行lambda式的线程将永远不会完成，这是个问题，因为RAII对象<code>tr</code>已被配置为在<code>tr</code>析构函数中针对该线程执行<code>join</code>。换而言之，如果从代码的第一个<code>....</code>区域抛出异常，<strong>这个函数将失去响应（也就是卡死了）</strong>，因为<code>tr</code>的析构函数将永远不会完成。</p>
<p>有很多种方法可以解决该问题，但这里并不暂开描述。这里，如何对原始代码（即，不使用ThreadRAII）加以扩充，使之可以<strong>针对不止一个，可以是很多个反应任务实施先暂停再取消暂停的功能</strong>。</p>
<p>这个拓展不难，因为关键之处在于在<code>react</code>的代码中使用<code>std::shared_future</code>而非<code>std::future</code>。一旦你了解到，<code>std::future</code>的<code>share</code>成员函数是把共享状态的所有权转移给了由<code>share</code>生成的<code>std::shared_future</code>类型对象，代码也就自己呼之欲出了。唯一的微妙之处就是，每个反应线程都需要自己的那份<code>std::shared_future</code>副本去指涉到共享状态，所以，从<code>share</code>中获取的<code>std::shared_future</code>被运行在反应线程上的lambda式按值捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt;  p;                  <span class="comment">//同前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span>                           <span class="comment">//现在可以处理多个反应任务了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sf = p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();   <span class="comment">//sf的类型是</span></span><br><span class="line">                                        <span class="comment">//std::shared_future&lt;void&gt;</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; vt;        <span class="comment">//反应任务的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadsToRun; ++i) &#123;</span><br><span class="line">        vt.<span class="built_in">emplace_back</span>([sf]&#123;</span><br><span class="line">            sf.<span class="built_in">wait</span>();                  <span class="comment">//sf局部副本之上的wait</span></span><br><span class="line">            <span class="built_in">react</span>();                    <span class="comment">//关于emplace_back，详见Item 42</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ....                                <span class="comment">//若此&quot;....&quot;抛出异常，则detect会失去响应！</span></span><br><span class="line">    p.<span class="built_in">set_value</span>();                      <span class="comment">//让所有线程取消暂停</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;                <span class="comment">//把所有线程置为不可联结状态</span></span><br><span class="line">        t.<span class="built_in">join</span>();                       <span class="comment">//auto&amp;的详情，参见Item 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用期值的设计能够实现这样的效果，此事实值得注意，这也是为何应该将一次性事件通信纳入考量的原因。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务检验事件确已发生。</td>
</tr>
<tr>
<td>2. 使用标志位的设计可以避免上述问题，但这一设计基于轮询而非阻塞。</td>
</tr>
<tr>
<td>3. 条件变量和标志位可以一起使用，但这一昂的通信机制设计结果不甚自然。</td>
</tr>
<tr>
<td>4. 使用<code>std::promise</code>类型对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信。</td>
</tr>
</tbody></table>
<h2 id="条款40-并发使用std-atomic，特种内存使用volatile"><a href="#条款40-并发使用std-atomic，特种内存使用volatile" class="headerlink" title="条款40 并发使用std::atomic，特种内存使用volatile"></a>条款40 并发使用std::atomic，特种内存使用volatile</h2><h3 id="1-volatile介绍"><a href="#1-volatile介绍" class="headerlink" title="1. volatile介绍"></a>1. volatile介绍</h3><p>可怜的<code>volatile</code>。被误解到如此地步。它甚至不应该出现在本章中，<strong>因为它与并发程序设计毫无关系</strong>。但是在其他程序设计语言中（例如 <code>Java</code> 和 <code>C#</code> ），它还是会对并发程序设计有些用处。甚至在C++中，一些编译器也已经把<code>volatile</code>投入了染缸，使得它的语义显得可以用于并发软件中（但是仅可能用于使用这些编译器进行编译之时）。</p>
<p>因此，<strong>除了消除环绕在它周围的混淆视听外</strong>，没有什么其他的理由值得在关于并发的一章中讨论<code>volatile</code>。</p>
<p>程序员有时会把<code>volatile</code>与绝对属于本章讨论范围的另一C++特性混淆，那就是<code>std::atomic</code>模板。该模板的实例（例如，<code>std::atomic&lt;int&gt;</code>、<code>std::atomic&lt;bool&gt;</code>和<code>std::atomic&lt;Widget* &gt;</code>等）提供的操作可以保证被其他线程视为原子的。一旦构造了一个<code>std::atomic</code>类型对象，针对它的操作就好像这些操作处于受互斥量保护的临界区域一样 ，但是实际上这些操作通常会使用特殊的机器指令来实现，<strong>这些指令比使用互斥量来的更加高效</strong>。</p>
<h3 id="2-std-atomic介绍"><a href="#2-std-atomic介绍" class="headerlink" title="2. std::atomic介绍"></a>2. std::atomic介绍</h3><p>考虑以下应用了<code>std::atomic</code>的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt;  <span class="title">ai</span><span class="params">(<span class="number">0</span>)</span></span>;        <span class="comment">//将ai初始化为0</span></span><br><span class="line">ai = <span class="number">10</span>;                        <span class="comment">//将ai原子地设置为10</span></span><br><span class="line">std::cout &lt;&lt; ai;                <span class="comment">//原子地读取ai的值</span></span><br><span class="line">++ai;                           <span class="comment">//原子地将ai自增为11</span></span><br><span class="line">--ai;                           <span class="comment">//原子地将ai自减为10</span></span><br></pre></td></tr></table></figure>

<p>这些语句的执行期间，其他读取<code>ai</code>的线程可能只会看到它取值为<code>0</code>、<code>10</code>或<code>11</code>，而不可能有其他的取值（当前，前提假设这是修改<code>ai</code>值的唯一线程）。</p>
<h4 id="2-1-原子性的仅覆盖到对象的API而不是整个语句"><a href="#2-1-原子性的仅覆盖到对象的API而不是整个语句" class="headerlink" title="2.1 原子性的仅覆盖到对象的API而不是整个语句"></a>2.1 原子性的仅覆盖到对象的API而不是整个语句</h4><p>此例在两方面值得注意。首先，在<code>std::cout &lt;&lt; ai;</code> 这个语句中，<code>ai</code>是<code>std::atomic</code>这一事实只能保证<code>ai</code>的读取是原子操作。至于整个语句都以原子方式执行，则没有提供如此保证。在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>将其写入标准输出之间，另一个线程可能已经修改了<code>ai</code>的值。这对语句的行为没有影响，因为整型的<code>operator&lt;&lt;</code>会使用按值传递的int类型的形参来输出（因此输出的值会是从<code>ai</code>读取的值），重点在于了解<strong>这个语句中具备原子性的部分仅在于<code>ai</code>的读取而不涉及其余更多部分</strong>。</p>
<h4 id="2-2-原子对象的所有API均为原子的"><a href="#2-2-原子对象的所有API均为原子的" class="headerlink" title="2.2 原子对象的所有API均为原子的"></a>2.2 原子对象的所有API均为原子的</h4><p>此例子第二个值得注意的方面是最后两个语句的行为————<code>ai</code>的自增和自减。这里想发个都是读取——修改——写入（read-modify-write,<code>RMW</code>）操作，但皆以原子方式进行执行。这是<code>std::atomic</code>类型最棒的特性之一：一旦构造出<code>std::atomic</code>类型对象，<strong>其上所有的成员函数</strong>（包括那些包含<code>RMW</code>操作的成员函数）<strong>都保证被其他线程视为原子的</strong>。</p>
<h3 id="3-数据竞险"><a href="#3-数据竞险" class="headerlink" title="3. 数据竞险"></a>3. 数据竞险</h3><p>对比之下，使用<code>volatile</code>的相应代码在多线程语境中几乎不能提供任何保证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">vi</span><span class="params">(<span class="number">0</span>)</span></span>;             <span class="comment">//将vi初始化为0</span></span><br><span class="line">vi = <span class="number">10</span>;                        <span class="comment">//将vi设置为10</span></span><br><span class="line">std::cout &lt;&lt; vi;                <span class="comment">//读取vi的值</span></span><br><span class="line">++vi;                           <span class="comment">//将vi自增为11</span></span><br><span class="line">--vi;                           <span class="comment">//将vi自减为10</span></span><br></pre></td></tr></table></figure>

<p>在这段代码的执行期间，如果<strong>其他线程正在读取vi的值，它们可能会看到任何值，例如-12、23423、2672389，任何值</strong>！这样的代码会出现未定义的行为，因为这些语句修改了<code>vi</code>，所以如果其他线程同时正在读取vi，就会出现在既非<code>std::atomic</code>，也非由互斥量保护的同时读写操作，这就是数据竞险（<code>Data Race</code>）的定义。</p>
<p>为了说明<code>std::atomic</code>类型对象和<code>volatile</code>的行为在多线程程序中会有怎样的差异，这里举个具体例子，考虑两者由多个线程执行自增的简单计数器。两者都初始化为0：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt;  <span class="title">ac</span><span class="params">(<span class="number">0</span>)</span></span>;        <span class="comment">//&quot;ac&quot;是&quot;atomic counter&quot;（原子计数器）缩写</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">vc</span><span class="params">(<span class="number">0</span>)</span></span>;             <span class="comment">//&quot;vc&quot;是&quot;volatile counter&quot;（挥发计数器）的缩写</span></span><br></pre></td></tr></table></figure>

<p>而后，我们在两个同时运行的线程中将两者各自增一次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****线程1****/</span>            <span class="comment">/*****线程2****/</span></span><br><span class="line">++ac;                           ++ac;</span><br><span class="line">++vc;                           ++vc;</span><br></pre></td></tr></table></figure>

<p>当两个线程都完成后，<code>ac</code>的值（即，<code>std::atomic</code>类型对象的值）必定是2，因为它的自增都是作为不可分割的操作出现的。另一方面，<code>vc</code>的值则不一定是2，因为它的自增可能会不以原子方式发生。每次自增包括：读取<code>vc</code>的值，自增读取的值，并将结果写回<code>vc</code>。但这三个操作皆不能保证以原子方式处理<code>volatile</code>对象，所以可能两次<code>vc</code>自增的组成部分会交错进行，如下所示：</p>
<ol>
<li>线程1读取<code>vc</code>的值，即0。</li>
<li>线程2读了<code>vc</code>的值，仍为0。</li>
<li>线程1把读取的值0自增为1，并将该值写入<code>vc</code>。</li>
<li>线程2把读取的值0自增为1，并将该值写入<code>vc</code>。</li>
</ol>
<p>这么一来，<code>vc</code>最终值为1，即使它被实施了两次自增操作。</p>
<p>这并不是唯一可能的结果，<code>vc</code>的最终取值一般来说是无法预测的，因为<code>vc</code>涉及数据竞险，而<strong>标准既然裁定数据竞险会导致未定义行为，意味着编译器可能会生成代码来做任何事情</strong>。当然，编译器一般不会利用这种保留余地来做什么恶。可是，它们会执行一些在对于没有数据竞险的程序而言有效的优化，但这些优化在存在数据竞险的程序则会产生意想不到的、无法预测的行为。</p>
<p><strong>再来一个例子</strong></p>
<p><code>RMW</code>操作的使用并不是唯一让<code>std::atomic</code>类型对象在并发条件下成功，而让<code>volatile</code>失败的情况。假设一个任务负责计算第二个任务所需的重要值。当地一个任务已经计算出该值时，它必须把这个值通信到第二个任务。Item 39解释过，要使第一个任务将所需值的可用性传递给第二个任务，有一种方法就是使用<code>std::atomic&lt;bool&gt;</code>。在负责计算的任务中，代码会长成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt;  <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> impValue = <span class="built_in">computeImportValue</span>();       <span class="comment">//计算值</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;                        <span class="comment">//通知其他任务值已可用</span></span><br></pre></td></tr></table></figure>

<p>当人类在阅读这段代码的时候，都会知道在为<code>valAvailable</code>赋值之前为<code>impValue</code>赋值这一点至关重要，但是编译器所能看到的一切，不过是一对针对独立变量实施的赋值操作。一般地，编译器可以将这些不想关的赋值重新排序。换而言之，给定下面的赋值序列（其中，a,b,x,y对应于独立变量），</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<p>编译器可以自行将其重新排序成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>

<p>即使编译器未对它们进行重新排序，底层硬件也可能会这样做（或者可能会让其他内核将其视为重新排序后的样子），因为这样做有时候会是代码运行的更快。</p>
<p>然而，<code>std::atomic</code>类型对象的运用会对代码可以如何重新排序加以限制，并且这样的限制之一，就是<strong>在源码中，不得将任何代码提前至后续会出现<code>std::atomic</code>类型变量的写入操作的位置（或使其他内核视作这样的操作会发生）。</strong></p>
<blockquote>
<p>插播译者解释<br>这一点仅在<code>std::atomic</code>类型对象采用顺序一致性时才成立，这种一致性是默认采用的，也是本书中使用该语法时唯一采用的一致性模型。C++还支持另外的、在代码重排方面更灵活的一致性模型。这样的弱化（也称作松弛）模型使得在某些硬件体系结构上运行得更快的软件成为可能，但是运用这样的模型所产生的软件想要保证正确性、可理解性和可维护性，会困难得多。在松弛原子性中的微妙代码错误绝不罕见，即使专业也会感觉棘手。所以但凡可能，你就应该抱紧顺序一致性。</p>
<p>在能够理解六种内存顺序的基础上，其实可以灵活的使用松弛顺序去保证那些可能造成竞态的单一变量。松弛顺序实际上比顺序一致性更适合用于纯粹为了避免竞态保护数据的场景。<strong>以上自己见解中有对应PPT</strong>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/aiyanzielf/article/details/120372982">传送门</a></p>
</blockquote>
<p>这意味着在我们的代码中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt;  <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> impValue = <span class="built_in">computeImportValue</span>();       <span class="comment">//计算值</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;                        <span class="comment">//通知其他任务值已可用</span></span><br></pre></td></tr></table></figure>

<p><strong>不仅编译器必须保持为<code>impValue</code>和<code>valAvailable</code>的赋值顺序，它们还必须生成代码以确保底层硬件也保证这个顺序</strong>。</p>
<p>因此，将<code>valAvailable</code>声明为<code>std::atomic</code>类型可以确保我们的关键顺序需求得到保证，<code>impValue</code>必须被所有线程看到，它是以不晚</p>
<p>于<code>valAvailable</code>的时序被更改。</p>
<p>将<code>valAvailable</code>加上<code>volatile</code>声明饰词，不会给代码施加同样的重新排序方面的约束：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">bool</span>  <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> impValue = <span class="built_in">computeImportValue</span>();       <span class="comment">//计算值</span></span><br><span class="line">valAvailable = <span class="literal">true</span>;        <span class="comment">//其他线程可能将这个赋值操作视作在impValue之前！</span></span><br></pre></td></tr></table></figure>

<p>在这里，编译器可能会将赋值顺序反转为后<code>impValue</code>先<code>valAvailable</code>，即使它不这么做， 也可能不会生成及其代码阻止底层硬件使其他内核上的代码看到<code>valAvailable</code>在<code>impValue</code>之前发生改变。</p>
<h3 id="4-volatile作用"><a href="#4-volatile作用" class="headerlink" title="4. volatile作用"></a>4. volatile作用</h3><p>这两个那问题（无法保证操作的原子性，无法对代码重新排序施加限制）解释了为何<code>volatile</code>对并发编程没用，但是并未解释它在什么情况下有用。简而言之，<strong>它的用处就是告诉编译器，正在处理的内存不具备常规行为</strong>。</p>
<blockquote>
<p>这里我有个更简单的理解方案，就是告诉编译器别乱优化我的代码，就按照我写的来。</p>
</blockquote>
<h4 id="4-1-常规内存"><a href="#4-1-常规内存" class="headerlink" title="4.1 常规内存"></a>4.1 常规内存</h4><p>“常规”内存的特征是： 如果你向某个内存位置写入了值，该值会一直保留在那里，直到它被覆盖为止。所以，如果我有个常规的<code>int</code>变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br></pre></td></tr></table></figure>

<p>且编译器看到了对其实施了以下序列的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">//读取x</span></span><br><span class="line">y = x;          <span class="comment">//再次读取x</span></span><br></pre></td></tr></table></figure>

<p>编译器可以通过消除对<code>y</code>的赋值操作来优化生成新的代码，因为它和<code>y</code>的初始化形成了冗余。</p>
<p>常规内存还有如下特征：如果向某内存位置写入某值，期间未读取该内存位置，然后再次写入该内存位置，则第一次写入可以消除，因为其写入结果从未被使用过。所以给定下面的两个相邻语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//写入x</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">//再次写入x</span></span><br></pre></td></tr></table></figure>

<p>编译器就可以消除第一个操作，这意味着如果我们在源代码中有这样一段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">//读取x</span></span><br><span class="line">y = x;          <span class="comment">//再次读取x</span></span><br><span class="line">x = <span class="number">10</span>;         <span class="comment">//写入x</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">//再次写入x</span></span><br></pre></td></tr></table></figure>

<p>编译器可以自行把这段代码视作长成下面这样一般：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">//读取x</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">//写入x</span></span><br></pre></td></tr></table></figure>

<p>恐怕你会想，谁会撰写执行如此的冗余读取和多余写入的代码（术语是冗余加载和废弃存储）呢？答案是，人类不会直接撰写如此代码，至少我们希望没人会这样做吧。但是，即使编译器接受的是看上去合情合理的源代码，对其执行模板实例化、内联以及各种常见的重新排序等优化后，结果中包含编译器能够消除的冗余加载和废弃存储的情况并不罕见。</p>
<h4 id="4-2-特种内存"><a href="#4-2-特种内存" class="headerlink" title="4.2 特种内存"></a>4.2 特种内存</h4><p>此类优化仅在内存行为符合常规时才合法。“特种”内存就是另一回事。</p>
<p>可能最常见的特种内存是用于内存映射IO的内存。这种内存的位置实际上是用于与外部设备（例如，外部传感器、显示器、打印机和网络端口等）通信，而非用于读取或写入常规内存（即RAM）。在此情况下，再次考虑看似冗余的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">//读取x</span></span><br><span class="line">y = x;          <span class="comment">//再次读取x</span></span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>对应于，比如说，由温度传感器报告的值，则<code>x</code>的第二次读取操作并非多余，因为在第一次和第二次读取之间，温度可能已经改变。</p>
<p>看似多余的写入操作也有类似的情形。比如，在这段代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//写入x</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">//再次写入x</span></span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>对应于无线发射器的控制端口，则可能是代码在向无线电发出指令，并且值<code>10</code>对应于与值<code>20</code>不同的命令。如果把第一个赋值优化掉，就将改变发送到无线电的命令序列了。</p>
<p>而<code>volatile</code>的用处就是告诉编译器，正在处理的是特种内存。它的意思是<strong>通知编译器“不要对在此内存上的操作做任何优化”</strong>。所以，如果<code>x</code>对应于特种内存，则它应该加上<code>volatile</code>声明饰词：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x;</span><br></pre></td></tr></table></figure>

<p>考虑这么一来，会对我们原先的代码序列产生什么影响：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;     <span class="comment">//读取x</span></span><br><span class="line">y = x;          <span class="comment">//再次读取x(不会被优化掉了！)</span></span><br><span class="line">x = <span class="number">10</span>;         <span class="comment">//写入x</span></span><br><span class="line">x = <span class="number">20</span>;         <span class="comment">//再次写入x(不会被优化掉了！)</span></span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>是内存映射的（或已映射到跨进程共享的内存位置等），这真正是我们想要的效果。</p>
<p>测试时间！在上面最后一段代码中，y应该取什么类型：<code>int</code>还是<code>volatile int</code>?</p>
<blockquote>
<p>这里需要注意<code>auto</code>和 <code>cv</code> 的关系，实际上这里的<code>auto</code>是<code>int</code>，所以<code>y</code>的冗余写入会被优化</p>
</blockquote>
<p>在处理特种内存时必须保留看似冗余加载和废弃存储这一事实，也顺便解释了为何<code>std::atomic</code>类型对象不适用于这种工作。编译器可以消除<code>std::atomic</code>类型上的冗余操作。代码的撰写方式与使用<code>volatile</code>时不尽相同，但是我们不妨暂时忽略这一点。而先关注编译器允许做的事情，我们可以这么说，从概念上说，编译器可能接受的是这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x;</span><br><span class="line"><span class="keyword">auto</span> y = x;             <span class="comment">//概念上会读取x（见下）</span></span><br><span class="line">y = x;                  <span class="comment">//概念上会再次读取x（见下）</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;                 <span class="comment">//写入x</span></span><br><span class="line">x = <span class="number">20</span>;                 <span class="comment">//再次写入x</span></span><br></pre></td></tr></table></figure>

<p>并优化成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;             <span class="comment">//概念上会读取x（见下）</span></span><br><span class="line">x = <span class="number">20</span>;                 <span class="comment">//写入x</span></span><br></pre></td></tr></table></figure>

<p>这显然对于特种内存来说，是不可接受的行为。</p>
<p>无巧不成书，以下两个语句在<code>x</code>是<code>std::atomic</code>类型对象时都不能通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;             <span class="comment">//错误！</span></span><br><span class="line">y = x;                  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>原因在于<code>std::atomic</code>的复制操作被删除了，参见Item 11。而且这个删除是有充分道理的。考虑如果从<code>x</code>触发来初始化<code>y</code>能够通过编译的话，会发生什么。</p>
<p>由于<code>x</code>的类型是<code>std::atomic</code>，所以<code>y</code>的类型也会被推导为<code>std::atomic</code>，参见Item 2。我之前说过，<code>std::atomic</code>类型对象最好的一点，是它们的所有操作都是原子的。但是，为了使得从<code>x</code>出发来构造<code>y</code>的操作也成为原子的，编译器就必须生成代码来在单一的原子操作中读取<code>x</code>并写入<code>y</code>。硬件通常无法完成这样的操作，这就是为什么从<code>x</code>到<code>y</code>的赋值通不过编译的原因（由于移动操作没有在<code>std::atomic</code>中显示声明，因此，根据Item 17中描述的编译器生成特种函数的规则，<code>std::atomic</code>既不提供移动构造，也不提供移动赋值运算符。）</p>
<p>从<code>x</code>中取值并置入<code>y</code>是可以实现的，但是要求使用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>。<code>load</code>成员函数以原子方式读取<code>std::atomic</code>类型对象的值，而<code>store</code>成员函数以原子方式写入之。如果想先用<code>x</code>初始化<code>y</code>，然后将<code>x</code>的值置入<code>y</code>，代码必须如下撰写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt;  <span class="title">y</span><span class="params">(x.load())</span></span>;          <span class="comment">//读取x</span></span><br><span class="line">y.<span class="built_in">store</span>(x.<span class="built_in">load</span>());                      <span class="comment">//x再次读取</span></span><br></pre></td></tr></table></figure>

<p>这段代码可以通过编译，但是，读取<code>x</code>（经由<code>x.load()</code>）是个独立于初始化或存储到<code>y</code>的函数调用这一事实清楚地表明，没有理由去期望这两条语句中的任何一条可以整体作为单一原子操作执行。</p>
<p>给定上述代码的前提下，编译器可以通过将<code>x</code>的值存储在寄存器中，而不是两次读取，以“优化”之：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> = x.<span class="built_in">load</span>();                <span class="comment">//将x读入寄存器</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt;  <span class="title">y</span><span class="params">(<span class="keyword">register</span>)</span></span>;      <span class="comment">//以寄存器值初始化y</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="keyword">register</span>);                  <span class="comment">//将寄存器值存储入y</span></span><br></pre></td></tr></table></figure>

<p>结果正如你所见，<code>x</code>的读取操作只执行了一次，这是在处理特种内存时必须避免的那种优化（该优化在<code>volatile</code>变量上不被允许）。</p>
<p>现在事情应该明确了：</p>
<ul>
<li><code>std::atomic</code>对于并发程序设计有用，但不能用于访问特种内存。</li>
<li><code>volatile</code>对于访问特种内存有用，但不能用于并发程序设计。</li>
</ul>
<p>由于<code>std::atomic</code>和<code>volatile</code>是用于不同目的，他们甚至可以一起使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> std::atomic&lt;<span class="type">int</span>&gt; val;      <span class="comment">//针对val的操作是原子的，</span></span><br><span class="line">                                    <span class="comment">//并且不可以被优化掉</span></span><br></pre></td></tr></table></figure>

<p>如果<code>val</code>对应于<strong>由多个线程同时访问的内存映射IO位置</strong>，就可能会是有用的。</p>
<p>最后，有些开发人员更喜欢使用<code>std::atomic</code>的<code>load</code>和<code>store</code>成员函数，即使并非必要，因为这样做可以在源代码中明确地表明所涉及的变量并非“常规”。<strong>强调这一事实，也并非没有理由</strong>。访问<code>std::atomic</code>类型对象通畅比访问非<code>std::atomic</code>类型对象<strong>慢得多</strong>，我们已经看到<code>std::atomic</code>类型对象在使用过程中会阻止编译器对某些类型的代码重新排序，而这样的重新排序在其他情况下是被允许的。召唤<code>std::atomic</code>类型对象的加载和存储有助于识别出阻碍潜在的可伸缩性之处。从正确性角度来看，如果本来想要通过某个变量将信息传达到其他线程，却未见它调用<code>store</code>(例如，一个指示数据可用性的标志位)，就可能意味着该变量本来应该声明为<code>std::atomic</code>，却没有这么做。</p>
<p>这在很大程度上是一个代码风格的问题，因此，这与在<code>std::atomic</code>和<code>volatile</code>之间进行的选择有着非常不同的性质。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>std::atomic</code>用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具。</td>
</tr>
<tr>
<td>2. <code>volatile</code>用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具。</td>
</tr>
</tbody></table>
<h1 id="第八章-小改进"><a href="#第八章-小改进" class="headerlink" title="第八章 小改进"></a>第八章 小改进</h1><h2 id="条款41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"><a href="#条款41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递" class="headerlink" title="条款41  针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"></a>条款41  针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h2><p>C++中的每一项通用技术或特性，都会在某些情况下使用，而在另一些情况下则不适用。一般而言，描述通用技术或者特性的适用情况才顺理成章，但本章却反其道而行之，描述了两种例外情况。</p>
<p>通用技术指的是按<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020">值传递</a>，而通用特性则是置入（<code>emplacement</code>）。想做出是否采用它们的决定，须面对诸多影响因素，而我能够提供的最佳建议则是需要考虑他们其实是有适用场景的。话虽如此，这两者可都是高效现代C++程序设计的重要角色，下面的条款为在评价它们是否适用你的软件这方面提供了参考信息。</p>
<h3 id="1-重载"><a href="#1-重载" class="headerlink" title="1. 重载"></a>1. 重载</h3><p>有些函数的形参本来就是打算拿来复制的。例如，成员函数<code>addName</code>可能会将其形参复制入其私有容器。<strong>为效率考虑，这样的函数应该针对左值实参实施复制，而针对右值实参实施移动</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span>    <span class="comment">//接受左值</span></span></span><br><span class="line"><span class="function">    </span>&#123;names.<span class="built_in">push_back</span>(newName);&#125;                 <span class="comment">//对其实施复制</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span>         <span class="comment">//接受右值</span></span></span><br><span class="line"><span class="function">    </span>&#123;names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));&#125;      <span class="comment">//对其实施移动</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt;  names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于<code>std::move</code>的用法，详见此处Item 25</p>
</blockquote>
<p>这样写也没有错，但要求撰写本质上在做同一件事的两个函数。这么一来可就有活干了：需要撰写两份函数声明，两份函数实现，两份函数文档，两份函数维护工作量。啊哟，要命了啊。</p>
<p>更有甚者，在目标代码中将会出现两个函数，如果你确实在意程序足迹一事，这一情况就可能会让你忧心。在本例情况下，这两个函数都可能会被实施内联，而这很可能会消除与存在两个函数相关的任何膨胀问题，但是如果这些函数没有处处实施内联的话，那么你在目标代码中就真会看到有两个函数了。</p>
<h3 id="2-万能引用"><a href="#2-万能引用" class="headerlink" title="2. 万能引用"></a>2. 万能引用</h3><p>另一种方法是把<code>addName</code>写成接受万能引用的函数模板（参见Item 24）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                                <span class="comment">//接受左值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span>                           <span class="comment">//也接受右值</span></span></span><br><span class="line"><span class="function">    </span>&#123;                                                   <span class="comment">//对左值实施复制</span></span><br><span class="line">        names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName));      <span class="comment">//对右值实施移动</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于<code>std::forward</code>的用法，详见此处Item 25</p>
</blockquote>
<p>这减少了你需要着手处理的源代码数量，但是万能引用的使用会导致其他方面的复杂性。作为模板，<code>addName</code>的实现通常必须置于头文件中。它还可能在对象代码中产生好几个函数，因为它不仅针对左值和右值会产生不同的实例化结果，针对<code>std::string</code>和可以转型为<code>std::string</code>的类型，参见Item 25，也会产生不同的实例化结果。同时，有些类型不能按通用引用方式传递，参见Item 30，如果客户传入了不正确的实参类型，编译器错误信息可能会吓人一跳，参见Item 25。</p>
<h3 id="3-按值传递"><a href="#3-按值传递" class="headerlink" title="3. 按值传递"></a>3. 按值传递</h3><p>如果有一种方法来撰写像<code>addName</code>这样的函数，<strong>针对左值实施的是复制，针对右值实施的是移动，而且无论在源代码和目标代码中只有一个函数需要着手处理，还能避免万能引用的怪癖</strong>，那该多妙！</p>
<p>无巧不成书，方法还真有一个。你所需要做的事情只有一件，就是<strong>要放弃</strong>你可能身为C++程序员学到的第一条规则。该规则说，<strong>要避免按值传递用户定义类型的对象</strong>。对于像<code>addName</code>这样的函数中的<code>newName</code>这样的形参，按值传递可能是个完全合理的策略。</p>
<p>在我们讨论为什么按值传递可能非常适用于<code>newName</code>和<code>addName</code>之前，先看看实现长成什么样子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span>      <span class="comment">//既接受左值</span></span></span><br><span class="line"><span class="function">    </span>&#123;names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));&#125;  <span class="comment">//也接受右值，对后者实施移动</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码中唯一无法一看就懂的部分，是针对形参<code>newName</code>实施<code>std::move</code>。通常情况下，<code>std::move</code>仅会针对右值引用实施。但在这种情况下，我们确知：</p>
<ol>
<li>无论调用方传入什么，<code>newName</code>都对它没有任何依赖，所以更改<code>newName</code>不会对调用方产生任何影响；</li>
<li>这次使用<code>newName</code>是对它的最后一次使用，所以移动它也不会对函数的其余部分产生任何影响。</li>
</ol>
<p>只有单个<code>addName</code>函数的事实，就已经说明我们做到了避免源代码以及目标代码中的代码重复。我们没有使用万能引用，所以采用这种也不会导致头文件膨胀、怪异的失败情形或令人费解的错误消息。但是，这样设计会导致效率问题嘛？毕竟我们可是按值传递的哟。会不会发生高昂的成本呢？</p>
<p><strong>在C++98中，可以打包票的说，肯定会发生的</strong>。无论调用方传入的是什么，形参<code>newName</code>都会经由复制构造函数创建。不过，在C++11中，<code>newName</code>仅在传入左值时才会被复制构造。而如果传入的是个右值，它会被移动构造。就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget  w;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::string  <span class="title">name</span><span class="params">(<span class="string">&quot;Adam&quot;</span>)</span></span>;</span><br><span class="line">w.<span class="built_in">addName</span>(name);            <span class="comment">//在调用addName时传入左值</span></span><br><span class="line">...</span><br><span class="line">w.<span class="built_in">addName</span>(name + <span class="string">&quot;Xiao&quot;</span>);   <span class="comment">//在调用addName时传入右值</span></span><br></pre></td></tr></table></figure>

<p>在<code>addName</code>的第一个调用中（即传入的是<code>name</code>时），用以初始化形参<code>newName</code>的是个左值。所以，对<code>newName</code>实施的是复制构造，一如在C++98中那样。在第二个调用中，用以初始化<code>newName</code>的，则是<code>std::string</code>的<code>operator+</code>的调用产生的结果<code>std::string</code>类型对象（即字符串附加操作）。那样的对象是个右值，所以对<code>newName</code>实施的是移动构造。</p>
<h3 id="4-三种方法对比分析"><a href="#4-三种方法对比分析" class="headerlink" title="4. 三种方法对比分析"></a>4. 三种方法对比分析</h3><blockquote>
<p>针对左值实施复制，针对右值实施移动，恰如所想。干净利落，对吧？</p>
</blockquote>
<p>干净利落，的确如此。但有些指导原则，还是最好牢记心中。回顾一下我们考虑过的<code>addName</code>三版本，就能更容易想到这个实现方案了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;                                   <span class="comment">//途径一：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">//针对左值和右值重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;names.<span class="built_in">push_back</span>(newName);&#125;                 </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span>         </span></span><br><span class="line"><span class="function">    </span>&#123;names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));&#125;      </span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt;  names;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                                  <span class="comment">//途径二：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">//使用万能引用</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                                </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span>                           </span></span><br><span class="line"><span class="function">    </span>&#123;                                                   </span><br><span class="line">        names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName));      </span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;                                   <span class="comment">//途径三：</span></span><br><span class="line"><span class="keyword">public</span>:                                         <span class="comment">//按值传递</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span>      </span></span><br><span class="line"><span class="function">    </span>&#123;names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));&#125;  </span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我把前两个版本称为<code>按引用的途径</code>，因为他们都是按引用传递形参的。</p>
<p>而下面则是我们考察过的两种调用场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line"><span class="function">std::string  <span class="title">name</span><span class="params">(<span class="string">&quot;Adam&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">addName</span>(name);            <span class="comment">//传入左值</span></span><br><span class="line">...</span><br><span class="line">w.<span class="built_in">addName</span>(name + <span class="string">&quot;Xiao&quot;</span>);   <span class="comment">//传入右值</span></span><br></pre></td></tr></table></figure>

<p><strong>成本合计分析</strong></p>
<p>现在考虑下成本问题，考察对象是复制和移动操作，<strong>考察两个调用场景在我们讨论过的三个<code>addName</code>实现中的每一个中添加一个名字会带来的成本是多少</strong>。</p>
<blockquote>
<p>这个成本会计过程将很大程度上忽略编译器优化掉复制和移动操作的可能性，因为这样的优化既依赖于语境，也依赖于编译器，实际上不会改变分析的本质结果。</p>
</blockquote>
<ul>
<li><p><strong>重载</strong>：无论传入左值还是右值，调用方的实参都会绑定到名字为<code>newName</code>的引用上。而这么做不会在复制或移动时带来任何成本。在接受左值的重载版本中，<code>newName</code>被复制入<code>Widget::names</code>；在接受右值的重载版本中，<code>newName</code>被移入<code>Widget::names</code>。成本合计：<strong>对于左值是一次复制，对于右值是一次移动</strong>。</p>
</li>
<li><p><strong>使用万能引用</strong>：与重载一样，调用方的实参会绑定到引用<code>newName</code>上。这是无成本操作。由于使用了<code>std::forward</code>，左值<code>std::string</code>实参被复制入<code>Widget::names</code>中，而右值<code>std::string</code>实参则被移入。传入<code>std::string</code>实参的成本合计结果与重载相同。成本合计：<strong>对于左值是一次复制，对于右值是一次移动</strong>。</p>
</li>
<li><p><strong>按值传递</strong>：无论传入的是左值还是右值，针对形参<code>newName</code>都必须实施一次构造。如果传入的是个左值，成本是一次复制构造。如果传入的是个右值，成本是一次移动构造。在函数体内，<code>newName</code>需要无条件地移入<code>Widget::names</code>。这么一来，就得到了成本合计的结果：<strong>对左值而言，是一次复制加一次移动；对右值而言，是两次移动</strong>。与按引用途径相比，<em><strong>无论是左值和右值，都存在一次额外的移动操作</strong></em>。</p>
</li>
</ul>
<p>回顾一下本条件的标题：</p>
<blockquote>
<p>针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</p>
</blockquote>
<p>使用这样的措辞，其实是有理由的。说具体点，有四条理由：</p>
<p><strong>它的优势</strong></p>
<p>你只是考虑按值传递。没错，它只要求撰写单个函数。没错，它在目标代码中只生成单个函数。没错，它能够避免万能引用带来的一系列毛病。但不要忘了，它的成本更高一些，并且，我们还会展示，在有些情况下，还会产生更多在此尚未讨论的成本。</p>
<p><strong>限定于可复制的形参</strong></p>
<p><strong>仅对可复制的形参，才考虑按值传递</strong>。不符合这个要求的形参必然具备只移类型，因为如果它们本来不可复制，但函数却总会创建副本的话，那就必须经由移动构造函数来创建该副本。回忆一下，按值传递相对于重载而言的优势，就在于若采用按值传递则只需撰写单个函数。但是只移类型却并不需要针对左值类型提供重载版本，因为复制左值需要调用复制构造函数，而只移类型的复制构造函数根本就已经被禁用了。这意味着，只需为右值类型的实参提供支持即可。所以在此情况下，所谓<code>重载</code>解决方案只要求一个重载版本：<strong>那个接受右值引用类型的重载版本</strong>。</p>
<p>考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和一个针对它的设置器。<code>std::unique_ptr</code>是个只移类型，所以其设置器虽然采用了<code>重载</code>途径，却只由单个函数组成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPtr</span><span class="params">(std::unique_ptr&lt;std::string&gt;&amp;&amp; ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;p = std::<span class="built_in">move</span>(ptr);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;std::string&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用方可能以这样的方式使用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w.<span class="built_in">setPtr</span>(std::<span class="built_in">make_unqiue</span>&lt;std::string&gt;(<span class="string">&quot;Modern C++&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在这里，从<code>std::make_unique</code>，参见Item 21返回右值<code>std::unique_ptr&lt;std:string&gt;</code>会以右值引用方式传递给<code>setPtr</code>，在那里它被移入数据成员<code>p</code>。总成本是一次移动。</p>
<p>如果<code>setPtr</code>以按值传递方式来接受形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPtr</span><span class="params">(std::unique_ptr&lt;std::string&gt; ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;p = std::<span class="built_in">move</span>(ptr);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同一调用会造成针对形参<code>ptr</code>实施移动构造后，再将<code>ptr</code>移入数据成员<code>p</code>。这么一来，总成本成了两次移动，比<code>重载</code>途径翻了一倍。</p>
<p><strong>限定于移动成本低廉</strong></p>
<p><strong>按值传递仅在形参移动成本低廉的情况下，才值得考虑</strong>。只有当移动成本低廉时，一次移动带来的额外成本才可能是可以接受的，但如果这个前提都不成立，那么执行不必要的移动就和执行不必要的复制没有区别了。而避免不必要的复制操作的重要性，也正是C++98中<code>要尽量避免按值传递</code>这条金科玉律的出发点。</p>
<p>你应该只针对一定会被复制的形参才考虑按值传递。欲理解为何这一点很重要，假设在将其形参复制到容器<code>names</code>之前，<code>addName</code>会先检查该新名字是否太短或太长。如果太短或太长，则忽略添加该名字的请求。按值传递的实现可能会写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newName.<span class="built_in">length</span>() &gt;= minLen) &amp;&amp; </span><br><span class="line">        (newName.<span class="built_in">length</span>() &lt;= Maxlen))</span><br><span class="line">        &#123;</span><br><span class="line">            names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使没有向<code>names</code>添加任何内容，该函数也会招致构造和析构<code>newName</code>的成本。而如果采用了按引用途径，就不必为此买单。</p>
<h3 id="5-例外情况：-基于赋值的形参复制成本有可能取决于参与赋值的对象的取值"><a href="#5-例外情况：-基于赋值的形参复制成本有可能取决于参与赋值的对象的取值" class="headerlink" title="5. 例外情况： 基于赋值的形参复制成本有可能取决于参与赋值的对象的取值"></a>5. 例外情况： 基于赋值的形参复制成本有可能取决于参与赋值的对象的取值</h3><blockquote>
<p>即使你面对的函数的确是在针对可复制类型实施无条件复制，并且移动成本也低廉，还是存在不合适的采用按值传递的一些情况。</p>
</blockquote>
<p>原因在于，函数可以经由两种方式来实施复制：</p>
<ol>
<li>经由构造（即复制构造或移动构造）</li>
<li>经由赋值（即复制赋值或移动赋值）</li>
</ol>
<p><code>addName</code>采用的是构造方式：其参数<code>newName</code>被传递给<code>vector::push_back</code>，并且在该函数内，<code>newName</code>被复制构造入<code>std::vector</code>末尾所创建的新元素中。</p>
<p>对于使用构造来实施形参复制的函数，我们前面的分析已经是完整的了：使用值传递的话，无论传入的左值还是右值，都会带来一次额外移动的成本。</p>
<p>如果采用赋值来实施形参复制的话，情况就更复杂了。例如，假定我们有个表示密码的类。由于密码可以更改，我们提供一个设置器函数<code>changeTo</code>。在采用按值传递策略的前提下，我们可能会像这样实现<code>Password</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Password</span><span class="params">(std::string pwd)</span>  <span class="comment">//按值传递</span></span></span><br><span class="line"><span class="function">    : text(std::move(pwd)) &#123;</span>&#125;           <span class="comment">//对text实施构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string newPwd)</span>   <span class="comment">//按值传递</span></span></span><br><span class="line"><span class="function">    </span>&#123; text = std::<span class="built_in">move</span>(newPwd);&#125;        <span class="comment">//对text实施赋值</span></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;                   <span class="comment">//表示密文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以明文的形式存储密码会让软件安全特勤组狂暴，但先不说这个，考虑下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string  <span class="title">intPwd</span><span class="params">(<span class="string">&quot;Supercalifragilisticexpialidocious&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Passwork <span class="title">p</span><span class="params">(initPwd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这段代码并无意外：<code>p.text</code>采用给定密码构造，而在构造函数中采用按值传递会产生<code>std::string</code>的移动构造成本，该成本在采用重载或完美转发时不会发生。一切运行正常。</p>
<p>不过，该程序的某个用户可能会感觉初始密码不尽如人意。因为<code>Supercalifragilisticexpialidocious</code>是可以在许多字典中直接找到的。因此，他可能会采取行动，造成等价于以下代码加以执行的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string  newPassword = <span class="string">&quot;Beware the Jabberwock&quot;</span>;</span><br><span class="line">p.<span class="built_in">changeTo</span>(newPassword);</span><br></pre></td></tr></table></figure>

<p>新密码与旧密码谁好谁坏这里不做定论。我们所面临的问题则是<code>changeTo</code>采用了赋值来对形参<code>newPwd</code>实施复制，这有可能导致该函数的按值传递策略带来爆发式的成本。</p>
<p>但在本例情况下，旧密码（<code>&quot;Supercalifragilisticexpialidocious&quot;</code>）比新密码（<code>&quot;Beware the Jabberwock&quot;</code>）更长，所以不需要实施任何内存分配和回收。如果采用重载途径，则很可能不会发生任何动态内存管理行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(<span class="type">const</span> std::string&amp; newPwd)</span>        <span class="comment">//为左值而准备的重载</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        text = newPwd;          <span class="comment">//在下式成立的前提下，可以复用text的内存</span></span><br><span class="line">                                <span class="comment">//text.capacity() &gt;= newPwd.size()</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;                   <span class="comment">//表示密文</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在此场景下，按值传递的代价会包括额外的内存分配和回收成本，该成本可能会比<code>std::string</code>移动操作的成本高出几个数量级。</p>
<p>有意思的是，如果旧密码比新密码短，在赋值过程中一般而言不可能避免分配—回收这对动作，在此情况下，按值传递可能与按引用传递有着大致相同的运行速度。也就是说，<strong>基于赋值的形参复制成本有可能取决于参与赋值的对象的取值</strong>！这一分析结果适用于可能在动态分配的内存中持有值的任何形参类型。不是所有的类型都符合这一特征，但很多确实符合，这其中就包括<code>std::string</code>和<code>std::vector</code>。</p>
<p>这样的潜在成本增加通常只在传入左值实参时才会发生，因为实施内存分配和回收的需求通常仅在实施真正的复制操作（即，非移动操作）时才发生。对于右值实参而言，几乎总是只需要移动就足够了。</p>
<p><strong>小总结</strong></p>
<p>总而言之，采用赋值方式复制形参的函数，其按值传递带来的额外成本取决于传入的<strong>类型</strong>、<strong>左值和右值实参的占比</strong>、<strong>类型是否使用动态分配内存</strong>，还有，在确实使用了动态内存的前提下，该类型的赋值运算符如何实现，以及与赋值目标相关联的内存是否至少与赋值源相关联的内存尺寸相当的<strong>可能性高低</strong>。对于<code>std::string</code>而言，还要取决于实现是否使用了小型字符串优化（<code>small string optimization, SSO</code>，参见Item 29），还有，如果确实使用了<code>SSO</code>，所赋的值是否放的进<code>SSO</code>缓冲区。</p>
<p>所以，和我之前说的那样，当通过赋值实施形参复制时，进行按值传递的成本分析会是复杂的。通常情况下，最实用的途径是采取<code>无罪推定，除非证明有罪</code>的策略。也就是说，<strong>总是采用重载或万能引用而非按值传递，除非已确凿地证明按值传递能够为所需的形参类型生成可接受效率的代码</strong>。</p>
<p>既然如此，对于那些必须运行的尽可能快的软件来说，按值传递可能并非可行的策略，因为也许即使移动成本低廉，可能避免它们仍然重要。更何况，其实会发生多少移动操作并不非常清晰。在<code>Widget::addName</code>例子中，按值传递只会招致一次额外的移动操作，但是假设<code>Widget::add</code>会先调用<code>Widget::validateName</code>，并且调用后者时也按值传递（它可能会有个总是复制其形参的理由，例如，将其存储在某个所有待验证的值构成的数据结构中）。并假设<code>validateName</code>会调用第三个也要求按值传递的函数…你应该可以看出来，这样下去会往什么方向发展。当存在函数调用链时，如果每个函数都出于“只不过耗费一次低成本的移动”而选用了按值传递的话，则整个调用的成本可能会超过你能容忍的范围。而如果使用的是按引用的形参传递，则调用链不会产生这种累积性的开销。</p>
<h3 id="6-另一个古老的但需要牢记的切片问题"><a href="#6-另一个古老的但需要牢记的切片问题" class="headerlink" title="6. 另一个古老的但需要牢记的切片问题"></a>6. 另一个古老的但需要牢记的切片问题</h3><p>还有一个与效率无关，但仍需要牢记的议题是，不同于按引用传递，按值传递较容易遭遇切片问题。这个问题在C++98中已是老生常谈，所以我不会展开。但是如果你有个函数被设计用以接受一个积累类型或从它派生的任何类型的形参，你肯定不会想要声明该类型的按值传递形参，因为传入的任何可能的派生类型对象的派生类特征都将会被“截断”掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;....&#125;;                        <span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>: <span class="keyword">public</span> Widget &#123;....&#125;;  <span class="comment">//派生类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(Widget w)</span></span>;               <span class="comment">//为任何Widget而设计的函数</span></span><br><span class="line">                                            <span class="comment">//包含派生类型</span></span><br><span class="line">                                            <span class="comment">//会受到切片问题侵害</span></span><br><span class="line">....</span><br><span class="line">SpecialWidget sw;</span><br><span class="line">....</span><br><span class="line"><span class="built_in">processWidget</span>(sw);                          <span class="comment">//processWidget看到的只是</span></span><br><span class="line">                                            <span class="comment">//一个Widget而非SpeicalWidget类型的对象！</span></span><br></pre></td></tr></table></figure>

<p>如果你对切片问题尚不熟悉，搜索引擎和互联网是你的朋友，那上面的相关信息汗牛充栋。你会了解到，切片问题的存在是按值传递在C++98中如此声名狼藉的另一个原因（比影响性能更甚）。为何你在初学C++程序设计时就会被告知的事项之一，就是避免按值传递用户自定义类型对象，这也不无理由。</p>
<p>C++11并没有从根本上颠覆C++98关于按值传递的智慧。一般地，<strong>按值传递仍会导致一些你本想避免的性能损失，按值传递还会导致切片问题</strong>。C++11引入的新特性是左值和右值的区别对待。欲实现函数以利用可复制右值类型的移动语义，就需要重载或使用万能引用之一，但这两者都有一定的缺点。对于<strong>可复制的、移动成本低廉的类型，并且传入的函数总是对其实施复制这个特殊情况，在切片问题也无需担心</strong>的前提下，按值传递可以提供一个易于实现的替代方法，它和按引用传递的竞争对手效率相近，但是避免了它们的不足。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 对于可复制的、在移动成本低廉的并且一定会被复制的形参而言，按值传递可能会和按引用传递具备相近的效率，并可能生成更少量的目标代码。</td>
</tr>
<tr>
<td>2. 经由构造复制形参的成本可能比经由赋值复制形参的成本高处很多。</td>
</tr>
<tr>
<td>3. 按值传递肯定会导致切片问题，所以基类类型特别不适用于按值传递。</td>
</tr>
</tbody></table>
<h2 id="条款42-考虑置入而非插入"><a href="#条款42-考虑置入而非插入" class="headerlink" title="条款42 考虑置入而非插入"></a>条款42 考虑置入而非插入</h2><p>如果你有个容器，持有一些，比如说，<code>std::string</code>类型的对象，那么似乎合乎逻辑的做法是用某个插入函数<code>insertion function</code>来向其中添加新元素，比如<code>insert</code>，<code>push_front</code>和<code>push_back</code>，又或者对于<code>std::forward_list</code>而言的<code>insert_after</code>，而传递给函数的元素类型将是<code>std::string</code>。毕竟，那正是容器持有物的类型。</p>
<h3 id="1-为什么push-back效率不高"><a href="#1-为什么push-back效率不高" class="headerlink" title="1 为什么push_back效率不高"></a>1 为什么push_back效率不高</h3><p>说合乎逻辑倒也确实合乎逻辑，但却不一定合乎事实。考虑这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;    <span class="comment">//持有std::string类型对象的容器</span></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyy&quot;</span>);            <span class="comment">//添加字符串字面量</span></span><br></pre></td></tr></table></figure>

<p>这里，容器持有的是<code>std::string</code>类型对象，但你手上有的（实际上想要实施<code>push_back</code>的）是个字符串字面量，即，一对引号内的一串字符串。字符串字面量不是<code>std::string</code>，也就是说，传递给<code>push_back</code>的实参并非容器持有物的类型。</p>
<h4 id="1-1-push-back的实现"><a href="#1-1-push-back的实现" class="headerlink" title="1.1 push_back的实现"></a>1.1 push_back的实现</h4><p><code>std::vector</code>的<code>push_back</code>针对左值和右值给出了不同的重载版本如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,                           <span class="comment">//引自C++11标准</span></span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(<span class="type">const</span> T&amp; x);             <span class="comment">//插入左值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;                  <span class="comment">//插入右值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的调用语句中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会看到实参类型<code>const char[6]</code>与<code>push_back</code> <code>std::string的引用类型</code>接受的形参类型之间的不匹配。而解决的办法就是**通过生成代码以从字符串字面量触发创建<code>std::string</code>类型的临时变量，并将该临时对象传递给<code>push_back</code>**。换言之，他们把这句调用看作下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyy&quot;</span>));   <span class="comment">//创建std::string类型的临时对象</span></span><br><span class="line">                                    <span class="comment">//并将其传递给push_back</span></span><br></pre></td></tr></table></figure>

<p>这段代码顺利通过编译并且运行无误，所有人都开心地打卡下班了。所有人，除了那些性能狂人们，正是他们，认识到这段代码不像它应有的那样高效。</p>
<h4 id="1-2-push-back的实际操作流程"><a href="#1-2-push-back的实际操作流程" class="headerlink" title="1.2 push_back的实际操作流程"></a>1.2 push_back的实际操作流程</h4><p>为了在持有<code>std::string</code>类型对象的容器中创建一个新的元素，他们明白，调用一次<code>std::string</code>的构造函数是应该的，但是上面的代码不会只发生一次构造函数调用。<strong>实际上，发生了两次</strong>。并且，还发生了一次<code>std::string</code>的析构函数调用。以下是对<code>push_back</code>的调用在运行期执行的全部动作：</p>
<blockquote>
<p>a. 从字符串字面量<code>xyy</code>触发，创建<code>std::string</code>类型的临时对象。该对象没有名字，我们称之为<code>temp</code>。针对<code>temp</code>实施的构造，就是第一次的<code>std::string</code>构造函数的调用。因为是个临时对象，所以<code>temp</code>是个右值。</p>
</blockquote>
<blockquote>
<p>b. <code>temp</code>被传递给<code>push_back</code>的右值重载版本，在那里它被绑定到右值引用形参<code>x</code>。然后，会在内存中为<code>std::vector</code>构造一个<code>x</code>的副本。这一次的构造（已经是第二次）结果就是在<code>std::vector</code>内创建了一个新的对象（用于将<code>x</code>复制到<code>std::vector</code>的构造函数，是移动构造函数，因为作为右值引用的<code>x</code>，在复制之前被转换成了右值。有关将右值引用形式强制转型到右值的相关信息，参见Item 25）。</p>
</blockquote>
<blockquote>
<p>c. 紧接着<code>push_back</code>返回的那一时刻，<code>temp</code>就被析构，所以，这就需要调用一次<code>std::string</code>的析构函数。</p>
</blockquote>
<p>性能狂人们肯定会不由自主的注意到，如果有什么办法能将字符串字面量直接传递给上述步骤2中那段在<code>std::string</code>内构造的<code>std::string</code>类型对象的代码，我们也就可以避免先构造再析构<code>temp</code>。这么一来，就可以达到效率最大化，即便是性能狂人也能安心打卡下班了。</p>
<h4 id="1-3-emplace-back的好处"><a href="#1-3-emplace-back的好处" class="headerlink" title="1.3 emplace_back的好处"></a>1.3 emplace_back的好处</h4><p><strong>由于你是名C++程序员，所以你比起其他人群成为性能狂人的概率更高</strong>。即使你不是个性能狂人，你也很可能会认同他们的观点（<strong>如果你对性能不以为意，难道你不应该出门左转到Python之家去吗？</strong>，注：这句话是作者原句，感觉放到现在有点引战的味道。。）所以，我很乐意告诉你，确实有个办法能够使得<code>push_back</code>调用过程的效率最大化。办法就是不要调用<code>push_back</code>。调用<code>push_back</code>是弄错了函数。符合要求的函数是<code>emplace_back</code>。</p>
<p><code>emplace_back</code>完全符合期望：它使用传入的任何实参在<code>std::vector</code>内构造一个<code>std::string</code>。不会涉及任何临时对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyy&quot;</span>);         <span class="comment">//直接从`xyy`出发，在vs内</span></span><br><span class="line">                                <span class="comment">//构造std::string类型对象</span></span><br></pre></td></tr></table></figure>

<p><code>emplace_back</code>使用了完美转发，所以只要你没有遭遇完美转发的限制（<a target="_blank" rel="noopener" href="https://blog.csdn.net/aiyanzielf/article/details/110456319">Item 30</a>），就可以通过<code>emplace_back</code>传递任意类型的任意数量和任意组合的实参。例如，如果你想通过<code>std::string</code>的那个接受一个字符及重复技术的构造函数重载版本来创建一个<code>std::string</code>类型对象，下面的代码就可以做到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);       <span class="comment">//插入一个由50个`x`字符组成的</span></span><br><span class="line">                                <span class="comment">//consisting std::string 类型对象</span></span><br></pre></td></tr></table></figure>

<p><code>emplace_back</code>可用于任何支持<code>push_back</code>的标准容器。相似的，所有支持<code>push_front</code>的标准容器也支持<code>emplace_front</code>。还有，任何支持插入操作（即，除了<code>std::forward_list</code>和<code>std::array</code>以外的所有标准容器）都支持置入操作。关联容器提供了<code>emplace_hint</code>来补充它们带有<code>hint</code>迭代器的<code>insert</code>函数，而<code>std::forward_list</code>也有着<code>emplace_after</code>与其<code>insert_after</code>一唱一和。</p>
<h4 id="1-4-emplace-back为何能超越push-back"><a href="#1-4-emplace-back为何能超越push-back" class="headerlink" title="1.4 emplace_back为何能超越push_back"></a>1.4 emplace_back为何能超越push_back</h4><p>使得置入函数超越插入函数成为可能的，是置入函数更加灵活的接口。插入函数接受的是待插入对象，而置入函数接受的则是待插入对象的构造函数实参。这一区别就让置入函数得以避免临时对象的创建和析构，但插入函数就无法避免。</p>
<p>因为具备容器所持有之物的实参可以被传递给一个置入函数（而后，该实参会引发函数执行复制或移动构造），所以即使在插入函数并不要求创建临时对象的情况下，也可以使用置入函数。在那种情况下，插入函数和置入函数本质上做的是同一件事。例如，给出下面的<code>std::string</code>类型对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">queenofDisco</span><span class="params">(<span class="string">&quot;Donna Summer&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面两个调用语句都成立，并且对容器来说，<strong>净效果相同</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(queenofDisco);     <span class="comment">//在vs的尾部复制构造了queenofDisco</span></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(queenofDisco);  <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<h3 id="2-看似完美的emplace-back也有不足"><a href="#2-看似完美的emplace-back也有不足" class="headerlink" title="2. 看似完美的emplace_back也有不足"></a>2. 看似完美的emplace_back也有不足</h3><p>这么一来，置入函数就能做到插入函数所能做到的一切。有时，他们可以比后者做的更高效一些，而且，至少在理论上，它们应该不会比后者效率更低。既然如此，何不总是使用置入函数呢？</p>
<p>因为，从理论上说，理论和实践没有区别，但从实践上说，理论和实践是有区别的。从标准库的当前实现情况来看，在有些情况下，正如预期的那样，置入的性能优于插入，但是，不幸的是，<strong>还是存在插入函数运行得更快的情况</strong>。后面一种情况不太容易表征，因为具体来说，取决于：</p>
<blockquote>
<p>a. 传递的实参类型<br>b. 使用的容器种类<br>c. 请求插入或置入的容器位置<br>d. 所持有类型构造函数的异常安全性<br>e. 还有，对于禁止出现重复的容器（即，<code>std::set</code>,<code>std::map</code>,<code>std::unordered_set</code>和<code>std::unordered_map</code>）而言，容器中是否已经存在要添加的值。</p>
</blockquote>
<p>所以，这里适用一般的性能调优建议：<strong>欲确定置入或插入哪个运行更快，需对两者实施基准测试</strong>。</p>
<h4 id="2-1-emplace系列效率更高的前提"><a href="#2-1-emplace系列效率更高的前提" class="headerlink" title="2.1 emplace系列效率更高的前提"></a>2.1 emplace系列效率更高的前提</h4><p>这样的说法当然不尽如人意，所以你肯定会高兴的得知，有一种启发式思路可以帮助确定置入功能在哪些情况下极有可能值得一试。<strong>如果下列情况都成立，那么置入将几乎肯定比插入更高效</strong>。</p>
<ul>
<li><strong>欲添加的值是以构造而非赋值方式加入容器</strong>。本条款第一例（即从<code>xyy</code>出发创建<code>std::string</code>类型对象，并加入<code>std::vector</code>），就能看出该值是被添加到了<code>vs</code>的结尾，该位置尚不存在对象。是故，新值必须以构造方式加入<code>std::vector</code>。若我们修订此例，使得新的<code>std::string</code>类型对象去到某个已被某对象占据的位置，则完全变成另一回事了。考虑如下代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt;  vs;   <span class="comment">//同前</span></span><br><span class="line">...                             <span class="comment">//向vs中添加元素</span></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(vs.<span class="built_in">begin</span>(), <span class="string">&quot;xyy&quot;</span>); <span class="comment">//向vs的开头添加`xyy`</span></span><br></pre></td></tr></table></figure>

<p>对于这代码，很少会有实现是将待添加的<code>std::string</code>在由<code>vs[0]</code>占用的内存中实施构造。这里一般会采用不同的手法，即移动赋值的方式来让该值就位。但既然是移动赋值，总要有个作为源的移动对象，也就是意味着需要创建一个临时对象作为移动的源。由于置入相对于插入的<strong>主要优点在于既不会创建也不会析构临时对象，那么当添加的值是经由赋值放入容器的时候，置入的边际效用也就趋于消失了</strong>。</p>
<p>哎，向容器中添加值究竟是通过构造还是赋值，这一般取决于实现者。但是，启发式思维会再一次派上用场。</p>
<p><strong>基于节点的容器几乎总是使用构造来添加新值，而大多数标准容器都是基于节点的</strong>。仅有的一些例外是<code>std::vector</code>,<code>std::deque</code>和<code>std::string</code>(<code>std::array</code>也不基于节点，但它根本不支持插入或置入，所以和这里的讨论不相干)。在非基于节点的容器中，可以可靠的说，<code>emplace_back</code>是使用构造函数非赋值来将新值就位的，而这一点对于<code>std::deque</code>的<code>emplace_front</code>来说也一样成立。</p>
<ul>
<li>传递的实参类型与容器持有物的类型不同。可以再次看出，置入相对于插入的优势通常源于这一个事实，即当传递的实参类型并非容器持有之物的类型时，其接口不要求创建和析构临时对象。当类型为<code>T</code>的对象被添加到<code>container&lt;T&gt;</code>中时，没有理由期望置入的运行速度会比插入快，因为并不需要为了满足插入的接口去创建临时对象。</li>
<li>容器不太可能由于出现重复情况而拒绝待添加的新值。这意味着，或者是容器允许重复值，或者所添加的大部分值都满足唯一性。这个因素之所以值得一提，是因为，欲检测某值是否已经在容器中，置入的实现通常会使用该新值创建一个节点，以便将该节点的值与容器的现有节点进行比较。如果待添加的值尚不在容器中，则将节点链入该容器。但是，如果该节点已经存在，则置入就会中止，节点也就会实施析构，这意味着其构造和析构的成本是被浪费掉了。</li>
</ul>
<p>下述前面已列出的调用语句满足所有的判断准则。它们就比对应的<code>push_back</code>调用要运行的更快。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyy&quot;</span>);     <span class="comment">//在容器尾部以构造新值</span></span><br><span class="line">                            <span class="comment">//传递和类型有异于容器持有之物的类型</span></span><br><span class="line">                            <span class="comment">//未使用拒绝重复值的容器</span></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);   <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-emplace系列在资源管理对象就地构造的时候，最好不要用"><a href="#2-2-emplace系列在资源管理对象就地构造的时候，最好不要用" class="headerlink" title="2.2 emplace系列在资源管理对象就地构造的时候，最好不要用"></a>2.2 emplace系列在资源管理对象就地构造的时候，最好不要用</h4><p>在决定是否选用置入函数时，还有其他两个问题值得操心。第一个和资源管理有关。假定你有个持有<code>std::shared_ptr&lt;Widget&gt;</code>类型对象的容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::shared_ptr&lt;Widget&gt;&gt; ptrs;</span><br></pre></td></tr></table></figure>

<p>而你想向其添加一个需要通过自定义删除器来释放的(参见Item 19) <code>std::shared_ptr</code>。Item 21解释过，只要可行，你就应该使用<code>std::make_shared</code>来创建<code>std::shared_ptr</code>类型的对象，但它同时也认可，在某些情况下你无法这样做。而其中之一，就是需要指定自定义删除器的情况。在此情况下，就必须直接使用<code>new</code>来获取裸指针以备<code>std::shared_ptr</code>加以管理。</p>
<p>如果自定义删除器就是下面这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">killWidget</span><span class="params">(Widget* pWidget)</span></span>;</span><br></pre></td></tr></table></figure>

<p>也可能长成这样，但意义相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrs.<span class="built_in">push_back</span>(&#123; <span class="keyword">new</span> Widget, killWidget &#125;);</span><br></pre></td></tr></table></figure>

<p>不管写成上面两者中的哪样，在调用<code>push_back</code>之前，都会创建一个<code>std::shared_ptr</code>类型的临时对象。<code>push_back</code>的形参是个<code>std::shared_ptr</code>类型的引用，所以必须存在一个<code>std::shared_ptr</code>类型独享来让该形参指涉到。</p>
<p>如果选用了<code>emplace_back</code>，本可以避免创建<code>std::shared_ptr</code>类型的临时独享，但是在本例的情况下，该临时对象带来的收益远超其成本。考虑下面这个有可能发生的事件序列：</p>
<ol>
<li>上述两个调用语句无论哪个都会构造一个<code>std::shared_ptr&lt;Widget&gt;</code>类型的临时对象，用以持有从<code>new Widget</code>返回的裸指针。该对象暂称为<code>temp</code>。</li>
<li><code>push_back</code>会按引用方式接受<code>temp</code>。在为链表节点分配内存以持有<code>temp</code>的副本的过程中，抛出了内存不足的异常。</li>
<li>该异常传播到了<code>push_back</code>之外，<code>temp</code>被析构。作为给<code>Widget</code>兜底的、指涉到它并对其施加管理的<code>std::shared_ptr&lt;Widget&gt;</code>类型对象会自动释放该<code>Widget</code>，在本例的情况下，会调用<code>killWidget</code>达成该目的。</li>
</ol>
<p>即使发生异常，也没有资源泄露。在<code>push_back</code>的调用过程中，从<code>new Widget</code>出发构造的<code>Widget</code>，会在为管理它创建的<code>std::shared_ptr</code>(temp)的析构函数中得到释放，岁月静好。</p>
<p>现在考虑 一下，如果调用的是<code>emplace_back</code>，而不是<code>push_back</code>，会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrs.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> Widget, killWidget);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>从<code>new Widget</code>返回的裸指针被完美转发，并运行到<code>emplace_back</code>内为链表节点分配内存的执行点。然而，该内存分配失败，并抛出了内存不足的异常。</p>
</li>
<li><p>该异常传播到了<code>emplace_back</code>之外，作为唯一可以获取堆上<code>Widget</code>的抓手的裸指针，却丢失了。那个<code>Widget</code>(连同他拥有的任何资源)都发生了泄漏。</p>
</li>
</ol>
<p>在这种场景下，岁月不再静好，并且故障不能归罪于<code>std::shared_ptr</code>。即使换用<code>std::unique_ptr</code>的自定义删除器，同样的问题仍然可能会现身。从根本上讲，像<code>std::shared_ptr</code>和<code>std::unique_ptr</code>这样的资源管理类若要发挥作用，前提是资源（比如从new出发的裸指针）会立即传递给资源管理对象的构造函数。<code>std::make_shared</code>和<code>std::make_unique</code>这样的函数会把这一点自动化，这个事实真是为何他们如此重要的原因之一。</p>
<p>在调用持有资源管理对象的容器（例如，<code>std::list&lt;std::shared_ptr&lt;Widget&gt;&gt;</code>）的插入函数时，函数的形参类型通常能确保在资源的获取（例如，运用new）和对资源管理的对象实施构造之间不再有任何其他动作。而在置入函数中，完美转发会推迟资源管理对象的创建，直到他们能够在容器的内存中构造为止。这开了一个“天窗”，其中就会因异常而导致资源泄露。所有的标准容器对此都在劫难逃。在处理持有资源管理对象的容器时，必须小心确保在选用了置入而非插入函数时，不会在提升了一点代码效率的同时，却因异常安全性的削弱而赔的精光。</p>
<p>坦率地说，绝不应该把像<code>new Widget</code>这样的表达式传递给<code>emplace_back</code>、<code>push_back</code>或者大多数其他函数，因为正如Item 21所解释过的，这可能会导致我们刚才所讨论的异常安全问题。要把这扇门关闭，就需要从<code>new Widget</code>中获取指针并将其在独立语句中转交给其他资源管理对象，然后将该对象作为右值传递给你最初想要向其传递<code>new Widget</code>的函数，Item 21涵盖了该技术的更多细节。所以，选用了<code>push_back</code>的代码有应该这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, </span></span></span><br><span class="line"><span class="params"><span class="function">                            killWidget)</span></span>;    <span class="comment">//构造Widget并用spw管理它</span></span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(spw));             <span class="comment">//以右值形式添加spw</span></span><br></pre></td></tr></table></figure>

<p>选用了<code>emplace_back</code>的版本十分类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line">ptrs.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(spw));  </span><br></pre></td></tr></table></figure>

<p>无论选用哪个，这个途径都会产生了构造和析构<code>spw</code>的成本。考虑选用置入而非插入的动机就在于避免容器所持有之物的类型的临时对象的成本，而这成本正是<code>spw</code>所体现的概念，当你向容器中添加的是资源管理对象，并遵循了正确的做法以确保在资源的获取和将其移交给资源管理对象之间没有任何多余的动作的话，置入函数的性能表现就不太会在此情形下仍然超越插入函数。</p>
<h4 id="2-3-emplace系列在带有explicit声明饰词的构造函数，慎用"><a href="#2-3-emplace系列在带有explicit声明饰词的构造函数，慎用" class="headerlink" title="2.3 emplace系列在带有explicit声明饰词的构造函数，慎用"></a>2.3 emplace系列在带有explicit声明饰词的构造函数，慎用</h4><p>置入函数第二个值得一提的方面，是它们与带有<code>explicit</code>声明饰词的构造函数之间的互动。假设你为了表彰C++11对正则表达式的支持，构造了一个正则表达式对象的容器:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt;   regexes;</span><br></pre></td></tr></table></figure>

<p>由于别你的同事们为了“每天该上多少次社交网站才最理想”的争论而分了心，你无意间写下了下面这句看似无意义的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);  <span class="comment">//向持有正则表达式的容器添加了一个nullptr?</span></span><br></pre></td></tr></table></figure>

<p>你在输入时没有注意到该错误，而编译器也一声不吭地接受了代码，最终你浪费了大把时间来调试，找了半天，你终于发现自己在正则表达式容器中插入了一个空指针。但这怎么可能呢？指针本根不是正则表达式啊，而且如果你试图这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::regex r = <span class="literal">nullptr</span>;         <span class="comment">//错误！无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>编译器会拒绝你的代码。有意思的是，如果你选用的是<code>push_back</code>而非<code>emplace_back</code>，编译器同样也会拒绝你的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexes.push_back(nullptr);     //错误！无法通过编译</span><br></pre></td></tr></table></figure>

<p>这种令人好奇的行为源自于<code>std::regex</code>对象可以从字符串触发来构造这一事实。这就使得下面这样有用的代码成为合法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex  <span class="title">uppperCaseWord</span><span class="params">(<span class="string">&quot;[A-Z]+&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从字符串出发来构造<code>std::regex</code>类型对象，肯定会导致相对较高昂的运行期成本，因此，为了尽可能地减少无意间招致这种开销的可能性，接受<code>const char *</code>指针的<code>std::regex</code>构造函数以<code>explicit</code>饰词声明。这就是为何下面几个语句都通不过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::regex r = <span class="literal">nullptr</span>;         <span class="comment">//错误！无法通过编译</span></span><br><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);     <span class="comment">//错误！无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>在两种情况下，我们都要求了一次从指针到<code>std::regex</code>的隐式类型转换，而由于该构造函数带有<code>explicit</code>饰词声明，这样的类型转换被阻止了。</p>
<p>然而，在<code>emplace_back</code>的调用过程中，我们却没有声称传递的是个<code>std::regex</code>对象。取而代之的是，我们向<code>std::regex</code>对象传递的是个构造函数实参。这不但不被视作隐式类型转换的请求，反而在编译器看来是等同于写了这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex  <span class="title">r</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;         <span class="comment">//能编译</span></span><br></pre></td></tr></table></figure>

<p>如果简短的注释“能编译”暗示着一种无精打采，那是好事，因为这段代码虽然能通过编译，但却有着未定义行为。接受<code>const char*</code>指针的<code>std::regex</code>构造函数要求指涉到的字符串包含一个有意义的正则表达式，而空指针并不符合该要求。如果你编写并编译这样的代码，<strong>你能指望的最好结果就是它在运行时崩溃</strong>。如果你不那么走运，你和你的调试器可能得亲密好一阵子了。</p>
<p>先把<code>push_back</code>和<code>emplace_back</code>和亲密什么的按下不表，单注意下面几个非常相似的初始化语法如何蝉产生了不同的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::regex  r1 = <span class="literal">nullptr</span>;       <span class="comment">//错误！无法通过编译</span></span><br><span class="line"><span class="function">std::regex <span class="title">r2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;         <span class="comment">//能编译</span></span><br></pre></td></tr></table></figure>

<p>用标准的官方术语来说，用于初始化<code>r1</code>（采用等号）的语法对应于所谓的复制初始化。相对的，用于初始化<code>r2</code>的语法（使用括号，尽量也可以使用花括号代替）会产生所谓的直接初始化。复制初始化是不允许调用带有<code>explicit</code>声明饰词的构造函数的，但直接初始化就允许。是故，对<code>r1</code>实施初始化的那一行通不过编译，但对<code>r2</code>实施初始化的那一行就可以通过编译。</p>
<p>但是，回过头来再说<code>push_back</code>和<code>emplace_back</code>，或更一般地对插入函数和置入函数作对比。置入函数使用的是直接初始化，所以他们就能够调用带有<code>explicit</code>声明饰词的构造函数。而插入函数使用的是复制初始化，它们就不能调用带有<code>explicit</code>声明饰词的构造函数。因此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);      <span class="comment">//能编译，直接初始化允许使用</span></span><br><span class="line">                                    <span class="comment">//接受指针的，带有explicit声明饰词的</span></span><br><span class="line">                                    <span class="comment">//std::regex构造函数</span></span><br><span class="line"></span><br><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);         <span class="comment">//错误！复制初始化禁止使用</span></span><br><span class="line">                                    <span class="comment">//那个构造函数</span></span><br></pre></td></tr></table></figure>

<p>这里得到的教训是，在使用置入函数时，要特别小心去保证传递了正确的实参，因为即使是带有<code>explicit</code>声明饰词的构造函数也会被编译器纳入考虑范围，因为它会尽力去找到某种方法来解释你的代码以使得它合法。</p>
<table>
<thead>
<tr>
<th>要点速记</th>
</tr>
</thead>
<tbody><tr>
<td>1. 从原理上说，置入函数应该有时比对应的插入函数高效，而不应该有更低效的可能。</td>
</tr>
<tr>
<td>2. 从实践上说，置入函数在以下几个前提条件<strong>均成立</strong>时，极有可能会运行的更快：a. 待添加的值是以构造而非赋值方式加入容器；b. 传递的实参类型与容器持有之物的类型不同；c. 容器不会由于存在重复值而拒绝待添加的值。</td>
</tr>
<tr>
<td>3. 置入函数可能会执行在插入函数中被拒绝的类型转换。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fang</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
