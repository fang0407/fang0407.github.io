<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fang0407.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="NOTE">
<meta property="og:url" content="https://fang0407.github.io/page/3/index.html">
<meta property="og:site_name" content="NOTE">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Fang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fang0407.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NOTE</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">NOTE</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/12/07/Janus%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/07/Janus%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">Janus搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-07 20:21:42" itemprop="dateCreated datePublished" datetime="2023-12-07T20:21:42+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:39:19" itemprop="dateModified" datetime="2023-12-30T22:39:19+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Janus/" itemprop="url" rel="index"><span itemprop="name">Janus</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Janus 是⼀个开源的，通过 C 语⾔实现了对 WebRTC ⽀持的 Gateway；Janus ⾃身实现得很简单，提供插件机制来⽀持不同的业务逻辑，配合官⽅⾃带插件就可以⽤来实现⾼效的 Media Server 服务。</p>
<p>本⽂主要介绍如何在 Ubuntu 16.04 下搭建起 janus 服务器，实现 janus 官⽅ Demo 浏览器与 Android APP Demo（janus-gateway-android）之间的⾳视频通话。 </p>
<h1 id="命令安装依赖"><a href="#命令安装依赖" class="headerlink" title="命令安装依赖"></a>命令安装依赖</h1><p>编译运⾏ Janus Server 需要依赖较多的⼀些第三⽅库，⽽这些依赖库在 Ubuntu 下主要通过 aptitude 进⾏安装，⾸先通过安装 aptitude：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br></pre></td></tr></table></figure>

<p>Ubuntu 下通过 aptitude 批量安装依赖⼯具包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude install libmicrohttpd-dev libjansson-dev libnice-dev \</span><br><span class="line">	libssl1.0.1-dev libsrtp-dev libsofia-sip-ua-dev libglib2.3.4-dev \</span><br><span class="line">	libopus-dev libogg-dev libcurl4-openssl-dev pkg-config gengetopt \</span><br><span class="line">	libtool automake</span><br><span class="line">	</span><br><span class="line">sudo apt install cmake</span><br><span class="line">sudo aptitude install libconfig-dev</span><br><span class="line">sudo aptitude install libssl-dev</span><br><span class="line">sudo aptitude install doxygen graphviz</span><br><span class="line"></span><br><span class="line"># ffmpeg库 ⽀持--enable-post-processing</span><br><span class="line">sudo aptitude install libavcodec-dev libavformat-dev libswscale-dev libavutil-dev</span><br></pre></td></tr></table></figure>

<h1 id="源码安装依赖"><a href="#源码安装依赖" class="headerlink" title="源码安装依赖"></a>源码安装依赖</h1><h2 id="安装WebSocket"><a href="#安装WebSocket" class="headerlink" title="安装WebSocket"></a>安装WebSocket</h2><p>janus ⽀持 WebSocket 是可选项，如果不安装，编译 janus 时，默认不⽀持 WebSocket 的链接请求，⽽ Android APP Demo 是通过 WebSocket 与 janus 进⾏通信的，因为我们希望 Android APP Demo 能与浏览器（HTTP）进⾏视频通话，所以就必须要在编译 janus 时⽀持 WebSocket。</p>
<p>依次执⾏以下命令，分别进⾏下载，编译，安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/warmcat/libwebsockets.git</span><br><span class="line">cd libwebsockets</span><br><span class="line">git branch -a 查看选择最新的稳定版本</span><br><span class="line">git checkout v3.2-stable 切换到最新稳定版本</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr -DCMAKE_C_FLAGS=&quot;-fpic&quot; ..</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>安装成功后，在编译 janus 时，janus 默认会增加对 WebSocket 的集成，或者通过增加编译参数 <code>--enable-websockets</code> 打开 WebSocket 开关。</p>
<h2 id="安装libsrtp"><a href="#安装libsrtp" class="headerlink" title="安装libsrtp"></a>安装libsrtp</h2><p>Janus 需要⾄少 version 1.5 以上的 libsrtp，如果系统中已经安装了 libsrtp，则⾸先卸载后，⼿动安装新版本，这⾥我们安装 libsrtp 2.2，依次执⾏以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/cisco/libsrtp/archive/v2.2.0.tar.gz</span><br><span class="line">tar xfv v2.2.0.tar.gz</span><br><span class="line">cd libsrtp-2.2.0</span><br><span class="line">./configure --prefix=/usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="安装libusrsctp"><a href="#安装libusrsctp" class="headerlink" title="安装libusrsctp"></a>安装libusrsctp</h2><p>libusrsctp⽀持<code>--enable-data-channels</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Kurento/libusrsctp.git</span><br><span class="line">cd libusrsctp</span><br><span class="line">./bootstrap</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="安装libmicrohttpd"><a href="#安装libmicrohttpd" class="headerlink" title="安装libmicrohttpd"></a>安装libmicrohttpd</h2><p>libmicrohttpd⽀持<code>--enable-rest</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/libmicrohttpd/libmicrohttpd-0.9.71.tar.gz</span><br><span class="line">tar zxf libmicrohttpd-0.9.71.tar.gz</span><br><span class="line">cd libmicrohttpd-0.9.71/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="编译Janus"><a href="#编译Janus" class="headerlink" title="编译Janus"></a>编译Janus</h2><p>通过 Git 下载 Janus 源码，并编译安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/meetecho/janus-gateway.git</span><br><span class="line">git tag 查看当前的 tag</span><br><span class="line">git checkout v0.10.4</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure --prefix=/opt/janus --enable-websockets --enable-post-processing --enable-docs --enable-rest --enable-data-channels</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>Janus安装到 <code>/opt/janus</code> 路径，插件的so库在 <code>/opt/janus/lib/janus/plugins</code>。</p>
<h1 id="配置和运⾏Janus"><a href="#配置和运⾏Janus" class="headerlink" title="配置和运⾏Janus"></a>配置和运⾏Janus</h1><h2 id="配置启动nginx"><a href="#配置启动nginx" class="headerlink" title="配置启动nginx"></a>配置启动nginx</h2><p>安装nginx，主要⽤来提供web访问。</p>
<p><strong>⽣成证书</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/cert</span><br><span class="line">cd ~/cert</span><br><span class="line"># CA私钥</span><br><span class="line">openssl genrsa -out key.pem 2048</span><br><span class="line"># ⾃签名证书</span><br><span class="line">openssl req -new -x509 -key key.pem -out cert.pem -days 1095</span><br></pre></td></tr></table></figure>

<p><strong>安装nginx</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#下载nginx 1.15.8版本</span><br><span class="line">wget http://nginx.org/download/nginx-1.15.8.tar.gz</span><br><span class="line">tar xvzf nginx-1.15.8.tar.gz</span><br><span class="line">cd nginx-1.15.8/</span><br><span class="line"></span><br><span class="line"># 配置，⼀定要⽀持https</span><br><span class="line">./configure --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p><strong>修改nginx配置⽂件</strong></p>
<p>nginx配置文件路径<code>/usr/local/nginx/conf/nginx.conf</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTPS server</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">            <span class="comment"># 配置相应的key</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /root/cert/cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /root/cert/key.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span>    shared:SSL:<span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line">            <span class="comment"># 指向janus demo所在目录</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /opt/janus/share/janus/demos;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动nginx</strong></p>
<p><code>sudo /usr/local/nginx/sbin/nginx</code></p>
<p>可以访问到界面，但此时还不能正常通话。</p>
<h2 id="安装启动coturn"><a href="#安装启动coturn" class="headerlink" title="安装启动coturn"></a>安装启动coturn</h2><p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install libevent-dev</span><br><span class="line"></span><br><span class="line">wget http://coturn.net/turnserver/v4.5.0.7/turnserver-4.5.0.7.tar.gz</span><br><span class="line">tar xfz turnserver-4.5.0.7.tar.gz</span><br><span class="line">cd turnserver-4.5.0.7</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p><strong>启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo turnserver -L 0.0.0.0 --min-port 50000 --max-port 60000  -a -u test:123456 -v -f -r nort.gov</span><br></pre></td></tr></table></figure>

<h2 id="启动Video-Room"><a href="#启动Video-Room" class="headerlink" title="启动Video Room"></a>启动Video Room</h2><h3 id="jcfg文件"><a href="#jcfg文件" class="headerlink" title="jcfg文件"></a>jcfg文件</h3><p>上述Janus安装目录在<code>/opt/janus</code>。其中各个目录的作用：</p>
<table>
<thead>
<tr>
<th>bin</th>
<th>etc</th>
<th>include</th>
<th>lib</th>
<th>share</th>
</tr>
</thead>
<tbody><tr>
<td>可执行文件</td>
<td>janus配置文件</td>
<td>janus头文件</td>
<td>janus库</td>
<td>存放脚本或者文档，web demo也在这里</td>
</tr>
</tbody></table>
<p>要先把.sample后缀的文件拷贝成jcfg后缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 进到对应的目录</span><br><span class="line">cd /opt/janus/etc/janus</span><br><span class="line"></span><br><span class="line"># 拷贝文件</span><br><span class="line">sudo cp janus.jcfg.sample janus.jcfg</span><br><span class="line">sudo cp janus.transport.http.jcfg.sample janus.transport.http.jcfg</span><br><span class="line">sudo cp janus.transport.websockets.jcfg.sample janus.transport.websockets.jcfg</span><br><span class="line">sudo cp janus.plugin.videoroom.jcfg.sample janus.plugin.videoroom.jcfg</span><br><span class="line">sudo cp janus.transport.pfunix.jcfg.sample janus.transport.pfunix.jcfg</span><br><span class="line">sudo cp janus.plugin.streaming.jcfg.sample janus.plugin.streaming.jcfg</span><br><span class="line">sudo cp janus.plugin.recordplay.jcfg.sample janus.plugin.recordplay.jcfg</span><br><span class="line">sudo cp janus.plugin.voicemail.jcfg.sample janus.plugin.voicemail.jcfg</span><br><span class="line">sudo cp janus.plugin.sip.jcfg.sample janus.plugin.sip.jcfg</span><br><span class="line">sudo cp janus.plugin.nosip.jcfg.sample janus.plugin.nosip.jcfg</span><br><span class="line">sudo cp janus.plugin.textroom.jcfg.sample  janus.plugin.textroom.jcfg</span><br><span class="line">sudo cp janus.plugin.echotest.jcfg.sample janus.plugin.echotest.jcfg</span><br></pre></td></tr></table></figure>

<h3 id="配置janus-jcfg"><a href="#配置janus-jcfg" class="headerlink" title="配置janus.jcfg"></a>配置janus.jcfg</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 搜索 stun_server 修改：</span><br><span class="line">stun_server = &quot;IP地址&quot;</span><br><span class="line">stun_port = 3478</span><br><span class="line">nice_debug = false       </span><br><span class="line"></span><br><span class="line"># 搜索 turn_server 修改：</span><br><span class="line">turn_server = &quot;IP地址&quot;</span><br><span class="line">turn_port = 3478</span><br><span class="line">turn_type = &quot;udp&quot;</span><br><span class="line">turn_user = &quot;test&quot;</span><br><span class="line">turn_pwd = &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<h3 id="配置janus-transport-http-jcfg"><a href="#配置janus-transport-http-jcfg" class="headerlink" title="配置janus.transport.http.jcfg"></a>配置janus.transport.http.jcfg</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">general: &#123;</span><br><span class="line">        #events = true              # Whether to notify event handlers about transport events (default=true)</span><br><span class="line">        json = &quot;indented&quot;           # Whether the JSON messages should be indented (default),</span><br><span class="line">                                    # plain (no indentation) or compact (no indentation and no spaces)</span><br><span class="line">        base_path = &quot;/janus&quot;        # Base path to bind to in the web server (plain HTTP only)</span><br><span class="line">        threads = &quot;unlimited&quot;       # unlimited=thread per connection, number=thread pool</span><br><span class="line">        http = true                 # Whether to enable the plain HTTP interface</span><br><span class="line">        port = 8088                 # Web server HTTP port</span><br><span class="line">        #interface = &quot;eth0&quot;         # Whether we should bind this server to a specific interface only</span><br><span class="line">        #ip = &quot;192.168.0.1&quot;     # Whether we should bind this server to a specific IP address (v4 or v6) only</span><br><span class="line">        https = true           # Whether to enable HTTPS (default=false)</span><br><span class="line">        secure_port = 8089     # Web server HTTPS port, if enabled</span><br><span class="line">        #secure_interface = &quot;eth0&quot;    # Whether we should bind this server to a specific interface only</span><br><span class="line">        #secure_ip = &quot;192.168.0.1&quot;    # Whether we should bind this server to a specific IP address (v4 or v6) only</span><br><span class="line">        #acl = &quot;127.,192.168.0.&quot;   # Only allow requests coming from this comma separated list of addresses</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">certificates: &#123;</span><br><span class="line">        cert_pem = &quot;/root/cert/cert.pem&quot;</span><br><span class="line">        cert_key = &quot;/root/cert/key.pem&quot;</span><br><span class="line">        #cert_pwd = &quot;secretpassphrase&quot;</span><br><span class="line">        #ciphers = &quot;PFS:-VERS-TLS1.0:-VERS-TLS1.1:-3DES-CBC:-ARCFOUR-128&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置janus-transport-websockets-jcfg"><a href="#配置janus-transport-websockets-jcfg" class="headerlink" title="配置janus.transport.websockets.jcfg"></a>配置janus.transport.websockets.jcfg</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">general: &#123;</span><br><span class="line">        #events = true            # Whether to notify event handlers about transport events (default=true)</span><br><span class="line">        json = &quot;indented&quot;         # Whether the JSON messages should be indented (default),</span><br><span class="line">                                  # plain (no indentation) or compact (no indentation and no spaces)</span><br><span class="line">        #pingpong_trigger = 30    # After how many seconds of idle, a PING should be sent</span><br><span class="line">        #pingpong_timeout = 10    # After how many seconds of not getting a PONG, a timeout should be detected</span><br><span class="line"></span><br><span class="line">        ws = true                 # Whether to enable the WebSockets API</span><br><span class="line">        ws_port = 8188            # WebSockets server port</span><br><span class="line">        #ws_interface = &quot;eth0&quot;    # Whether we should bind this server to a specific interface only</span><br><span class="line">        #ws_ip = &quot;192.168.0.1&quot;    # Whether we should bind this server to a specific IP address only</span><br><span class="line">        wss = true                # Whether to enable secure WebSockets</span><br><span class="line">        wss_port = 8989           # WebSockets server secure port, if enabled</span><br><span class="line">        #wss_interface = &quot;eth0&quot;   # Whether we should bind this server to a specific interface only</span><br><span class="line">        #wss_ip = &quot;192.168.0.1&quot;   # Whether we should bind this server to a specific IP address only</span><br><span class="line">        #ws_logging = &quot;err,warn&quot;  # libwebsockets debugging level as a comma separated list of things</span><br><span class="line">                                  # to debug, supported values: err, warn, notice, info, debug, parser,</span><br><span class="line">                                  # header, ext, client, latency, user, count (plus &#x27;none&#x27; and &#x27;all&#x27;)</span><br><span class="line">        #ws_acl = &quot;127.,192.168.0.&quot;   # Only allow requests coming from this comma separated list of addresses</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">certificates: &#123;</span><br><span class="line">        cert_pem = &quot;/root/cert/cert.pem&quot;</span><br><span class="line">        cert_key = &quot;/root/cert/key.pem&quot;</span><br><span class="line">        #cert_pwd = &quot;secretpassphrase&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改网页默认支持的wss协议"><a href="#修改网页默认支持的wss协议" class="headerlink" title="修改网页默认支持的wss协议"></a>修改网页默认支持的wss协议</h3><p>修改 <code>/opt/janus/share/janus/demos/videoroomtest.js</code>文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span> === <span class="string">&#x27;http:&#x27;</span>)</span><br><span class="line">        server = <span class="string">&quot;http://&quot;</span> + <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span> + <span class="string">&quot;:8088/janus&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        server = <span class="string">&quot;https://&quot;</span> + <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span> + <span class="string">&quot;:8089/janus&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>将默认的https协议改为wss</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="string">&quot;wss://&quot;</span> + <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span> + <span class="string">&quot;:8989&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="运行-Janus"><a href="#运行-Janus" class="headerlink" title="运行 Janus"></a>运行 Janus</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/janus/bin/janus --debug-level=5 --log-file=$HOME/janus-log</span><br></pre></td></tr></table></figure>

<h3 id="测试web和web的通话"><a href="#测试web和web的通话" class="headerlink" title="测试web和web的通话"></a>测试web和web的通话</h3><p>开两个同样的网页，然后点击Demos中的Video Room的start，输入名字则开始进行音视频通话测试。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/205056453">https://zhuanlan.zhihu.com/p/205056453</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/12/04/WebRtc%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/04/WebRtc%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">WebRtc通信架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-04 21:43:00" itemprop="dateCreated datePublished" datetime="2023-12-04T21:43:00+08:00">2023-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-18 14:13:25" itemprop="dateModified" datetime="2024-01-18T14:13:25+08:00">2024-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/WebRTC/" itemprop="url" rel="index"><span itemprop="name">WebRTC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h1><p>Mesh 方案的结构如下图所示： </p>
<img src="/2023/12/04/WebRtc%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/Mesh架构.png" alt="Mesh架构" style="zoom:50%;">

<p>在上图中，B1、B2、B3、B4 分别表示 4 个浏览器，它们之间两两相连，同时还分别与 STUN&#x2F;TURN 服务器进行连接（此时的 STUN&#x2F;TURN 服务器不能进行数据中转，否则情况会变得非常复杂），这样就形成了一个网格拓扑结构。当某个浏览器想要共享它的音视频流时，它会将共享的媒体流分别发送给其他 3 个浏览器，这样就实现了多人通信。</p>
<p><strong>优点</strong></p>
<ul>
<li>充分利用了客户端的带宽资源。 </li>
<li>节省了服务器资源，因为服务器带宽往往是专线，价格昂贵，所以这种方案可以很好地控制成本。</li>
<li>不需要服务器中转数据，STUN&#x2F;TUTN 只是负责 NAT 穿越，这样利用现有 WebRTC 通信模型就可以实现，而不需要开发媒体服务器。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>共享端共享媒体流的时候，需要给每一个参与人都转发一份媒体流，这样对上行带宽的占用很大。参与人越多，占用的带宽就越大。除此之外，对 CPU、Memory 等资源也是极大的考验。一般来说，客户端的机器资源、带宽资源往往是有限的，资源占用和参与人数是线性相关的。这样导致多人通信的规模非常有限，通过实践来看，这种方案在超过 4 个人时，就会有非常大的问题。</li>
<li>在多人通信时，如果有部分人不能实现 NAT 穿越，但还想让这些人与其他人互通，就显得很麻烦，需要做出更多的可靠性设计。</li>
</ul>
<h1 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h1><p>MCU 主要的处理逻辑是：接收每个共享端的音视频流，经过解码、与其他解码后的音视频进行混流、重新编码，之后再将混好的音视频流发送给房间里的所有人。</p>
<p>MCU 方案的模型是一个星形结构，如下图所示：</p>
<img src="/2023/12/04/WebRtc%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/MCU架构.png" alt="MCU架构" style="zoom:50%;">

<p><strong>优点</strong></p>
<ul>
<li>技术非常成熟，在硬件视频会议中应用非常⼴泛。</li>
<li>作为音视频网关，通过解码、再编码可以屏蔽不同编解码设备的差异化，满足更多客户的集成需求，提升用户体验和产品竞争力。</li>
<li>将多路视频混合成一路，所有参与人看到的是相同的画面，客户体验非常好。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>重新解码、编码、混流，需要大量的运算，对 CPU 资源的消耗很大。</li>
<li>重新解码、编码、混流还会带来延迟。</li>
<li>由于机器资源耗费很大，所以 MCU 所提供的容量有限，一般十几路视频就是上限了。</li>
</ul>
<h1 id="SFU"><a href="#SFU" class="headerlink" title="SFU"></a>SFU</h1><p>SFU 像是一个媒体流路由器，接收终端的音视频流，根据需要转发给其他终端。SFU 在音视频会议中应用非常⼴泛，尤其是 WebRTC 普及以后。支持 WebRTC 多方通信的媒体服务器基本都是 SFU 结构。SFU的拓扑机构和功能模型如下图： </p>
<img src="/2023/12/04/WebRtc%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84/SFU架构.png" alt="SFU架构" style="zoom:50%;">

<p>在这个图中，B1、B2、B3、B4 分别代表 4 个浏览器，每一个浏览器都会共享一路流发给 SFU，SFU 会将每一路流转发给共享者之外的 3 个浏览器。 </p>
<p><strong>优点</strong></p>
<ul>
<li>首先由于是数据包直接转发，不需要编码、解码，对 CPU 资源消耗很小。</li>
<li>其次是 直接转发也极大地降低了延迟，提高了实时性。</li>
<li>最后 带来了很大的灵活性，能够更好地适应不同的网络状况和终端类型。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于是数据包直接转发，参与人观看多路视频的时候可能会出现不同步（mesh、mcu 实际上也是可能出现这种情况）；相同的视频流，不同的参与人看到的画面也可能不一致。 </li>
<li>参与人同时观看多路视频，在多路视频窗口显示、渲染等会带来很多麻烦，尤其对多人实时通信进行录制，多路流也会带来很多回放的困难。总之，整体在通用性、一致性方面比较差。</li>
</ul>
<p>目前许多 SFU 实现都支持 SVC 模式和 Simulcast 模式，用于适配 WiFi、4G 等不同网络状况，以及 Phone、Pad、PC 等不同终端设备。</p>
<p><strong>Simulcast 模式</strong></p>
<p>Simulcast 模式就是指视频的共享者可以同时向 SFU 发送多路不同分辨率的视频流（一般为三路，如 1080P、720P、360P）。而 SFU 可以将接收到的三路流根据各终端的情况而选择其中某一路发送出去。例如，由于 PC 端网络特别好，给 PC 端发送 1080P 分辨率的视频；而移动网络较差，就给 Phone 发送 360P 分辨率的视频。 </p>
<p>Simulcast 模式对移动端的终端类型非常有用，它可以灵活而⼜智能地适应不同的网络环境。</p>
<p><strong>SVC 模式</strong></p>
<p>SVC（Scalable Video Coding） 是可伸缩的视频编码模式。与 Simulcast 模式的同时传多路流不同， </p>
<p>SVC 模式是在视频编码时做“手脚”。 它在视频编码时将视频分成多层——核心层、中间层和扩展层。上层依赖于底层，而且越上层越清晰，越底层越模糊。在带宽不好的情况下，可以只传输底层，即核心层，在带宽充足的情况下，可以将三层全部传输过去。 </p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/466172240">https://zhuanlan.zhihu.com/p/466172240</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/12/01/Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/01/Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Go-并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-01 19:55:25" itemprop="dateCreated datePublished" datetime="2023-12-01T19:55:25+08:00">2023-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-21 21:31:16" itemprop="dateModified" datetime="2024-01-21T21:31:16+08:00">2024-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h2><p>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。</p>
<p>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p>
<h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p>
<p>注意：如果主协程退出了，其他任务不会执行。</p>
<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><h2 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h2><p>让出CPU时间片，重新等待安排任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="comment">// 主协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 切一下，再次分配任务</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h2><p>退出当前协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            <span class="comment">// 结束协程</span></span><br><span class="line">            runtime.Goexit()</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;C.defer&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS()"></a>runtime.GOMAXPROCS()</h2><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//runtime.GOMAXPROCS(2)</span></span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><h2 id="channel介绍"><a href="#channel介绍" class="headerlink" title="channel介绍"></a>channel介绍</h2><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
<p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h2 id="channel创建"><a href="#channel创建" class="headerlink" title="channel创建"></a>channel创建</h2><h3 id="channel声明"><a href="#channel声明" class="headerlink" title="channel声明"></a>channel声明</h3><p>channel是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量 chan 元素类型</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>

<h3 id="channel初始化"><a href="#channel初始化" class="headerlink" title="channel初始化"></a>channel初始化</h3><p>声明的通道后需要使用make函数初始化之后才能使用。</p>
<p>创建channel的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make(chan 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure>

<p>channel的缓冲大小是可选的。</p>
<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h2 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h2><p>通道有发送（send）、接收（receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用&lt;-符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure>

<h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure>

<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<h2 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h2><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">10</span>  <span class="comment">//阻塞了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/mac/WorkSpace/go/demo/main.go:9 +0x34</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>出现deadlock错误：上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁。</p>
<p>解决方式，一种方法是启用一个goroutine去接收值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，<strong>无缓冲通道也被称为同步通道</strong>。</p>
<h2 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h2><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。</p>
<p>我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。</p>
<p>可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</p>
<h2 id="通道是否关闭"><a href="#通道是否关闭" class="headerlink" title="通道是否关闭"></a>通道是否关闭</h2><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把 close(c) 注释掉，程序会一直阻塞在 if data, ok := &lt;-c; ok 那一行</span></span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//ok为true说明channel没有关闭，为false说明管道已经关闭</span></span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭后的通道有以下特点：</p>
<ul>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ul>
<p>可以使用<strong>range</strong>来迭代不断操作channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把 close(c) 注释掉，程序会一直阻塞在 for data := range c 那一行</span></span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h2><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们<strong>在不同的任务函数中使用通道都会对其进行限制</strong>，比如限制通道在函数中只能发送或只能接收。</p>
<p>单向channel变量的声明非常简单，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>       <span class="comment">// ch1是一个正常的channel，不是单向的</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="type">float64</span> <span class="comment">// ch2是单向channel，只用于写float64数据</span></span><br><span class="line"><span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="type">int</span>     <span class="comment">// ch3是单向channel，只用于读取int数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>chan&lt;-</code> 表示数据进入管道，要把数据写进管道，对于调用者就是输出。</p>
</li>
<li><p><code>&lt;-chan</code> 表示数据从管道出来，对于调用者就是得到管道的数据，当然就是输入。</p>
</li>
</ul>
<p>可以将channel隐式转换为单向队列，只收或只发，<strong>不能将单向channel转换为普通channel</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="type">int</span> = c <span class="comment">// send-only</span></span><br><span class="line"><span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="type">int</span> = c <span class="comment">// receive-only</span></span><br><span class="line">send &lt;- <span class="number">1</span></span><br><span class="line"><span class="comment">//&lt;-send //invalid operation: &lt;-send (receive from send-only type chan&lt;- int)</span></span><br><span class="line">&lt;-recv</span><br><span class="line"><span class="comment">//recv &lt;- 2 //invalid operation: recv &lt;- 2 (send to receive-only type &lt;-chan int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能将单向 channel 转换为普通 channel</span></span><br><span class="line">d1 := (<span class="keyword">chan</span> <span class="type">int</span>)(send) <span class="comment">//cannot convert send (type chan&lt;- int) to type chan int</span></span><br><span class="line">d2 := (<span class="keyword">chan</span> <span class="type">int</span>)(recv) <span class="comment">//cannot convert recv (type &lt;-chan int) to type chan int</span></span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   chan&lt;- //只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        out &lt;- i <span class="comment">//如果对方不读 会阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   &lt;-chan //只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//   chan   //读写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> counter(c) <span class="comment">//生产者</span></span><br><span class="line">    printer(c)    <span class="comment">//消费者</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h2><table>
<thead>
<tr>
<th>channel</th>
<th>nil</th>
<th>非空</th>
<th>空的</th>
<th>满了</th>
<th>没满</th>
</tr>
</thead>
<tbody><tr>
<td>接收</td>
<td>阻塞</td>
<td>接收值</td>
<td>阻塞</td>
<td>接收值</td>
<td>接收值</td>
</tr>
<tr>
<td>发送</td>
<td>阻塞</td>
<td>发送值</td>
<td>发送值</td>
<td>阻塞</td>
<td>发送值</td>
</tr>
<tr>
<td>关闭</td>
<td>panic</td>
<td>关闭成功，读完数据后返回零值</td>
<td>关闭成功，返回零值</td>
<td>关闭成功，读完数据后返回零值</td>
<td>关闭成功，读完数据后返回零值</td>
</tr>
</tbody></table>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>Timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个channel，在将来的那个时间那个channel提供了一个时间值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建定时器，2秒后，定时器就会向自己的C字节发送一个time.Time类型的元素值</span></span><br><span class="line">    timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">    t1 := time.Now()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t1: %v\n&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line">    t2 := &lt;-timer1.C</span><br><span class="line">    fmt.Printf(<span class="string">&quot;t2: %v\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只是想单纯的等待的话，可以使用 time.Sleep 来实现</span></span><br><span class="line">    timer2 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">    &lt;-timer2.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;2s后&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;再一次2s后&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &lt;-time.After(time.Second * <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;再再一次2s后&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止定时器</span></span><br><span class="line">    timer3 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-timer3.C</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 3 expired&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    stop := timer3.Stop() <span class="comment">//停止定时器</span></span><br><span class="line">    <span class="keyword">if</span> stop &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timer 3 stopped&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置时间</span></span><br><span class="line">    reset_t1 := time.Now()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;before reset t1: %v\n&quot;</span>, reset_t1)</span><br><span class="line">    timer4 := time.NewTimer(time.Second * <span class="number">5</span>) <span class="comment">//原来设置3s</span></span><br><span class="line">    timer4.Reset(time.Second * <span class="number">2</span>)            <span class="comment">//重新设置时间</span></span><br><span class="line">    reset_t2 := &lt;-timer4.C</span><br><span class="line">    fmt.Printf(<span class="string">&quot;after reset t2:; %v\n&quot;</span>, reset_t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h2><p>Ticker是一个<strong>定时触发</strong>的计时器，它会以一个间隔（interval）往channel发送一个事件（当前时间），而channel的接收者可以以固定的时间间隔从channel中读取事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间)</span></span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123; <span class="comment">//循环</span></span><br><span class="line">            t := &lt;-ticker.C</span><br><span class="line">            i++</span><br><span class="line">            fmt.Printf(<span class="string">&quot;time=%v, i=%d\n&quot;</span>, t, i)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                ticker.Stop() <span class="comment">//停止定时器</span></span><br><span class="line">                fmt.Println(<span class="string">&quot;tricker stop&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。Go内置了select关键字，可以同时响应多个通道的操作。Go内置了select关键字，可以同时响应多个通道的操作。</p>
<p>select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case &lt;-chan1:</span><br><span class="line">   // 如果chan1成功读到数据，则进行该case处理语句</span><br><span class="line">case chan2 &lt;- 1:</span><br><span class="line">   // 如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="line">default:</span><br><span class="line">   // 如果上面都没有成功，则进入default处理流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<p>如果多个channel同时ready，则随机选择一个执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建2个管道</span></span><br><span class="line">   int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">   string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//time.Sleep(2 * time.Second)</span></span><br><span class="line">      int_chan &lt;- <span class="number">1</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">      fmt.Println(<span class="string">&quot;int:&quot;</span>, value)</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">      fmt.Println(<span class="string">&quot;string:&quot;</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">                fmt.Println(v)</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                o &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//c &lt;- 1 // 注释掉，引发 timeout</span></span><br><span class="line">    &lt;-o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h1><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>(wg *WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg *WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用<code>Done()</code>方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<p>使用<code>sync.WaitGroup</code>代替<code>time.Sleep()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoOnce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cb := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;DoOnce&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    once.Do(cb)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> DoOnce()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只会打印一次DoOnce。<code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>Go语言中内置的map不是并发安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            set(key, n)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的<code>map</code>一样使用<code>make</code>函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store、Load、LoadOrStore、Delete、Range</code>等操作方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生<strong>竞态问题</strong>（数据竞态）。</p>
<p>互斥锁是一种常用的控制共享资源访问的方法，它<strong>能够保证同时只有一个goroutine可以访问共享资源</strong>。Go语言中使用sync包的<code>Mutex</code>类型来实现互斥锁。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当<strong>我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁</strong>的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    x      <span class="type">int64</span></span><br><span class="line">    wg     sync.WaitGroup</span><br><span class="line">    lock   sync.Mutex</span><br><span class="line">    rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">    rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">    rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">    <span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">    rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">    time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">    rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">    <span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> write()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> read()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别测试使用互斥锁和读写锁方式运行上述代码，发现耗时差距很大。</p>
<h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync&#x2F;atomic提供。</p>
<h2 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h2><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>func LoadInt32(addr *int32) (val int32) func LoadInt64(addr <code>*int64</code>) (val int64)<br>func LoadUint32(addr<code>*uint32</code>) (val uint32)<br>func LoadUint64(addr<code>*uint64</code>) (val uint64)<br>func LoadUintptr(addr<code>*uintptr</code>) (val uintptr)<br>func LoadPointer(addr<code>*unsafe.Pointer</code>) (val unsafe.Pointer)</td>
<td>读取操作</td>
</tr>
<tr>
<td>func StoreInt32(addr <code>*int32</code>, val int32) <br>func StoreInt64(addr <code>*int64</code>, val int64) <br>func StoreUint32(addr <code>*uint32</code>, val uint32) <br>func StoreUint64(addr <code>*uint64</code>, val uint64) <br>func StoreUintptr(addr <code>*uintptr</code>, val uintptr) <br>func StorePointer(addr <code>*unsafe.Pointer</code>, val unsafe.Pointer)</td>
<td>写入操作</td>
</tr>
<tr>
<td>func AddInt32(addr <code>*int32</code>, delta int32) (new int32) <br>func AddInt64(addr <code>*int64</code>, delta int64) (new int64) <br>func AddUint32(addr <code>*uint32</code>, delta uint32) (new uint32) <br>func AddUint64(addr <code>*uint64</code>, delta uint64) (new uint64) <br>func AddUintptr(addr <code>*uintptr</code>, delta uintptr) (new uintptr)</td>
<td>修改操作</td>
</tr>
<tr>
<td>func SwapInt32(addr <code>*int32</code>, new int32) (old int32) <br>func SwapInt64(addr <code>*int64</code>, new int64) (old int64) <br>func SwapUint32(addr <code>*uint32</code>, new uint32) (old uint32) <br>func SwapUint64(addr <code>*uint64</code>, new uint64) (old uint64) <br>func SwapUintptr(addr <code>*uintptr</code>, new uintptr) (old uintptr) <br>func SwapPointer(addr <code>*unsafe.Pointer</code>, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td>交换操作</td>
</tr>
<tr>
<td>func CompareAndSwapInt32(addr <code>*int32</code>, old, new int32) (swapped bool) <br>func CompareAndSwapInt64(addr <code>*int64</code>, old, new int64) (swapped bool) <br>func CompareAndSwapUint32(addr <code>*uint32</code>, old, new uint32) (swapped bool) <br>func CompareAndSwapUint64(addr <code>*uint64</code>, old, new uint64) (swapped bool) <br>func CompareAndSwapUintptr(addr <code>*uintptr</code>, old, new uintptr) (swapped bool) <br>func CompareAndSwapPointer(addr <code>*unsafe.Pointer</code>, old, new unsafe.Pointer) (swapped bool)</td>
<td>比较并交换操作</td>
</tr>
</tbody></table>
<h1 id="GMP原理与调度"><a href="#GMP原理与调度" class="headerlink" title="GMP原理与调度"></a>GMP原理与调度</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://www.topgoer.com/">https://www.topgoer.com/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/11/25/x264%E7%BC%96%E7%A0%81%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/25/x264%E7%BC%96%E7%A0%81%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">x264编码码率控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-25 19:52:27" itemprop="dateCreated datePublished" datetime="2023-11-25T19:52:27+08:00">2023-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:36:46" itemprop="dateModified" datetime="2023-12-30T22:36:46+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="恒定速率因子"><a href="#恒定速率因子" class="headerlink" title="恒定速率因子"></a>恒定速率因子</h1><p>使用 CRF（Constant Rate Factor，恒定速率因子）进行编码时，可以通过 <code>-crf</code> 参数设置 CRF 的值。CRF 值通常在 0 到 51 之间，其中 0 表示无损压缩，51 表示最低质量。一般来说，合理的范围是 18 到 28，其中 18 是极高质量，28 是相对较低的质量。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -crf 23 -c:a copy output.mp4</span><br></pre></td></tr></table></figure>

<p>FFmpeg代码设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_crf</span><span class="params">(AVCodecContext *codec_ctx, <span class="type">int</span> crf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(crf &gt; <span class="number">51</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;crf &gt; 51 , is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> crf_str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(crf_str,<span class="string">&quot;%d&quot;</span>, crf);</span><br><span class="line">    <span class="type">int</span> ret = av_opt_set(codec_ctx-&gt;priv_data, <span class="string">&quot;crf&quot;</span>, crf_str, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;av_opt_set crf failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景：</strong> 适用于希望更直观地控制视频质量而不是比特率的场景。通常用于 H.264 和 H.265&#x2F;HEVC 编码。</li>
<li><strong>特点：</strong> 使用 CRF 值（通常在 0 到 51 之间）来调整输出的质量。较小的 CRF 值表示更高的质量，但文件可能较大；较大的 CRF 值表示较低的质量，但文件较小。适用于希望以质量为导向的应用。</li>
</ul>
<h1 id="恒定量化参数"><a href="#恒定量化参数" class="headerlink" title="恒定量化参数"></a>恒定量化参数</h1><p>CQP（Constant Quantization Parameter，恒定量化参数）是一种用于视频编码的质量控制模式，通常用于 H.264 和 H.265&#x2F;HEVC 编码。与传统的比特率控制模式（CBR、VBR）不同，CQP 模式通过固定量化参数来控制输出质量，而不是固定比特率。这意味着在 CQP 模式下，编码器会以固定的质量水平生成输出，而不考虑输出文件的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -qp 20 -c:a copy output.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景</strong>：一般用于研究。</li>
<li><strong>特点</strong>：每帧图像都按照一个特定的QP来编码，每帧编码后的数据量有多大是未知的，既不是码率优先模型也不是质量优先模型。</li>
</ul>
<h1 id="平均比特率"><a href="#平均比特率" class="headerlink" title="平均比特率"></a>平均比特率</h1><p>在 FFmpeg 中，要使用 ABR（Average Bit Rate，平均比特率）模式，可以使用 <code>-b:v</code> 参数来设置平均比特率，以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -b:v 1000k -maxrate 1500k -bufsize 2000k -c:a copy output.mp4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景</strong>：适用于直播和低延时系统。</li>
<li><strong>特点</strong>：平均比特率的动态调整，适应网络条件的变化，提供更一致的用户体验。</li>
</ul>
<h1 id="恒定比特率"><a href="#恒定比特率" class="headerlink" title="恒定比特率"></a>恒定比特率</h1><p>在 FFmpeg 中，要设置使用 CBR（Constant Bit Rate，恒定比特率）进行编码，可以使用 <code>-b:v</code> 参数来指定视频的目标比特率，并且设置<code>-minrate</code>、<code>-maxrate</code>和<code>-b:v</code>设置的比特率一致。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -b:v 1M -minrate 1M -maxrate 1M -bufsize 2M -c:a copy output.mp4</span><br></pre></td></tr></table></figure>

<p>FFmpeg代码设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_cbr</span><span class="params">(AVCodecContext *codec_ctx, <span class="type">int</span> br)</span></span><br><span class="line">&#123;</span><br><span class="line">    codec_ctx-&gt;bit_rate = br;    <span class="comment">//平均码率</span></span><br><span class="line">    codec_ctx-&gt;rc_min_rate = br; <span class="comment">//最大码率和平均码率一直</span></span><br><span class="line">    codec_ctx-&gt;rc_max_rate = br; <span class="comment">//最小码率和平均码率一直</span></span><br><span class="line">    codec_ctx-&gt;bit_rate_tolerance = br;  <span class="comment">//指定编码器在达到指定的目标比特率时允许的比特率误差的阈值</span></span><br><span class="line">    codec_ctx-&gt;rc_buffer_size = br;  <span class="comment">//码流缓存大小</span></span><br><span class="line">    codec_ctx-&gt;rc_initial_buffer_occupancy = codec_ctx-&gt;rc_buffer_size;  <span class="comment">//初始的缓存占用量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景：</strong> 适用于对网络带宽或存储空间有明确限制的场景，如在线直播、视频会议、广播等。</li>
<li><strong>特点：</strong> 输出的比特率保持恒定，这意味着文件大小相对稳定，但质量可能在复杂场景下有所降低。</li>
</ul>
<h1 id="可变比特率"><a href="#可变比特率" class="headerlink" title="可变比特率"></a>可变比特率</h1><p>在 FFmpeg 中，要设置使用 VBR（Variable Bit Rate，可变比特率）模式进行编码，可以使用 <code>-b:v</code> 参数指定目标平均比特率，同时使用 <code>-maxrate</code>、和<code>-minrate</code> <code>-bufsize</code> 参数来控制最大比特率和缓冲区大小。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -b:v 1000k -minrate 800k -maxrate 2000k -bufsize 2000k -c:a copy output.mp4</span><br></pre></td></tr></table></figure>

<p>FFmpeg代码设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_vbr</span><span class="params">(AVCodecContext *codec_ctx, <span class="type">int</span> br, <span class="type">int</span> min, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">    codec_ctx-&gt;bit_rate = br;</span><br><span class="line">    codec_ctx-&gt;rc_min_rate = min;</span><br><span class="line">    codec_ctx-&gt;rc_max_rate = max;</span><br><span class="line">    codec_ctx-&gt;flags |= AV_CODEC_FLAG_QSCALE;  <span class="comment">//这标志告诉编码器使用固定的量化标度而不是变化的比特率。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>场景：</strong> 适用于对输出质量有较高要求，但对文件大小相对宽容的场景，如视频存档、影片制作等。</li>
<li><strong>特点：</strong> 允许根据场景的复杂性调整比特率，以提供更好的视频质量。输出文件大小相对不稳定，但质量更高。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/11/24/FFmpeg%E4%BD%BF%E7%94%A8CUDA%E7%A1%AC%E4%BB%B6%E7%BC%96%E8%A7%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/24/FFmpeg%E4%BD%BF%E7%94%A8CUDA%E7%A1%AC%E4%BB%B6%E7%BC%96%E8%A7%A3%E7%A0%81/" class="post-title-link" itemprop="url">FFmpeg使用CUDA硬件编解码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-24 20:18:49" itemprop="dateCreated datePublished" datetime="2023-11-24T20:18:49+08:00">2023-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-18 10:21:44" itemprop="dateModified" datetime="2024-01-18T10:21:44+08:00">2024-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h1><p>编译 FFmpeg 的 NVIDIA GPU 硬件编解码器，解码器：h264_cuvid；编码器：h264_nvenc。</p>
<ul>
<li>环境：<ul>
<li>ubuntu：16.04</li>
<li>cuda：10.0</li>
<li>nvidia-driver：510.47.03</li>
<li>FFmpeg：4.4.1</li>
<li>nv-codec-headers：10.0.26</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 编译nv-codec</span><br><span class="line">unzip nv-codec-headers-old-sdk-10.0.zip</span><br><span class="line">cd nv-codec-headers-old-sdk-10.0</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># 编译FFmpeg</span><br><span class="line">unzip FFmpeg-n4.4.1.zip</span><br><span class="line">cd FFmpeg-n4.4.1</span><br><span class="line">./configure --enable-gpl --enable-nonfree --enable-cuda-nvcc --enable-libnpp --extra-cflags=&quot;-I/usr/local/cuda-10.0/include&quot; --extra-ldflags=&quot;-L/usr/local/cuda-10.0/lib64&quot; --prefix=`pwd`/install</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># 测试FFmpeg</span><br><span class="line">./install/bin/ffmpeg -hwaccels | grep cuda</span><br><span class="line">./install/bin/ffmpeg -codecs | grep h264</span><br><span class="line"></span><br><span class="line"># 编码</span><br><span class="line">./install/bin/ffmpeg -hwaccel_output_format cuda -i input.mp4 -vcodec h264_nvenc -acodec copy output.mp4</span><br></pre></td></tr></table></figure>

<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>FFmpeg自带的硬件解码例子hw_decode.c。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2017 Jun Zhao</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2017 Kaixuan Liu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HW Acceleration API (video decoding) decode sample</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment"> * of this software and associated documentation files (the &quot;Software&quot;), to deal</span></span><br><span class="line"><span class="comment"> * in the Software without restriction, including without limitation the rights</span></span><br><span class="line"><span class="comment"> * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span></span><br><span class="line"><span class="comment"> * copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment"> * furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"> * all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</span></span><br><span class="line"><span class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span></span><br><span class="line"><span class="comment"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * HW-Accelerated decoding example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @example hw_decode.c</span></span><br><span class="line"><span class="comment"> * This example shows how to do HW-accelerated decoding with output</span></span><br><span class="line"><span class="comment"> * frames from the HW video surfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/pixdesc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/hwcontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/avassert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AVBufferRef *hw_device_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">AVPixelFormat</span> <span class="title">hw_pix_fmt</span>;</span></span><br><span class="line"><span class="type">static</span> FILE *output_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hw_decoder_init</span><span class="params">(AVCodecContext *ctx, <span class="type">const</span> <span class="keyword">enum</span> AVHWDeviceType type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = av_hwdevice_ctx_create(&amp;hw_device_ctx, type,</span><br><span class="line">                                      <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create specified HW device.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx-&gt;hw_device_ctx = av_buffer_ref(hw_device_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> AVPixelFormat <span class="title function_">get_hw_format</span><span class="params">(AVCodecContext *ctx,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="keyword">enum</span> AVPixelFormat *pix_fmts)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">enum</span> <span class="title">AVPixelFormat</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pix_fmts; *p != <span class="number">-1</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == hw_pix_fmt)</span><br><span class="line">            <span class="keyword">return</span> *p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get HW surface format.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> AV_PIX_FMT_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_write</span><span class="params">(AVCodecContext *avctx, AVPacket *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">    AVFrame *frame = <span class="literal">NULL</span>, *sw_frame = <span class="literal">NULL</span>;</span><br><span class="line">    AVFrame *tmp_frame = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = avcodec_send_packet(avctx, packet);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error during decoding\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(frame = av_frame_alloc()) || !(sw_frame = av_frame_alloc())) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can not alloc frame\n&quot;</span>);</span><br><span class="line">            ret = AVERROR(ENOMEM);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = avcodec_receive_frame(avctx, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;</span><br><span class="line">            av_frame_free(&amp;frame);</span><br><span class="line">            av_frame_free(&amp;sw_frame);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error while decoding\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;format == hw_pix_fmt) &#123;</span><br><span class="line">            <span class="comment">/* retrieve data from GPU to CPU */</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = av_hwframe_transfer_data(sw_frame, frame, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error transferring the data to system memory\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_frame = sw_frame;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            tmp_frame = frame;</span><br><span class="line"></span><br><span class="line">        size = av_image_get_buffer_size(tmp_frame-&gt;format, tmp_frame-&gt;width,</span><br><span class="line">                                        tmp_frame-&gt;height, <span class="number">1</span>);</span><br><span class="line">        buffer = av_malloc(size);</span><br><span class="line">        <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can not alloc buffer\n&quot;</span>);</span><br><span class="line">            ret = AVERROR(ENOMEM);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = av_image_copy_to_buffer(buffer, size,</span><br><span class="line">                                      (<span class="type">const</span> <span class="type">uint8_t</span> * <span class="type">const</span> *)tmp_frame-&gt;data,</span><br><span class="line">                                      (<span class="type">const</span> <span class="type">int</span> *)tmp_frame-&gt;linesize, tmp_frame-&gt;format,</span><br><span class="line">                                      tmp_frame-&gt;width, tmp_frame-&gt;height, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can not copy image to buffer\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ret = fwrite(buffer, <span class="number">1</span>, size, output_file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to dump raw data.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fail:</span><br><span class="line">        av_frame_free(&amp;frame);</span><br><span class="line">        av_frame_free(&amp;sw_frame);</span><br><span class="line">        av_freep(&amp;buffer);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    AVFormatContext *input_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> video_stream, ret;</span><br><span class="line">    AVStream *video = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodecContext *decoder_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodec *decoder = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AVHWDeviceType</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;device type&gt; &lt;input file&gt; &lt;output file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type = av_hwdevice_find_type_by_name(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (type == AV_HWDEVICE_TYPE_NONE) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Device type %s is not supported.\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Available device types:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>((type = av_hwdevice_iterate_types(type)) != AV_HWDEVICE_TYPE_NONE)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; %s&quot;</span>, av_hwdevice_get_type_name(type));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open the input file */</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;input_ctx, argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot open input file &#x27;%s&#x27;\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(input_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot find input stream information.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find the video stream information */</span></span><br><span class="line">    ret = av_find_best_stream(input_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, &amp;decoder, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot find a video stream in the input file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    video_stream = ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);</span><br><span class="line">        <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decoder %s does not support device type %s.\n&quot;</span>,</span><br><span class="line">                    decoder-&gt;name, av_hwdevice_get_type_name(type));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (config-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp;</span><br><span class="line">            config-&gt;device_type == type) &#123;</span><br><span class="line">            hw_pix_fmt = config-&gt;pix_fmt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(decoder_ctx = avcodec_alloc_context3(decoder)))</span><br><span class="line">        <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">    video = input_ctx-&gt;streams[video_stream];</span><br><span class="line">    <span class="keyword">if</span> (avcodec_parameters_to_context(decoder_ctx, video-&gt;codecpar) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    decoder_ctx-&gt;get_format  = get_hw_format;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hw_decoder_init(decoder_ctx, type) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = avcodec_open2(decoder_ctx, decoder, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open codec for stream #%u\n&quot;</span>, video_stream);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open the file to dump raw data */</span></span><br><span class="line">    output_file = fopen(argv[<span class="number">3</span>], <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* actual decoding and dump the raw data */</span></span><br><span class="line">    <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = av_read_frame(input_ctx, &amp;packet)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (video_stream == packet.stream_index)</span><br><span class="line">            ret = decode_write(decoder_ctx, &amp;packet);</span><br><span class="line"></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* flush the decoder */</span></span><br><span class="line">    packet.data = <span class="literal">NULL</span>;</span><br><span class="line">    packet.size = <span class="number">0</span>;</span><br><span class="line">    ret = decode_write(decoder_ctx, &amp;packet);</span><br><span class="line">    av_packet_unref(&amp;packet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output_file)</span><br><span class="line">        fclose(output_file);</span><br><span class="line">    avcodec_free_context(&amp;decoder_ctx);</span><br><span class="line">    avformat_close_input(&amp;input_ctx);</span><br><span class="line">    av_buffer_unref(&amp;hw_device_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/11/15/SDP%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/15/SDP%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">SDP详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-15 21:39:49" itemprop="dateCreated datePublished" datetime="2023-11-15T21:39:49+08:00">2023-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-16 18:45:18" itemprop="dateModified" datetime="2024-01-16T18:45:18+08:00">2024-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SDP结构"><a href="#SDP结构" class="headerlink" title="SDP结构"></a>SDP结构</h1><p>SDP 描述分为两部分，分别是会话级别的描述（session level）和媒体级别的描述（media level），其具体的组成可参考 RFC 4566，带星号 (*) 的是可选的。常见的内容如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Session description（会话级别描述）</span><br><span class="line">         v=  (protocol version)</span><br><span class="line">         o=  (originator and session identifier)</span><br><span class="line">         s=  (session name)</span><br><span class="line">         c=* (connection information -- not required if included in all media)</span><br><span class="line">         One or more Time descriptions (&quot;t=&quot; and &quot;r=&quot; lines; see below)</span><br><span class="line">         a=* (zero or more session attribute lines)</span><br><span class="line">         Zero or more Media descriptions</span><br><span class="line"></span><br><span class="line">Time description （时间字段）</span><br><span class="line">         t=  (time the session is active)</span><br><span class="line"></span><br><span class="line">Media description（媒体级别描述）, if present</span><br><span class="line">         m=  (media name and transport address)</span><br><span class="line">         c=* (connection information -- optional if included at session level)</span><br><span class="line">         a=* (zero or more media attribute lines)</span><br></pre></td></tr></table></figure>

<p>SDP Line 是顺序相关的，比如 <code>a=rtpmap:96</code> 后面的都是它相关的设置，直到下一行是 <code>a=rtpmap</code>或者其他属性。</p>
<p>SDP Line 没有统一的 Schema 描述，也就是没有一个固定的规则能解析所有 Line，SDP Grammer 只是描述了 SDP 相关的属性，具体每个属性的表达需要根据属性定义。</p>
<p>SDP 解析时，每个 SDP Line 都是以 key&#x3D;… 形式，解析出 key 是 a 后，可能有两种方式。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=&lt;attribute&gt;</span><br><span class="line">a=&lt;attribute&gt;:&lt;value&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>比如 a&#x3D;rtcp-mux，key 为 a，attribute 为 rtcp-mux，没有 value。 </li>
<li>比如 a&#x3D;rtpmap:96 VP8&#x2F;90000，key 为 a，attribute 为 rtpmap，value&#x3D;96 VP8&#x2F;90000。</li>
</ul>
<h1 id="SDP关键属性"><a href="#SDP关键属性" class="headerlink" title="SDP关键属性"></a>SDP关键属性</h1><h2 id="会话级别字段"><a href="#会话级别字段" class="headerlink" title="会话级别字段"></a>会话级别字段</h2><p>会话级别的 SDP 描述字段包括：v、o、s、b、t。 </p>
<h3 id="协议版本号-version"><a href="#协议版本号-version" class="headerlink" title="协议版本号(version)"></a>协议版本号(version)</h3><p>SDP 协议版本，值固定为 0。</p>
<p><code>v=0</code>。</p>
<h3 id="会话发起者-origin"><a href="#会话发起者-origin" class="headerlink" title="会话发起者(origin)"></a>会话发起者(origin)</h3><p>代表会话的发起者。</p>
<p>格式：<code>o=&lt;username&gt;&lt;sess-id&gt;&lt;sess-version&gt;&lt;nettype&gt;&lt;addrtype&gt;&lt;unicast-address&gt; </code></p>
<p>各字段含义如下： </p>
<ul>
<li><code>username</code>：发起者的用户名，不允许存在空格，如果应用不支持用户名，则为<code>-</code>。 </li>
<li><code>sess-id</code>：会话 id，由应用自行定义，规范的建议是 NTP（Network Time Protocol）时间戳。 </li>
<li><code>sess-version</code>：会话版本，用途由应用自行定义，只要会话数据发生变化时（比如编码），sess-version 随着递增就行。同样的，规范的建议是 NTP 时间戳。 </li>
<li><code>nettype</code>：网络类型，比如 IN 表示 Internet。</li>
<li><code>addrtype</code>：地址类型，比如 IP4、IV6。</li>
<li><code>unicast-address</code>：域名，或者 IP 地址。</li>
</ul>
<p>示例：<code>o=- 7298280855354507719 2 IN IP4 127.0.0.1 </code></p>
<h3 id="会话名-session-name"><a href="#会话名-session-name" class="headerlink" title="会话名(session name)"></a>会话名(session name)</h3><p>会话的名称，每个 SDP 中有且仅能有一个 s 描述，其值不能为空。如果实在没有有意义的会话名，可以赋一个<code>-</code>。</p>
<p>格式：<code>s=&lt;session name&gt; </code></p>
<h2 id="媒体级别描述"><a href="#媒体级别描述" class="headerlink" title="媒体级别描述"></a>媒体级别描述</h2><h3 id="m"><a href="#m" class="headerlink" title="m&#x3D;"></a>m&#x3D;</h3><p>会话级别描述完成后，后面就是零到多个媒体级别描述，属于标准 SDP 中媒体描述的内容，同时也是 SDP 中最核心的内容。</p>
<p>格式：<code>m=&lt;media&gt;&lt;port&gt;&lt;proto&gt;&lt;fmt&gt;...</code></p>
<p>各字段含义如下： </p>
<ul>
<li><p><code>media</code>：媒体类型。包括 video、audio、text、application、message 等。</p>
</li>
<li><p><code>port</code>：传输媒体流的端口。对于 webrtc 而言由于它不适用 SDP 中描述的网络信息，所以该端口号对它没任何意义。</p>
</li>
<li><p><code>proto</code>：传输协议，具体含义取决于 c&#x3D; 中定义的地址类型，比如 c&#x3D; 是 IP4，那么这里的传输协议运行在 IP4 之上。比如：</p>
<ul>
<li><code>UDP</code>：传输层协议是 UDP。</li>
<li><code>RTP/AVP</code>：针对视频、音频的 RTP 协议，跑在 UDP 之上。</li>
<li><code>RTP/SAVP</code>：针对视频、音频的 SRTP 协议，跑在 UDP 之上。</li>
<li><code>RTP/AVPF</code>: 应用场景为视频&#x2F;音频的 RTP 协议，支持 RTCP-based Feedback。参考 RFC 4585。</li>
<li><code>RTP/SAVPF</code>: 应用场景为视频&#x2F;音频的 SRTP 协议，支持 RTCP-based Feedback。参考 RFC 5124。</li>
</ul>
</li>
<li><p><code>fmt</code>：媒体格式的描述，可能有多个。根据 proto 的不同，fmt 的含义也不同。比如 proto 为 RTP&#x2F;SAVP 时，fmt 表示 RTP payload 的类型。如果有多个，表示在这次会话中，多种 payload 类型可能会用到，且第一个为默认的 payload 类型。后面会跟着 rtpmap、rtcp-fb、fmtp 这些属性来做进一步的详细的描述。</p>
</li>
</ul>
<p>对于 RTP&#x2F;SAVP，需要注意的是，payload type 又分两种类型：</p>
<ul>
<li>静态类型</li>
<li>动态类型：在 a&#x3D;fmtp: 里进行定义</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 对于audio，111 是动态类型，表示opus/48000/2</span><br><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 126</span><br><span class="line">a=rtpmap:111 opus/48000/2</span><br><span class="line"></span><br><span class="line"># 对于video，122 是动态类型，表示H264/90000</span><br><span class="line">m=video</span><br><span class="line">9 UDP/TLS/RTP/SAVPF 122 102 100 101 124 120 123 119</span><br><span class="line">a=rtpmap:122 H264/90000</span><br></pre></td></tr></table></figure>

<h3 id="音频媒体信息"><a href="#音频媒体信息" class="headerlink" title="音频媒体信息"></a>音频媒体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126</span><br><span class="line">...</span><br><span class="line">a=mid:0</span><br><span class="line">...</span><br><span class="line">a=rtpmap:111 opus/48000/2</span><br><span class="line">a=rtcp-fb:111 transport-cc</span><br><span class="line">a=fmtp:111 minptime=10;useinbandfec=1</span><br><span class="line">a=rtpmap:103 ISAC/16000</span><br><span class="line">a=rtpmap:104 ISAC/32000</span><br><span class="line">a=rtpmap:9 G722/8000</span><br><span class="line">a=rtpmap:0 PCMU/8000</span><br><span class="line">a=rtpmap:8 PCMA/8000</span><br><span class="line">a=rtpmap:106 CN/32000</span><br><span class="line">a=rtpmap:105 CN/16000</span><br><span class="line">a=rtpmap:13 CN/8000</span><br><span class="line">a=rtpmap:110 telephone-event/48000</span><br><span class="line">a=rtpmap:112 telephone-event/32000</span><br><span class="line">a=rtpmap:113 telephone-event/16000</span><br><span class="line">a=rtpmap:126 telephone-event/8000</span><br></pre></td></tr></table></figure>

<ul>
<li>M line 的类型不是只有 audio 和 video，还有 application(bfcp)、text 等媒体类型。</li>
<li>M line 的数字 9 代表该媒体类型的传输端口，在 RTC 场景中都是使用 ICE candidate 的地址信息进行数据传输，所以 M line 的 port 并没有用到。不过，在 SIP 的场景下，M line 的 port 就十分重要了，此时，port 代表 RTP 端口，而且必须是偶数。结合 SDP 会话级别描述中的 C line 中的 IP 地址，我们就可以知道 SIP 的这路媒体流的传输地址。</li>
<li><strong>RTX</strong> 表示是重传，比如 video 的 97，就是 apt&#x3D;96 的重传。也就是说如果用的是 97 这个编码格式，它是在 96（VP8）基础上加了重传功能。</li>
</ul>
<h4 id="a-mid"><a href="#a-mid" class="headerlink" title="a&#x3D;mid"></a>a&#x3D;mid</h4><p>格式：<code>a=mid:&lt;id&gt;</code></p>
<p>示例：<code>a=mid:0</code></p>
<p><strong>a&#x3D;mid</strong> 属性可以认为是每个 M 描述的唯一 ID。比如 a&#x3D;mid:audio，那么 <code>audio</code> 这个字符串就是这个 M 描述的 ID。有的时候 mid 属性值也可以用数字表示，比如 a&#x3D;mid:0，那么 0 也是这个 M 描述的 ID。mid 值一般和 grouping 传输属性的 BUNDLE 策略结合来用，比如 a&#x3D;group:BUNDLE audio video，代表本次会话将对 mid 为 <code>audio</code> 和 <code>video</code> 的 M 描述进行复用传输。</p>
<h4 id="a-rtpmap"><a href="#a-rtpmap" class="headerlink" title="a&#x3D;rtpmap"></a>a&#x3D;rtpmap</h4><p>格式：<code>a=rtpmap:&lt;payload type&gt; &lt;endcoding name&gt;/&lt;clock rate&gt;/[/&lt;encodingparameters&gt;]</code></p>
<p>示例：<code>a=rtpmap:111 opus/48000/2</code></p>
<p>各字段说明：</p>
<ul>
<li><code>payload type</code>：类型，111。</li>
<li><code>endcoding name</code>：编解码器，opus。</li>
<li><code>clock rate</code>：时钟频率即采样率，48000。</li>
<li><code>encodingparameters</code>：音频通道数，2。</li>
</ul>
<h4 id="a-fmtp"><a href="#a-fmtp" class="headerlink" title="a&#x3D;fmtp"></a>a&#x3D;fmtp</h4><p>格式：<code>a=fmtp:&lt;format&gt; &lt;format specific parameters&gt;</code></p>
<p>示例：<code>a=fmtp:111 minptime=10;useinbandfec=1</code></p>
<p>各字段说明：</p>
<ul>
<li><code>format</code>：类型，111。</li>
<li><code>format specific parameters</code>：对于<code>minptime=10;useinbandfec=1</code>，意思以 10 ms 长的音频为一帧并且数据是经 FEC 编码的。</li>
</ul>
<h3 id="视频媒体信息"><a href="#视频媒体信息" class="headerlink" title="视频媒体信息"></a>视频媒体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 35 36</span><br><span class="line">...</span><br><span class="line">a=mid:1</span><br><span class="line">...</span><br><span class="line">a=rtpmap:96 VP8/90000</span><br><span class="line">...</span><br><span class="line">a=rtpmap:97 rtx/90000</span><br><span class="line">a=fmtp:97 apt=96</span><br><span class="line">a=rtpmap:98 VP9/90000</span><br><span class="line">a=fmtp:98 profile-id=0</span><br><span class="line">...</span><br><span class="line">a=rtpmap:99 rtx/90000</span><br><span class="line">a=fmtp:99 apt=98</span><br><span class="line">a=rtpmap:100 VP9/90000</span><br><span class="line">...</span><br><span class="line">a=fmtp:100 profile-id=2</span><br><span class="line">a=rtpmap:101 rtx/90000</span><br><span class="line">a=fmtp:101 apt=100</span><br><span class="line">a=rtpmap:102 H264/90000</span><br><span class="line">...</span><br><span class="line">a=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f</span><br><span class="line">a=rtpmap:121 rtx/90000</span><br><span class="line">a=fmtp:121 apt=102</span><br><span class="line">a=rtpmap:127 H264/90000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="a-rtpmap-1"><a href="#a-rtpmap-1" class="headerlink" title="a&#x3D;rtpmap"></a>a&#x3D;rtpmap</h4><p><code>a=rtpmap:96 VP8/90000</code>；payload 值为 96 表示媒体数据使用的编码器是 VP8，其时钟频率为 90000。又因为其排在 m&#x3D; 列表的第一位所以它是视频的默认编码器。</p>
<p><code>a=rtpmap:97 rtx/90000</code>；payload 值为 97，rtx 表示不再是编码器而是丢包重传，其要结合第 8 行代码 <code>a=fmtp:97 apt=96</code>一起看。apt 的值为 96 表示 96 与 97 是关联在一起的。所以整体含义是：当 webrtc 使用媒体类型是 96 时如果出现丢包需要重传，重传数据包类型为 97。</p>
<p><code>a=rtpmap:114 red/90000</code>；red 是一种在 webrtc 中使用的 FEC（引入前向纠错）算法，用于防止丢包；red 编码流程，默认情况下 webrtc 会将 VP8&#x2F;H264 等编码器编码后的数据再交由 red 模块编码，生成带一些冗余信息的数据包，这样当传输中某个包丢了，就可以通过其他包将其恢复回来，而不用重传丢失的包。</p>
<h4 id="a-fmtp-1"><a href="#a-fmtp-1" class="headerlink" title="a&#x3D;fmtp"></a>a&#x3D;fmtp</h4><p><code>a=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f</code></p>
<ul>
<li><code>level-asymmetry-allowed=1</code>指明通信双方使用的 H264 Level 否要保持一致，0 必须一致，1 可以不一致。</li>
<li><code>packetization-mode</code>指明经 H264 编码后的视频数据如何打包：0 单包、1 非交错包、2 交错包。三种打包模式中，模式 0 和模式 1 用于低延迟的实时通信领域。模式0的含义是每个包就是一帧视频数据。模式 1 是可以将视频帧拆分成多个顺序的 RTP 包发送，接收端收到数据包后再按顺序将其还原。</li>
<li><code>profile-level-id</code>由三部分组成，即 profile_idc、profile_iop 以及 level_idc，每个组成占 8 位，因此可以推测出 profile_idc&#x3D;64、profile_iop&#x3D;00、level-idc&#x3D;1f。</li>
</ul>
<h3 id="a-ssrc"><a href="#a-ssrc" class="headerlink" title="a&#x3D;ssrc"></a>a&#x3D;ssrc</h3><p>SSRC 是媒体源的唯一标识，每一路媒体流都有一个唯一的 SSRC 标识它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 35 36 124 119 123 118 114 115 116</span><br><span class="line">...</span><br><span class="line">a=ssrc-group:FID 3004200836 146948263</span><br><span class="line">//视频流的SSRC</span><br><span class="line">a=ssrc:3004200836 cname:hO7txeyp3DC4HQ6j</span><br><span class="line">a=ssrc:3004200836 msid:- 30c268ef-b3d0-42d2-ba35-0c8cb207505f</span><br><span class="line">a=ssrc:3004200836 mslabel:-</span><br><span class="line">a=ssrc:3004200836 label:30c268ef-b3d0-42d2-ba35-0c8cb207505f</span><br><span class="line">//丢包重传的SSRC</span><br><span class="line">a=ssrc:146948263 cname:hO7txeyp3DC4HQ6j</span><br><span class="line">a=ssrc:146948263 msid:- 30c268ef-b3d0-42d2-ba35-0c8cb207505f</span><br><span class="line">a=ssrc:146948263 mslabel:-</span><br><span class="line">a=ssrc:146948263 label:30c268ef-b3d0-42d2-ba35-0c8cb207505f</span><br></pre></td></tr></table></figure>

<p><code>a=ssrc-group:FID 3004200836 146948263</code>，描述了 SSRC（146948263）是 SSRC（3004200836）的重传流。也就说 3004200836 是真正代表视频的 SSRC，而 146948263 是视频流 3004200836 丢包时使用的 SSRC，也就是为什么在同一个视频描述中有两个 SSRC。</p>
<p><code>cnmae</code>（canonical name）通常称为别名，可以用在很多地方，其中用的最多是在域名解析中，你想为某个域名起别名时就可以使用它。在两个 SSRC 中跟着同样的 SSRC 说明这两个 SSRC 属于同一个媒体流。</p>
<h3 id="PlanB-与-UnifiedPlan"><a href="#PlanB-与-UnifiedPlan" class="headerlink" title="PlanB 与 UnifiedPlan"></a>PlanB 与 UnifiedPlan</h3><p>PlanB：只有两个媒体描述，即音频媒体描述（m&#x3D;audio…）和视频媒体描述（m&#x3D;video…）。如果要传输多路视频，则他们在视频媒体描述中需要通过 SSRC 来区分。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m=audio...</span><br><span class="line">a=ssrc:11223344</span><br><span class="line">...</span><br><span class="line">m=video ...</span><br><span class="line">...</span><br><span class="line">a=ssrc:22223333 cname:video1</span><br><span class="line">...</span><br><span class="line">a=ssrc:33334444 cname:video2</span><br></pre></td></tr></table></figure>

<p>UnifiedPlan 中可以有多个媒体描述，因此对于多路视频，将其拆成多个视频媒体描述即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//UnifiedPlan</span><br><span class="line">m=audio...</span><br><span class="line">a=ssrc:11223344</span><br><span class="line">...</span><br><span class="line">m=video..</span><br><span class="line">...</span><br><span class="line">a=ssrc:22223333 cname:video1</span><br><span class="line">...</span><br><span class="line">m=video..</span><br><span class="line">...</span><br><span class="line">a=ssrc:33334444 cname:video2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="a-sendrecv"><a href="#a-sendrecv" class="headerlink" title="a&#x3D;sendrecv"></a>a&#x3D;sendrecv</h3><p>媒体流的方向有四种，分别是 sendonly、recvonly、sendrecv、inactive，它们既可以出现在会话级别描述中也可以出现在媒体描述中。</p>
<ul>
<li><code>sendonly</code> 表示只发送数据，比如客户端推流到 SFU，那么会在自己的 Offer(or Answer) 中携带 senonly 属性。</li>
<li><code>revonly</code> 表示只接收数据，比如客户端向 SFU 订阅流，那么会在自己的 Offer(or Answer) 中携带 recvonly 属性。</li>
<li><code>sendrecv</code> 表示可以双向传输，比如客户端加入到视频会议中，既要发布自己的流又要订阅别人的流，那么就需要在自己的 Offer(or Answer) 中携带 sendrecv 属性。</li>
<li><code>inactive</code> 表示禁止发送数据，比如在基于 RTP 的视频会议中，主持人暂时禁掉用户 A 的语音，那么用户 A 的关于音频的媒体级别描述应该携带 inactive 属性，表示不能再发送音频数据。</li>
</ul>
<p>注意：senonly 和 recvonly 属性仅应用于媒体，不用于媒体控制相关的协议。比如在基于 RTP 的媒体会话中，即使是 recvonly 模式，也仍然要发送 RTCP 包，即使是 senonly 模式，也依然会接收并正常处理 RTCP 包。</p>
<h3 id="a-extmap"><a href="#a-extmap" class="headerlink" title="a&#x3D;extmap"></a>a&#x3D;extmap</h3><p>RTP扩展头，格式：<code>a=extmap:&lt;value&gt;[&quot;/&quot;&lt;direction&gt;]  &lt;URI&gt;  &lt;extensionattributes&gt;</code></p>
<p>extmap 时 extension map 的缩写，即 RTP Heade r扩展映射表。详情请参考 <a href="https://link.zhihu.com/?target=https://www.ietf.org/rfc/rfc8285.txt">RFC 8285</a></p>
<h2 id="网络描述"><a href="#网络描述" class="headerlink" title="网络描述"></a>网络描述</h2><p>网络描述包含 c&#x3D; 和 a&#x3D;candidate 字段。</p>
<h3 id="连接数据-connection-data"><a href="#连接数据-connection-data" class="headerlink" title="连接数据(connection data)"></a>连接数据(connection data)</h3><p>携带了会话的连接信息，其实就是 IP 地址。</p>
<p>SDP 的会话级别描述可以包含该字段，每一个媒体级别的描述也可以包含该字段，如果会话级别和媒体级别都有 c line，那么以媒体级别的 c line 为准。因为 WebRTC 使用 ICE candidate 交换地址信息，所以不会用到 c line，不过这并不代表 c line 没有用，在 SIP 视频会议场景中，c line 就必不可少了，文末会再次介绍该字段。</p>
<p>格式：<code>c=&lt;nettype&gt;&lt;addrtype&gt;&lt;connection-address&gt; </code></p>
<p>每个 SDP 至少需要包含一个会话级别的 c&#x3D; 字段，或者在每个媒体描述后⾯各包含一个 c&#x3D; 字段。（媒体描述后的 c&#x3D; 会覆盖会话级别的c&#x3D;）</p>
<ul>
<li><code>nettype</code>：网络类型，比如 IN，表示 Internet。 </li>
<li><code>addrtype</code>：地址类型，比如 IP4、IP6。</li>
<li><code>connection-address</code>：如果是⼴播，则为⼴播地址组；如果是单播，则为单播地址。</li>
</ul>
<p>示例：<code>c=IN IP4 224.2.36.42/127</code></p>
<p>不过 c&#x3D; 字段通常在 webrtc 中不适用。</p>
<h3 id="a-candidate"><a href="#a-candidate" class="headerlink" title="a&#x3D;candidate"></a>a&#x3D;candidate</h3><p>格式：<code>a=candidate:&lt;foundation&gt; &lt;component-id&gt; &lt;transport&gt; &lt;priority&gt; &lt;conn-addr&gt; &lt;conn-port&gt; typ &lt;candidate-type&gt; [&lt;rel-addr&gt; &lt;rel-port&gt;]</code></p>
<p>各字段说明：</p>
<ul>
<li><p><code>foundation</code>：一个字符串，用于唯一标识候选地址的基础。</p>
</li>
<li><p><code>component-id</code>：表示组件的 ID，通常是 1（对于RTP）或 2（对于RTCP）。 </p>
</li>
<li><p><code>transport</code>：传输协议。</p>
</li>
<li><p><code>priority</code>：表示优先级，用于确定首选候选地址，数值越大优先级越高。</p>
</li>
<li><p><code>conn-addr</code>：候选地址的 IP 地址。</p>
</li>
<li><p><code>conn-port</code>：候选地址的端口号。</p>
</li>
<li><p><code>typ</code>：候选地址的类型，通常是 “host”、”srflx”（服务器反射）或 “relay”（中继）。</p>
</li>
<li><p><code>candidate-type</code>：表示候选地址的具体类型，例如 “typ host” 或 “typ srflx”。</p>
</li>
<li><p><code>rel-addr</code>和<code>rel-port</code>：可选项，用于指定相关地址和端口，通常在对称型 NAT 场景下使用。</p>
</li>
</ul>
<p>示例：</p>
<p><code>a=candidate:1 1 UDP 2113937151 192.168.1.1 50000 typ host</code><br><code>a=candidate:2 1 UDP 1694498815 203.0.113.1 50000 typ srflx raddr 192.168.1.1 rport 50000</code></p>
<p>这两个示例中，第一个是主机候选地址，第二个是服务器反射（STUN）候选地址。这些候选地址会在 ICE 过程中用于建立对等连接，尤其是在对抗 NAT 的情境下。</p>
<p><strong>候选地址类型</strong>：</p>
<ul>
<li><code>host</code> 该 candidate 是一个真实的主机，参数中的地址和端口对应一个真实的主机地址。</li>
<li><code>srflx</code>（server reflexive）该 candidate 是通过 Cone NAT （锥形 NAT）反射的类型，参数中的地址和端口是端发送 Binding 请求到 STUN&#x2F;TURN server 经过 NAT 时，NAT 上分配的地址和端口。</li>
<li><code>prflx</code>（peer reflexive）该 candidate 是通过 Symmetric NAT（对称 NAT） 反射的类型，参数中的地址和端口是端发送 Binding 请求到 STUN&#x2F;TURN server 经过 NAT 时，NAT 上分配的地址和端口。</li>
<li><code>relay</code> 该 candidate 是通过 TURN 服务中继的类型，参数中的地址和端口是 TURN 服务用于在两个对等点之间转发数据的地址和端口。</li>
</ul>
<p><code>a=end-of-candidates</code> 在 Trickle ICE 模式时，用于显示声明 candidate 信息的结束。</p>
<h2 id="ICE策略"><a href="#ICE策略" class="headerlink" title="ICE策略"></a>ICE策略</h2><p>SDP 中和 ICE 相关的信息包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126</span><br><span class="line">a=ice-ufrag:kce9</span><br><span class="line">a=ice-pwd:M31WxfrwmrFvPws4+tPdbsCE</span><br><span class="line">a=ice-options:trickle</span><br><span class="line"></span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 123 127 122 125 107 108 109 124</span><br><span class="line">a=ice-ufrag:kce9</span><br><span class="line">a=ice-pwd:M31WxfrwmrFvPws4+tPdbsCE</span><br><span class="line">a=ice-options:trickle</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ice-ufrag</code> 和 <code>ice-pwd</code> 就是 ICE short-term 认证算法用到的用户名和密码。</li>
<li><code>trickle</code> 说明 SDP 中没有包含 Candidate 信息，Candidate 是通过信令单独交换的，这样可以做到 Connectivity checks 和 Candidate harvesting 并行处理，提高会话建立的速度。</li>
</ul>
<h2 id="DTLS"><a href="#DTLS" class="headerlink" title="DTLS"></a>DTLS</h2><p>SDP 中和 DTLS 相关的信息包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126B0:A2:B3:AB:0B:A3:44:22:B1:C8:69:52:ED:04:E8:5A:A4:C3:7A:A6:55:F3:BA:76:62:26:4B:F7:9F:DD:F1:BD</span><br><span class="line">a=setup:actpass</span><br><span class="line"></span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 123 127 122 125 107 108 109 124</span><br><span class="line">a=fingerprint:sha-256 B0:A2:B3:AB:0B:A3:44:22:B1:C8:69:52:ED:04:E8:5A:A4:C3:7A:A6:55:F3:BA:76:62:26:4B:F7:9F:DD:F1:BD</span><br><span class="line">a=setup:actpass</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a=fingerprint</code>：用于验证加密证书的有效性。当通信双方通过 DTLS 协议交换证书时，如何保障证书在网络交换的过程中没有被篡改？<ul>
<li>各端会给各自的证书生成一个指纹。</li>
<li>将指纹放到 SDP 中通过信令交换给对方。</li>
<li>DTLS 协议交换证书。</li>
<li>将拿到的证书重新生成指纹。</li>
<li>将生成的指纹与 SDP 中的指纹进行比较，如果两者一致，则说明证书在传输过程中没有被篡改可以使用，否则说明证书被篡改此时连接创建失败。</li>
</ul>
</li>
<li><code>a=setup:actpass</code>：决定 DTLS 协议时通信双方的角色。具体如下：<ul>
<li><code>active</code>：终端的角色为客户端。</li>
<li><code>passive</code>：终端的角色为服务端。</li>
<li><code>actpass</code>：终端既可以是客户端也可以是服务端。</li>
</ul>
</li>
<li>最终的角色由另一端角色确定，一般第一个加入房间的终端默认为 actpass，后来加入的终端为 active。</li>
</ul>
<h2 id="Qos、Grouping传输描述"><a href="#Qos、Grouping传输描述" class="headerlink" title="Qos、Grouping传输描述"></a>Qos、Grouping传输描述</h2><h3 id="a-rtcp-mux"><a href="#a-rtcp-mux" class="headerlink" title="a&#x3D;rtcp-mux"></a>a&#x3D;rtcp-mux</h3><p>传输时，可以复用媒体通道，一种是音频和视频的复用，一种是 RTCP 和 RTP 的复用。RTCP 和 RTP 复用，表示 Sender 使用一个传输通道（单一端口）发送 RTP 和 RTCP：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126</span><br><span class="line">a=rtcp-mux</span><br><span class="line"></span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 35 36 124 119 123 118 114 115 116</span><br><span class="line">a=rtcp-mux</span><br></pre></td></tr></table></figure>

<p>此时，Receiver 必须准备好在 RTP 端口上接收 RTCP 数据，并需要预留一些资源，比如 RTCP 带宽。</p>
<p>rtcp-mux 是与 RTC 传输相关的重要的 SDP 属性，关于它的 SDP 协商的原则如下：</p>
<ul>
<li>如果 Offer 携带 rtcp-mux 属性，并且 Answer 方希望复用 RTP 和 RTCP 到单一端口，那么 Answer 必须也要携带该rtcp-mux 属性。 </li>
<li>如果 Offer 没有携带 rtcp-mux 属性，那么 Answer 也一定不能携带 rtcp-mux 属性，而且 Answer 方禁止 RTP 和 RTCP 复用单一端口。 </li>
<li>rtcp-mux 的协商和使用必须是双向的。</li>
</ul>
<h3 id="a-group-BUNDLE"><a href="#a-group-BUNDLE" class="headerlink" title="a&#x3D;group:BUNDLE"></a>a&#x3D;group:BUNDLE</h3><p>BUNDLE 又将多路媒体流复用到同一端口进行传输，如下代表本次会话将对 mid 为 0 和 1 的 M 描述进行复用传输。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=group:BUNDLE 0 1</span><br><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126</span><br><span class="line">a=mid:0</span><br><span class="line"></span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 35 36 124 119 123 118 114 115 116</span><br><span class="line">a=mid:1</span><br></pre></td></tr></table></figure>

<h3 id="a-rtcp-fb"><a href="#a-rtcp-fb" class="headerlink" title="a&#x3D;rtcp-fb"></a>a&#x3D;rtcp-fb</h3><p>媒体描述中服务质量是由<code>a=rtcp-fb</code>描述的。rtcp-fb 有两层含义</p>
<ul>
<li>RTCP 消息中专门反馈信息的消息。</li>
<li>设置 webrtc 支持哪些 rtcp feedback 消息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126</span><br><span class="line">...</span><br><span class="line">a=rtcp-fb:111 transport-cc</span><br><span class="line">...</span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 35 36 124 119 123 118 114 115 116</span><br><span class="line">...</span><br><span class="line">a=rtcp-fb:96 goog-remb</span><br><span class="line">a=rtcp-fb:96 transport-cc</span><br><span class="line">a=rtcp-fb:96 ccm fir</span><br><span class="line">a=rtcp-fb:96 nack</span><br><span class="line">a=rtcp-fb:96 nack pli</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>a=rtcp-fb:111 transport-cc</code>：在使用 payload 类型为 111 的编解码器时，支持 transport-cc 类型的 rtcp feedback 报文，同时也说明 webrtc 在使用 opus 编解码器时开启了 transport-cc 拥塞控制算法。</p>
</li>
<li><p><code>a=rtcp-fb:96 goog-remb</code>和<code>a=rtcp-fb:96 transport-cc</code>：webrtc 使用 VP8 编解码器时，既支持 Goog-REMB 的 RTCP 报文，也支持 transport-cc 的 RTCP 报文。</p>
</li>
<li><p><code>a=rtcp-fb:96 ccm fir</code>：指明 webrtc 支持 RTCP 的 FIR（full intra refresh） 指令，即关键帧重传请求和 ccm（codec control message）指令即，使用 RTCP 反馈机制来实现编码控制。</p>
</li>
<li><p><code>a=rtcp-fb:96 nack</code>：webrtc 支持 nack 报文。</p>
</li>
<li><p><code>a=rtcp-fb:96 nack pli</code>：支持 nack 报文的同时将支持 PLI 报文（关键帧丢包重传）。</p>
</li>
</ul>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/L4BABJQKOCJYp_63gyEe4A">https://mp.weixin.qq.com/s/L4BABJQKOCJYp_63gyEe4A</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzb869168467/article/details/122147530">https://blog.csdn.net/hzb869168467/article/details/122147530</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freeabc/article/details/106711632">https://blog.csdn.net/freeabc/article/details/106711632</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/11/12/STUN%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/12/STUN%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">STUN协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-12 09:14:02" itemprop="dateCreated datePublished" datetime="2023-11-12T09:14:02+08:00">2023-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-03-14 21:29:14" itemprop="dateModified" datetime="2024-03-14T21:29:14+08:00">2024-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/134045027">去中心化技术分享与 P2P 框架的实现</a></p>
<h1 id="STUN介绍"><a href="#STUN介绍" class="headerlink" title="STUN介绍"></a>STUN介绍</h1><p>RFC3489 （Simple Traversal of User Datagram Protocol Through Network Address Translators）</p>
<ul>
<li>旧版的 STUN</li>
<li>定位：NAT 穿透的完整解决方案，能够帮助客户端发现自己是否在 NAT 后面、NAT 的类型，以及对应的NAT 公网侧的地址</li>
<li>自从 RFC3489 规范发布以来的经验发现，旧版的 STUN 根本无法很好的工作，无法成为可部署的解决方案，主要有以下原因：<ul>
<li>从旧版 STUN 获取的地址，有时候可以用，有时候不能用</li>
<li>没有提供任何方法来发现这些地址是否可用</li>
<li>即使发现了不能用，也没有提供补救的措施</li>
</ul>
</li>
</ul>
<p>RFC5389（Session Traversal Utilities for NAT）</p>
<ul>
<li>从旧版的 STUN 演变过来的</li>
<li>定位：只是作为完整NAT穿透解决方案的一个工具，配合其它规范来实现完整的NAT穿透解决方案，这是于旧版相比最重要的变化</li>
</ul>
<h1 id="STUN协议"><a href="#STUN协议" class="headerlink" title="STUN协议"></a>STUN协议</h1><h2 id="STUN头部"><a href="#STUN头部" class="headerlink" title="STUN头部"></a>STUN头部</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|  0                     1                 2                   3</span><br><span class="line">|  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|0 0|      STUN Message Type      |     Message Length            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Magic Cookie                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                                 |</span><br><span class="line">|                    Transaction ID (64 bits)                     |</span><br><span class="line">|                                                                 |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>每个 STUN 消息都包含一个固定 20 字节的头部，其后跟随 0 个或者多个属性。</p>
<ul>
<li>第一个字节的前两位，<strong>必须是 0</strong>，可用于多协议数据包的解复用</li>
<li><code>STUN Message Type</code> ：前两个字节的后 14 位表示消息的类型，类型又分为 class 和 method<ul>
<li><p>M0 ~ M11 代表 method</p>
</li>
<li><p>C0 和 C1 代表 class</p>
<ul>
<li>0b00 表示 request</li>
<li>0b01 表示 indication</li>
<li>0b10 表示 success response</li>
<li>0b11 表示 error response</li>
</ul>
</li>
<li><p>比如，Binding 请求代表 class&#x3D;0b00（request），method&#x3D;0b000000000001（Binding）并且编码成 0x0001；Binding  相应代表 class&#x3D;0b10（success response），method&#x3D;0b000000000001 并且编码成 0x0101</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0                 1</span><br><span class="line">2  3  4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+--+--+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|M |M |M|M|M|C|M|M|M|C|M|M|M|M|</span><br><span class="line">|11|10|9|8|7|1|6|5|4|0|3|2|1|0|</span><br><span class="line">+--+--+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Message Length</code>：第 3 ~ 4 字节表示消息的总长度，<strong>不包含头部的固定 20 字节长度</strong></li>
<li><code>Magic Cookie</code>：第 5 ~ 8 字节，固定取值 0x2112A442，在旧版的 STUN 中，它是 TransactionID 的一部分，新规范在这个位置放置 Magic Cookie，可以允许服务器能够发现客户端是否能够理解新规范增加的属性。另外，也可以用于多协议数据包的解复用</li>
<li><code>Transaction ID</code>：12 个字节，用于标识 STUN 事务的唯一标识符。用于关联请求和响应</li>
</ul>
<h2 id="STUN属性"><a href="#STUN属性" class="headerlink" title="STUN属性"></a>STUN属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|  0                     1                 2                   3</span><br><span class="line">|  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Type              |             Length            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Value(variable)                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>遵循 TLV 编码格式，即：Type、Length、Value。</p>
<ul>
<li><code>Type</code>: 16 位，表示属性的类型</li>
<li><code>Length</code>：16 位，表示属性值的长度（单位是字节），<strong>不包含填充部分</strong></li>
<li><code>Value</code>：属性值，<strong>4 字节对齐</strong></li>
<li>0x0000 ~ 0x7fff，为强制理解的属性</li>
<li>0x8000 ~ 0xffff, 为可选理解的属性</li>
</ul>
<h2 id="STUN常用属性"><a href="#STUN常用属性" class="headerlink" title="STUN常用属性"></a>STUN常用属性</h2><h3 id="FINGERPRINT"><a href="#FINGERPRINT" class="headerlink" title="FINGERPRINT"></a>FINGERPRINT</h3><ul>
<li><p>Type: 0x8028，Value 的类型：UInt32</p>
</li>
<li><p>fingerprint 可以出现在所有的 STUN 消息当中，对于 WebRTC 会<strong>强制校验该属性</strong>。<strong>必须在最后一个属性</strong>，可以用于解复用</p>
</li>
<li><p>计算方法：首先用 STUN 的头部 + 所有属性的内容（不包含 fingerprint 自身），计算 crc32 的值，然后计算<code>fingerprint值 = crc32值 ^ 0x5354554e</code></p>
</li>
</ul>
<h3 id="MESSAGE-INTEGRITY"><a href="#MESSAGE-INTEGRITY" class="headerlink" title="MESSAGE-INTEGRITY"></a>MESSAGE-INTEGRITY</h3><ul>
<li><p>Type：0x0008，Value 的类型：字符串固定为 20 字节</p>
</li>
<li><p>MESSAGE-INTEGRITY 用于在通信过程中确保消息的完整性。</p>
</li>
<li><p>计算方法：获取 MI 属性之前的包长度，并用来替换头部长度，从头部到 MI 属性之间的部分使用算法 sha1，key 使用 ice_pwd，用于计算值结果</p>
</li>
</ul>
<h3 id="USERNAME"><a href="#USERNAME" class="headerlink" title="USERNAME"></a>USERNAME</h3><ul>
<li><p>Type：0x0006，Value 的类型：字符串</p>
</li>
<li><p>username 用于短期认证来验证对等方的身份； username 由两部分构成，<code>remote_ufrag:local_ufrag</code>，检查接收方的 ufrag 和 username 中的 remote_ufrag 是否一致</p>
</li>
</ul>
<h3 id="MAPPED-ADDRESS"><a href="#MAPPED-ADDRESS" class="headerlink" title="MAPPED-ADDRESS"></a>MAPPED-ADDRESS</h3><ul>
<li><p>用于表示 Peer 的反射传输地址，即：prflx</p>
</li>
<li><p>这个属性在RFC5389规范，已经不再使用了，只是出于向后兼容，服务端还会支持</p>
</li>
</ul>
<h3 id="XOR-MAPPED-ADDRESS"><a href="#XOR-MAPPED-ADDRESS" class="headerlink" title="XOR-MAPPED-ADDRESS"></a>XOR-MAPPED-ADDRESS</h3><ul>
<li><p>Type：0x0020</p>
</li>
<li><p>Value 的类型</p>
<ul>
<li><p>第 1 个字节：全部为 0</p>
</li>
<li><p>第 2 个字节：family，8位（0x01: IPv4，0x02: IPv6）</p>
</li>
<li><p>第 3-4 个字节：16 位，地址端口；<code>x-port = port ^ (magic_cookie &gt;&gt; 16)</code></p>
</li>
<li><p>后面的字节对于 IPV4 为 32 位，对于 IPV6 为 128 位。<code>x-address-ipv4 = address-ipv4 ^ magic_cookie</code>，<code>x-address-ipv6 = address-ipv6^ (magic_cookie 拼接 transaction_id)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="PRIORITY"><a href="#PRIORITY" class="headerlink" title="PRIORITY"></a>PRIORITY</h3><ul>
<li><p>Type：0x0024，Value 的类型：Uint32</p>
</li>
<li><p>用于排序和选择 ICE 候选地址的属性</p>
</li>
</ul>
<h3 id="ICE-CONTROLLED和ICE-CONTROLLING"><a href="#ICE-CONTROLLED和ICE-CONTROLLING" class="headerlink" title="ICE-CONTROLLED和ICE-CONTROLLING"></a>ICE-CONTROLLED和ICE-CONTROLLING</h3><ul>
<li>offerer 是 controlling，answerer 是 controlled</li>
<li>ICE-CONTROLLED 或者是 ICE-CONTROLLING，这两个属性都会携带一个 Tie breaker 这样的字段，其中包含一个本机产生的随机值。收到该 bind request 的一方会检查这两个字段，如果和当前本机的 role 冲突，则检查本机的 Tie breaker 值和消息中携带的 Tie breaker 值进行判定本机合适的 role。<strong>判定的方法为 Tie breaker 值大的一方为 controlling</strong>。如果判定本端变更角色，这直接修改；如果判定对端变更角色，则对此 bind request 发送 487 错误响应，收到此错误响应的一方变更角色即可</li>
</ul>
<h3 id="USE-CANDIDATE"><a href="#USE-CANDIDATE" class="headerlink" title="USE-CANDIDATE"></a>USE-CANDIDATE</h3><ul>
<li><p>Type：0x0020，Value 的类型：字符串</p>
</li>
<li><p>一开始 Binding 时，可能没有 USE-CANDIDATE 这个字段，当这个通道可以使用的时候，也就是 ICE 提名使用时，STUN 消息添加该字段，表示使用该通道开始建联 Dtls 链接，这时候服务端开始和客户端握手建立安全加密 UDP 链接</p>
</li>
</ul>
<h3 id="ERROR-CODE"><a href="#ERROR-CODE" class="headerlink" title="ERROR-CODE"></a>ERROR-CODE</h3><ul>
<li>Type: 0x0009</li>
<li>Value 的类型<ul>
<li>前 21 位，是保留位，设置为 0</li>
<li>22 ~ 24 位，是错误的分类，取值 3 ~ 6</li>
<li>25 ~ 32位，是错误 number，取值 0 ~ 99</li>
<li>最后是错误的原因描述</li>
</ul>
</li>
<li>常见错误码<ul>
<li>400 – Bad Request</li>
<li>401 – Unauthorized</li>
<li>500 – Server error</li>
</ul>
</li>
</ul>
<h1 id="STUN抓包"><a href="#STUN抓包" class="headerlink" title="STUN抓包"></a>STUN抓包</h1><ul>
<li>客户端请求，Binding Request</li>
</ul>
<img src="/2023/11/12/STUN%E5%8D%8F%E8%AE%AE/STUN-binding-request.png" alt="STUN-binding-request" style="zoom:50%;">

<ul>
<li>服务端成功响应，Binding Success Response</li>
</ul>
<img src="/2023/11/12/STUN%E5%8D%8F%E8%AE%AE/STUN-binding-success-response.png" alt="STUN-binding-success-response" style="zoom:50%;">

<ul>
<li>SRS一对一通话建立流程</li>
</ul>
<img src="/2023/11/12/STUN%E5%8D%8F%E8%AE%AE/SRS一对一通话报文.png" alt="SRS一对一通话报文" style="zoom:50%;">

<h1 id="STUN交互过程"><a href="#STUN交互过程" class="headerlink" title="STUN交互过程"></a>STUN交互过程</h1><ul>
<li>在 WebRTC 中，STUN 客户端内置在浏览器用户代理中，在会话建立之前，先发送 stun 测试报文，以便浏览器确定其是否位于 NAT 之后并发现映射地址和端口。</li>
<li>当 STUN 服务器收到 STUN Binding 请求时，它会记录 Binding 请求来自哪个 IP 地址和端口号，此地址和端口号随后将以 STUN Binding 响应的形式返回客户端。（通过 XOR-MAPPED-ADDRESS 属性）。</li>
<li>客户端将响应中发来的 IP 地址和端口与其发送的 IP 地址和端口进行比较，以此来判断客户端和服务器之间有没有 NAT ，若不同，则说明至少有一个 NAT ，客户端能够识别由最外层的 NAT 分配的 IP 地址和端口。存在多个 NAT 时，STUN 只能识别最外层 NAT 的相关信息。</li>
<li>STUN 服务器将源传输地址复制到 STUN Binding 响应中 XOR-MAPPED-ADDRESS 属性中，并将绑定响应发送回 STUN 客户端。当这个数据包通过 NAT 返回时，NAT 将修改 IP 报头中的目的传输地址，但是 STUN 响应主体中 XOR-MAPPED-ADDRESS 属性中的传输地址将保持不变。通过这种方式，客户端可以了解最外面的 NAT 相对于 STUN 服务器分配的反射传输地址。</li>
</ul>
<h1 id="STUN-SRS源码"><a href="#STUN-SRS源码" class="headerlink" title="STUN-SRS源码"></a>STUN-SRS源码</h1><p>SRS版本为<code>v6.0.75</code></p>
<h2 id="请求解析"><a href="#请求解析" class="headerlink" title="请求解析"></a>请求解析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsStunPacket::decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">const</span> <span class="type">int</span> nb_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    SrsBuffer* stream = <span class="keyword">new</span> <span class="built_in">SrsBuffer</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(buf), nb_buf);</span><br><span class="line">    <span class="built_in">SrsAutoFree</span>(SrsBuffer, stream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream-&gt;<span class="built_in">left</span>() &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_new</span>(ERROR_RTC_STUN, <span class="string">&quot;invalid stun packet, size=%d&quot;</span>, stream-&gt;<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析stun消息头</span></span><br><span class="line">    message_type = stream-&gt;<span class="built_in">read_2bytes</span>();</span><br><span class="line">    <span class="type">uint16_t</span> message_len = stream-&gt;<span class="built_in">read_2bytes</span>();</span><br><span class="line">    string magic_cookie = stream-&gt;<span class="built_in">read_string</span>(<span class="number">4</span>);</span><br><span class="line">    transcation_id = stream-&gt;<span class="built_in">read_string</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 20字节是消息头</span></span><br><span class="line">    <span class="keyword">if</span> (nb_buf != <span class="number">20</span> + message_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_new</span>(ERROR_RTC_STUN, </span><br><span class="line">                             <span class="string">&quot;invalid stun packet, message_len=%d, nb_buf=%d&quot;</span>,</span><br><span class="line">                             message_len, nb_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stun属性 type len value 格式</span></span><br><span class="line">    <span class="keyword">while</span> (stream-&gt;<span class="built_in">left</span>() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> type = stream-&gt;<span class="built_in">read_2bytes</span>();</span><br><span class="line">        <span class="type">uint16_t</span> len = stream-&gt;<span class="built_in">read_2bytes</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stream-&gt;<span class="built_in">left</span>() &lt; len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_new</span>(ERROR_RTC_STUN, <span class="string">&quot;invalid stun packet&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string val = stream-&gt;<span class="built_in">read_string</span>(len);</span><br><span class="line">        <span class="comment">// padding</span></span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            stream-&gt;<span class="built_in">read_string</span>(<span class="number">4</span> - (len % <span class="number">4</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析属性</span></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> Username: &#123;</span><br><span class="line">                username = val;</span><br><span class="line">                <span class="type">size_t</span> p = val.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);    <span class="comment">// 以:分割本地和远程ufrag  610f5ir6:Dw56</span></span><br><span class="line">                <span class="keyword">if</span> (p != string::npos) &#123;</span><br><span class="line">                    local_ufrag = val.<span class="built_in">substr</span>(<span class="number">0</span>, p);</span><br><span class="line">                    remote_ufrag = val.<span class="built_in">substr</span>(p + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">srs_verbose</span>(<span class="string">&quot;stun packet local_ufrag=%s, remote_ufrag=%s&quot;</span>,</span><br><span class="line">                                local_ufrag.<span class="built_in">c_str</span>(), remote_ufrag.<span class="built_in">c_str</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始建立DTLS连接</span></span><br><span class="line">            <span class="keyword">case</span> UseCandidate: &#123;</span><br><span class="line">                use_candidate = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">srs_verbose</span>(<span class="string">&quot;stun use-candidate&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// @see: https://tools.ietf.org/html/draft-ietf-ice-rfc5245bis-00#section-5.1.2</span></span><br><span class="line">            <span class="comment">// One agent full, one lite:  The full agent MUST take the controlling</span></span><br><span class="line">            <span class="comment">// role, and the lite agent MUST take the controlled role.  The full</span></span><br><span class="line">            <span class="comment">// agent will form check lists, run the ICE state machines, and</span></span><br><span class="line">            <span class="comment">// generate connectivity checks.</span></span><br><span class="line">            <span class="comment">// 接收端</span></span><br><span class="line">            <span class="keyword">case</span> IceControlled: &#123;</span><br><span class="line">                ice_controlled = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">srs_verbose</span>(<span class="string">&quot;stun ice-controlled&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发起端，不会解析值，SRS作为SFU，都是由web发起请求</span></span><br><span class="line">            <span class="keyword">case</span> IceControlling: &#123;</span><br><span class="line">                ice_controlling = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">srs_verbose</span>(<span class="string">&quot;stun ice-controlling&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="built_in">srs_verbose</span>(<span class="string">&quot;stun type=%u, no process&quot;</span>, type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应解析"><a href="#响应解析" class="headerlink" title="响应解析"></a>响应解析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcUdpNetwork::on_binding_request</span><span class="params">(SrsStunPacket* r, string ice_pwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    SrsStunPacket stun_binding_response;</span><br><span class="line">    <span class="type">char</span> buf[kRtpPacketSize];</span><br><span class="line">    SrsBuffer* stream = <span class="keyword">new</span> <span class="built_in">SrsBuffer</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">SrsAutoFree</span>(SrsBuffer, stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应类型</span></span><br><span class="line">    stun_binding_response.<span class="built_in">set_message_type</span>(BindingResponse);</span><br><span class="line">    <span class="comment">// 设置响应头字段，在请求中解析</span></span><br><span class="line">    stun_binding_response.<span class="built_in">set_local_ufrag</span>(r-&gt;<span class="built_in">get_remote_ufrag</span>());</span><br><span class="line">    stun_binding_response.<span class="built_in">set_remote_ufrag</span>(r-&gt;<span class="built_in">get_local_ufrag</span>());</span><br><span class="line">    stun_binding_response.<span class="built_in">set_transcation_id</span>(r-&gt;<span class="built_in">get_transcation_id</span>());</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> inet_addr is deprecated, IPV6 support</span></span><br><span class="line">    <span class="comment">// 设置NAT映射的外网IP端口</span></span><br><span class="line">    stun_binding_response.<span class="built_in">set_mapped_address</span>(<span class="built_in">be32toh</span>(<span class="built_in">inet_addr</span>(<span class="built_in">get_peer_ip</span>().<span class="built_in">c_str</span>())));</span><br><span class="line">    stun_binding_response.<span class="built_in">set_mapped_port</span>(<span class="built_in">get_peer_port</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stun response encode</span></span><br><span class="line">    <span class="keyword">if</span> ((err = stun_binding_response.<span class="built_in">encode</span>(ice_pwd, stream)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;stun binding response encode failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">write</span>(stream-&gt;<span class="built_in">data</span>(), stream-&gt;<span class="built_in">pos</span>(), <span class="literal">NULL</span>)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;stun binding response send failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == SrsRtcNetworkStateWaitingStun) &#123;</span><br><span class="line">        state_ = SrsRtcNetworkStateDtls;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> Add cost.</span></span><br><span class="line">        <span class="built_in">srs_trace</span>(<span class="string">&quot;RTC: session STUN done, waiting DTLS handshake.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((err = transport_-&gt;<span class="built_in">start_active_handshake</span>()) != srs_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;fail to dtls handshake&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_srs_blackhole-&gt;blackhole) &#123;</span><br><span class="line">        _srs_blackhole-&gt;<span class="built_in">sendto</span>(stream-&gt;<span class="built_in">data</span>(), stream-&gt;<span class="built_in">pos</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsStunPacket::encode</span><span class="params">(<span class="type">const</span> string&amp; pwd, SrsBuffer* stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_binding_response</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">encode_binding_response</span>(pwd, stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">srs_error_new</span>(ERROR_RTC_STUN, <span class="string">&quot;unknown stun type=%d&quot;</span>, <span class="built_in">get_message_type</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> make this function easy to read</span></span><br><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsStunPacket::encode_binding_response</span><span class="params">(<span class="type">const</span> string&amp; pwd, SrsBuffer* stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    string property_username = <span class="built_in">encode_username</span>();</span><br><span class="line">    string mapped_address = <span class="built_in">encode_mapped_address</span>();</span><br><span class="line"></span><br><span class="line">    stream-&gt;<span class="built_in">write_2bytes</span>(BindingResponse);</span><br><span class="line">    stream-&gt;<span class="built_in">write_2bytes</span>(property_username.<span class="built_in">size</span>() + mapped_address.<span class="built_in">size</span>());</span><br><span class="line">    stream-&gt;<span class="built_in">write_4bytes</span>(kStunMagicCookie);</span><br><span class="line">    stream-&gt;<span class="built_in">write_string</span>(transcation_id);</span><br><span class="line">    stream-&gt;<span class="built_in">write_string</span>(property_username);</span><br><span class="line">    stream-&gt;<span class="built_in">write_string</span>(mapped_address);</span><br><span class="line"></span><br><span class="line">    stream-&gt;<span class="built_in">data</span>()[<span class="number">2</span>] = ((stream-&gt;<span class="built_in">pos</span>() - <span class="number">20</span> + <span class="number">20</span> + <span class="number">4</span>) &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    stream-&gt;<span class="built_in">data</span>()[<span class="number">3</span>] = ((stream-&gt;<span class="built_in">pos</span>() - <span class="number">20</span> + <span class="number">20</span> + <span class="number">4</span>) &amp; <span class="number">0x000000FF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置MESSAGE-INTEGRIT字段，用于ice-pwd检验</span></span><br><span class="line">    <span class="type">char</span> hmac_buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hmac_buf_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">hmac_encode</span>(<span class="string">&quot;sha1&quot;</span>, pwd.<span class="built_in">c_str</span>(), pwd.<span class="built_in">size</span>(), </span><br><span class="line">                           stream-&gt;<span class="built_in">data</span>(), stream-&gt;<span class="built_in">pos</span>(), hmac_buf, hmac_buf_len)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;hmac encode failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string hmac = <span class="built_in">encode_hmac</span>(hmac_buf, hmac_buf_len);</span><br><span class="line"></span><br><span class="line">    stream-&gt;<span class="built_in">write_string</span>(hmac);</span><br><span class="line">    stream-&gt;<span class="built_in">data</span>()[<span class="number">2</span>] = ((stream-&gt;<span class="built_in">pos</span>() - <span class="number">20</span> + <span class="number">8</span>) &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    stream-&gt;<span class="built_in">data</span>()[<span class="number">3</span>] = ((stream-&gt;<span class="built_in">pos</span>() - <span class="number">20</span> + <span class="number">8</span>) &amp; <span class="number">0x000000FF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置FINGERPRINT字段，CRC-32检验，防止篡改</span></span><br><span class="line">    <span class="type">uint32_t</span> crc32 = <span class="built_in">srs_crc32_ieee</span>(stream-&gt;<span class="built_in">data</span>(), stream-&gt;<span class="built_in">pos</span>(), <span class="number">0</span>) ^ <span class="number">0x5354554E</span>;</span><br><span class="line"></span><br><span class="line">    string fingerprint = <span class="built_in">encode_fingerprint</span>(crc32);</span><br><span class="line"></span><br><span class="line">    stream-&gt;<span class="built_in">write_string</span>(fingerprint);</span><br><span class="line"></span><br><span class="line">    stream-&gt;<span class="built_in">data</span>()[<span class="number">2</span>] = ((stream-&gt;<span class="built_in">pos</span>() - <span class="number">20</span>) &amp; <span class="number">0x0000FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    stream-&gt;<span class="built_in">data</span>()[<span class="number">3</span>] = ((stream-&gt;<span class="built_in">pos</span>() - <span class="number">20</span>) &amp; <span class="number">0x000000FF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/11/11/SRS%E9%85%8D%E7%BD%AE%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/SRS%E9%85%8D%E7%BD%AE%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/" class="post-title-link" itemprop="url">SRS配置一对一通话</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-11 21:12:12" itemprop="dateCreated datePublished" datetime="2023-11-11T21:12:12+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:37:22" itemprop="dateModified" datetime="2023-12-30T22:37:22+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SRS/" itemprop="url" rel="index"><span itemprop="name">SRS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SRS服务"><a href="#SRS服务" class="headerlink" title="SRS服务"></a>SRS服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ossrs/srs.git srs</span><br><span class="line">cd srs/trunk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译debug模式调试</span></span><br><span class="line">./configure --debug=on --debug-stats=on --prefix=`pwd`/install</span><br><span class="line">make -j4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装到当前目录下的install</span></span><br><span class="line">make instal</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">cd install</span><br><span class="line">./objs/srs -c conf/rtc.conf</span><br></pre></td></tr></table></figure>

<h1 id="信令服务"><a href="#信令服务" class="headerlink" title="信令服务"></a>信令服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd 3rdparty/signaling</span><br><span class="line">make</span><br><span class="line">./objs/signaling </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听1989端口</span></span><br></pre></td></tr></table></figure>

<h1 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成server.key</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">⽣成server.crt</span></span><br><span class="line">openssl req -new  -x509 -key server.key -out server.crt -days 3650</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译和启动httpx-static <span class="keyword">for</span> HTTPS/WSS</span></span><br><span class="line">cd 3rdparty/httpx-static</span><br><span class="line">make</span><br><span class="line">./objs/httpx-static -http 80 -https 443 -ssk server.key -ssc server.crt -proxy http://127.0.0.1:1989/sig -proxy http://127.0.0.1:1985/rtc -proxy http://127.0.0.1:8080</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1935端⼝对应的是rtmp服务</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1985对应的是http api服务</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8080对应的是http-flv、hls的服务器端⼝</span></span><br></pre></td></tr></table></figure>

<h1 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h1><p><a target="_blank" rel="noopener" href="http://localhost/demos/">http://localhost/demos/</a></p>
<p><a target="_blank" rel="noopener" href="https://localhost/demos/">https://localhost/demos/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/11/10/SRS-RTMP%E8%BD%ACRTC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/10/SRS-RTMP%E8%BD%ACRTC/" class="post-title-link" itemprop="url">SRS-RTMP转RTC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-10 17:58:26" itemprop="dateCreated datePublished" datetime="2023-11-10T17:58:26+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:37:37" itemprop="dateModified" datetime="2023-12-30T22:37:37+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SRS/" itemprop="url" rel="index"><span itemprop="name">SRS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>注：SRS版本为<code>v6.0.75</code></p>
<h1 id="RTMP2RTC服务运行"><a href="#RTMP2RTC服务运行" class="headerlink" title="RTMP2RTC服务运行"></a>RTMP2RTC服务运行</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>使用工程自带<code>rtmp2rtc.conf</code>配置文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">listen              1935;</span><br><span class="line">max_connections     1000;</span><br><span class="line">daemon              off;</span><br><span class="line">srs_log_tank        console;</span><br><span class="line"></span><br><span class="line">http_server &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          8080;</span><br><span class="line">    dir             ./objs/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http_api &#123;</span><br><span class="line">    enabled         on;</span><br><span class="line">    listen          1985;</span><br><span class="line">&#125;</span><br><span class="line">stats &#123;</span><br><span class="line">    network         0;</span><br><span class="line">&#125;</span><br><span class="line">rtc_server &#123;</span><br><span class="line">    enabled on;</span><br><span class="line">    listen 8000; # UDP port</span><br><span class="line">    # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#config-candidate</span><br><span class="line">    candidate $CANDIDATE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vhost __defaultVhost__ &#123;</span><br><span class="line">    rtc &#123;</span><br><span class="line">        enabled     on;</span><br><span class="line">        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#rtmp-to-rtc</span><br><span class="line">        rtmp_to_rtc on;</span><br><span class="line">        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#rtc-to-rtmp</span><br><span class="line">        rtc_to_rtmp on;</span><br><span class="line">    &#125;</span><br><span class="line">    http_remux &#123;</span><br><span class="line">        enabled     on;</span><br><span class="line">        mount       [vhost]/[app]/[stream].flv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h2><ul>
<li>运行SRS服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./obj/srs -c conf/rtmp2rtc.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>推流</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i test.mp4 -codec copy -f flv -y rtmp://127.0.0.1/live/livestream</span><br></pre></td></tr></table></figure>

<ul>
<li>拉流<ul>
<li>启动SRS后访问本地URL：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/players/rtc_player.html">http://127.0.0.1:8080/players/rtc_player.html</a> 。</li>
<li>进入RTC播放器，播放视频。</li>
</ul>
</li>
</ul>
<h1 id="RTMP2RTC推流端"><a href="#RTMP2RTC推流端" class="headerlink" title="RTMP2RTC推流端"></a>RTMP2RTC推流端</h1><h2 id="初始化RTC相关类"><a href="#初始化RTC相关类" class="headerlink" title="初始化RTC相关类"></a>初始化RTC相关类</h2><ul>
<li>断点<code>b SrsRtcSource::SrsRtcSource()</code>，查看堆栈。</li>
</ul>
<img src="/2023/11/10/SRS-RTMP%E8%BD%ACRTC/SrsRtcSource断点.png" alt="SrsRtcSource断点" style="zoom:50%;">

<h3 id="SrsRtmpConn-acquire-publish"><a href="#SrsRtmpConn-acquire-publish" class="headerlink" title="SrsRtmpConn::acquire_publish()"></a>SrsRtmpConn::acquire_publish()</h3><ul>
<li><code>_srs_rtc_sources-&gt;fetch_or_create</code>创建<code>SrsRtcSource</code>。</li>
<li><code>new SrsFrameToRtcBridge(rtc)</code>创建RTMPToRTC桥接器。</li>
<li><code>source-&gt;set_bridge(bridge)</code>设置桥接器，在<code>on_audio_imp()</code>中会使用到。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtmpConn::acquire_publish</span><span class="params">(SrsLiveSource* source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line">    </span><br><span class="line">    SrsRequest* req = info-&gt;req;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether RTC stream is busy.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_RTC</span></span><br><span class="line">    SrsRtcSource* rtc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> rtc_server_enabled = _srs_config-&gt;<span class="built_in">get_rtc_server_enabled</span>();</span><br><span class="line">    <span class="type">bool</span> rtc_enabled = _srs_config-&gt;<span class="built_in">get_rtc_enabled</span>(req-&gt;vhost);</span><br><span class="line">    <span class="keyword">if</span> (rtc_server_enabled &amp;&amp; rtc_enabled &amp;&amp; !info-&gt;edge) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err = _srs_rtc_sources-&gt;<span class="built_in">fetch_or_create</span>(req, &amp;rtc)) != srs_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;create source&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rtc-&gt;<span class="built_in">can_publish</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_new</span>(ERROR_SYSTEM_STREAM_BUSY, <span class="string">&quot;rtc stream %s busy&quot;</span>, </span><br><span class="line">                                 req-&gt;<span class="built_in">get_stream_url</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bridge to RTC streaming.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SRS_RTC) &amp;&amp; defined(SRS_FFMPEG_FIT)</span></span><br><span class="line">    <span class="keyword">if</span> (rtc &amp;&amp; _srs_config-&gt;<span class="built_in">get_rtc_from_rtmp</span>(req-&gt;vhost)) &#123;</span><br><span class="line">        SrsCompositeBridge* bridge = <span class="keyword">new</span> <span class="built_in">SrsCompositeBridge</span>();</span><br><span class="line">        bridge-&gt;<span class="built_in">append</span>(<span class="keyword">new</span> <span class="built_in">SrsFrameToRtcBridge</span>(rtc));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((err = bridge-&gt;<span class="built_in">initialize</span>(req)) != srs_success) &#123;</span><br><span class="line">            <span class="built_in">srs_freep</span>(bridge);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;bridge init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source-&gt;<span class="built_in">set_bridge</span>(bridge);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SrsRtcSourceManager-fetch-or-create"><a href="#SrsRtcSourceManager-fetch-or-create" class="headerlink" title="SrsRtcSourceManager::fetch_or_create()"></a>SrsRtcSourceManager::fetch_or_create()</h3><ul>
<li>通过<code>std::map&lt;std::string, SrsRtcSource*&gt; pool</code>保存url和对应的<code>SrsRtcSource</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcSourceManager::fetch_or_create</span><span class="params">(SrsRequest* r, SrsRtcSource** pps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lock to protect coroutine switch.</span></span><br><span class="line">    <span class="comment">// @bug https://github.com/ossrs/srs/issues/1230</span></span><br><span class="line">    <span class="built_in">SrsLocker</span>(lock);</span><br><span class="line"></span><br><span class="line">    SrsRtcSource* source = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((source = <span class="built_in">fetch</span>(r)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// we always update the request of resource,</span></span><br><span class="line">        <span class="comment">// for origin auth is on, the token in request maybe invalid,</span></span><br><span class="line">        <span class="comment">// and we only need to update the token of request, it&#x27;s simple.</span></span><br><span class="line">        source-&gt;<span class="built_in">update_auth</span>(r);</span><br><span class="line">        *pps = source;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string stream_url = r-&gt;<span class="built_in">get_stream_url</span>();</span><br><span class="line">    string vhost = r-&gt;vhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should always not exists for create a source.</span></span><br><span class="line">    <span class="built_in">srs_assert</span> (pool.<span class="built_in">find</span>(stream_url) == pool.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srs_trace</span>(<span class="string">&quot;new rtc source, stream_url=%s&quot;</span>, stream_url.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    source = <span class="keyword">new</span> <span class="built_in">SrsRtcSource</span>();</span><br><span class="line">    <span class="keyword">if</span> ((err = source-&gt;<span class="built_in">initialize</span>(r)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;init source %s&quot;</span>, r-&gt;<span class="built_in">get_stream_url</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool[stream_url] = source;</span><br><span class="line"></span><br><span class="line">    *pps = source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换数据给拉流端"><a href="#转换数据给拉流端" class="headerlink" title="转换数据给拉流端"></a>转换数据给拉流端</h2><ul>
<li>断点<code>b SrsRtcConsumer::enqueue(SrsRtpPacket*)</code>。</li>
</ul>
<img src="/2023/11/10/SRS-RTMP%E8%BD%ACRTC/SrsRtcConsumer中enqueue断点.png" alt="SrsRtcConsumer中enqueue断点" style="zoom:50%;">

<h3 id="SrsLiveSource-on-audio-imp"><a href="#SrsLiveSource-on-audio-imp" class="headerlink" title="SrsLiveSource::on_audio_imp()"></a>SrsLiveSource::on_audio_imp()</h3><ul>
<li>调用上述初始化RTC设置的<code>SrsCompositeBridge</code>处理。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsLiveSource::on_audio_imp</span><span class="params">(SrsSharedPtrMessage* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// For bridge to consume the message.</span></span><br><span class="line">    <span class="keyword">if</span> (bridge_ &amp;&amp; (err = bridge_-&gt;<span class="built_in">on_frame</span>(msg)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;bridge consume audio&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SrsCompositeBridge-on-frame"><a href="#SrsCompositeBridge-on-frame" class="headerlink" title="SrsCompositeBridge::on_frame()"></a>SrsCompositeBridge::on_frame()</h3><ul>
<li><code>bridge</code>是<code>SrsFrameToRtcBridge</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsCompositeBridge::on_frame</span><span class="params">(SrsSharedPtrMessage* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;ISrsStreamBridge*&gt;::iterator it = bridges_.<span class="built_in">begin</span>(); it != bridges_.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        ISrsStreamBridge* bridge = *it;</span><br><span class="line">        <span class="keyword">if</span> ((err = bridge-&gt;<span class="built_in">on_frame</span>(frame)) != srs_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsFrameToRtcBridge::on_frame</span><span class="params">(SrsSharedPtrMessage* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_FFMPEG_FIT</span></span><br><span class="line">    <span class="keyword">return</span> rtp_builder_-&gt;<span class="built_in">on_frame</span>(frame);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> srs_success;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcRtpBuilder::on_frame</span><span class="params">(SrsSharedPtrMessage* frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;<span class="built_in">is_audio</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">on_audio</span>(frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame-&gt;<span class="built_in">is_video</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">on_video</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srs_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SrsRtcRtpBuilder-on-audio"><a href="#SrsRtcRtpBuilder-on-audio" class="headerlink" title="SrsRtcRtpBuilder::on_audio()"></a>SrsRtcRtpBuilder::on_audio()</h3><ul>
<li><code>init_codec</code>初始化编解码器。</li>
<li><code>aac_raw_append_adts_header</code>封装ADTS。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcRtpBuilder::on_audio</span><span class="params">(SrsSharedPtrMessage* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> Support parsing OPUS for RTC.</span></span><br><span class="line">    <span class="keyword">if</span> ((err = format-&gt;<span class="built_in">on_audio</span>(msg)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;format consume audio&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to init codec when startup or codec changed.</span></span><br><span class="line">    <span class="keyword">if</span> (format-&gt;acodec &amp;&amp; (err = <span class="built_in">init_codec</span>(format-&gt;acodec-&gt;id)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;init codec&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore if no format-&gt;acodec, it means the codec is not parsed, or unknown codec.</span></span><br><span class="line">    <span class="comment">// @issue https://github.com/ossrs/srs/issues/1506#issuecomment-562079474</span></span><br><span class="line">    <span class="keyword">if</span> (!format-&gt;acodec) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ts support audio codec: aac/mp3</span></span><br><span class="line">    SrsAudioCodecId acodec = format-&gt;acodec-&gt;id;</span><br><span class="line">    <span class="keyword">if</span> (acodec != SrsAudioCodecIdAAC &amp;&amp; acodec != SrsAudioCodecIdMP3) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ignore sequence header</span></span><br><span class="line">    <span class="built_in">srs_assert</span>(format-&gt;audio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (format-&gt;acodec-&gt;id == SrsAudioCodecIdMP3) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">transcode</span>(format-&gt;audio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When drop aac audio packet, never transcode.</span></span><br><span class="line">    <span class="keyword">if</span> (acodec != SrsAudioCodecIdAAC) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* adts_audio = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> nn_adts_audio = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> Reserve 7 bytes header when create shared message.</span></span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">aac_raw_append_adts_header</span>(msg, format, &amp;adts_audio, &amp;nn_adts_audio)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;aac append header&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!adts_audio) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SrsAudioFrame aac;</span><br><span class="line">    aac.dts = format-&gt;audio-&gt;dts;</span><br><span class="line">    aac.cts = format-&gt;audio-&gt;cts;</span><br><span class="line">    <span class="keyword">if</span> ((err = aac.<span class="built_in">add_sample</span>(adts_audio, nn_adts_audio)) == srs_success) &#123;</span><br><span class="line">        <span class="comment">// If OK, transcode the AAC to Opus and consume it.</span></span><br><span class="line">        err = <span class="built_in">transcode</span>(&amp;aac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srs_freepa</span>(adts_audio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SrsRtcRtpBuilder-transcode"><a href="#SrsRtcRtpBuilder-transcode" class="headerlink" title="SrsRtcRtpBuilder::transcode()"></a>SrsRtcRtpBuilder::transcode()</h3><ul>
<li><code>SrsAudioFrame</code>转<code>SrsRtpPacket</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcRtpBuilder::transcode</span><span class="params">(SrsAudioFrame* audio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;SrsAudioFrame*&gt; out_audios;</span><br><span class="line">    <span class="keyword">if</span> ((err = codec_-&gt;<span class="built_in">transcode</span>(audio, out_audios)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;recode error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save OPUS packets in shared message.</span></span><br><span class="line">    <span class="keyword">if</span> (out_audios.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;SrsAudioFrame*&gt;::iterator it = out_audios.<span class="built_in">begin</span>(); it != out_audios.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        SrsAudioFrame* out_audio = *it;</span><br><span class="line"></span><br><span class="line">        SrsRtpPacket* pkt = <span class="keyword">new</span> <span class="built_in">SrsRtpPacket</span>();</span><br><span class="line">        <span class="built_in">SrsAutoFree</span>(SrsRtpPacket, pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((err = <span class="built_in">package_opus</span>(out_audio, pkt)) != srs_success) &#123;</span><br><span class="line">            err = <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;package opus&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((err = bridge_-&gt;<span class="built_in">on_rtp</span>(pkt)) != srs_success) &#123;</span><br><span class="line">            err = <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;consume opus&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codec_-&gt;<span class="built_in">free_frames</span>(out_audios);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SrsFrameToRtcBridge-on-rtp"><a href="#SrsFrameToRtcBridge-on-rtp" class="headerlink" title="SrsFrameToRtcBridge::on_rtp()"></a>SrsFrameToRtcBridge::on_rtp()</h3><ul>
<li><code>consumer-&gt;enqueue</code>入队列。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsFrameToRtcBridge::on_rtp</span><span class="params">(SrsRtpPacket* pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_RTC</span></span><br><span class="line">    <span class="keyword">return</span> source_-&gt;<span class="built_in">on_rtp</span>(pkt);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> srs_success;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcSource::on_rtp</span><span class="params">(SrsRtpPacket* pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If circuit-breaker is dying, drop packet.</span></span><br><span class="line">    <span class="keyword">if</span> (_srs_circuit_breaker-&gt;<span class="built_in">hybrid_dying_water_level</span>()) &#123;</span><br><span class="line">        _srs_pps_aloss2-&gt;sugar += (<span class="type">int64_t</span>)consumers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)consumers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        SrsRtcConsumer* consumer = consumers.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span> ((err = consumer-&gt;<span class="built_in">enqueue</span>(pkt-&gt;<span class="built_in">copy</span>())) != srs_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;consume message&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_FFMPEG_FIT</span></span><br><span class="line">    <span class="keyword">if</span> (frame_builder_ &amp;&amp; (err = frame_builder_-&gt;<span class="built_in">on_rtp</span>(pkt)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;frame builder consume packet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RTMP2RTC拉流端"><a href="#RTMP2RTC拉流端" class="headerlink" title="RTMP2RTC拉流端"></a>RTMP2RTC拉流端</h1><h2 id="RTC客户端连接"><a href="#RTC客户端连接" class="headerlink" title="RTC客户端连接"></a>RTC客户端连接</h2><h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><p>RTC播放器请求 webrtc:&#x2F;&#x2F;127.0.0.1&#x2F;xxx&#x2F;xxx 后，首先通过HTTP信令建立 offer 和 answer 的交互，然后通过 answer 解析出来的 ICE Server 地址进行 UDP 连接数据通信。</p>
<ul>
<li>断点<code>b SrsGoApiRtcPlay::do_serve_http(ISrsHttpResponseWriter*, ISrsHttpMessage*, SrsJsonObject*)</code>。</li>
</ul>
<img src="/2023/11/10/SRS-RTMP%E8%BD%ACRTC/SrsGoApiRtcPlay中断点.jpg" alt="SrsGoApiRtcPlay中断点" style="zoom:50%;">

<h4 id="SrsGoApiRtcPlay-do-serve-http"><a href="#SrsGoApiRtcPlay-do-serve-http" class="headerlink" title="SrsGoApiRtcPlay::do_serve_http()"></a>SrsGoApiRtcPlay::do_serve_http()</h4><ul>
<li>接收请求url<code>/rtc/v1/play/</code>。</li>
<li>请求中解析sdp、streamers、clientip、tid、api。</li>
<li><code>server_http</code>中创建<code>SrsRtcConnection</code>，具体在<code>do_create_session</code>中实现。</li>
<li>响应设置sdp等相关信息返回。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsGoApiRtcPlay::do_serve_http</span><span class="params">(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, SrsJsonObject* res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each RTC session, we use short-term HTTP connection.</span></span><br><span class="line">    SrsHttpHeader* hdr = w-&gt;<span class="built_in">header</span>();</span><br><span class="line">    hdr-&gt;<span class="built_in">set</span>(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Close&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse req, the request json object, from body.</span></span><br><span class="line">    SrsJsonObject* req = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">SrsAutoFree</span>(SrsJsonObject, req);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string req_json;</span><br><span class="line">        <span class="keyword">if</span> ((err = r-&gt;<span class="built_in">body_read_all</span>(req_json)) != srs_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;read body&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SrsJsonAny* json = SrsJsonAny::<span class="built_in">loads</span>(req_json);</span><br><span class="line">        <span class="keyword">if</span> (!json || !json-&gt;<span class="built_in">is_object</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_new</span>(ERROR_RTC_API_BODY, <span class="string">&quot;invalid body %s&quot;</span>, req_json.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req = json-&gt;<span class="built_in">to_object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch params from req object.</span></span><br><span class="line">    SrsJsonAny* prop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((prop = req-&gt;<span class="built_in">ensure_property_string</span>(<span class="string">&quot;sdp&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;not sdp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string remote_sdp_str = prop-&gt;<span class="built_in">to_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((prop = req-&gt;<span class="built_in">ensure_property_string</span>(<span class="string">&quot;streamurl&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;not streamurl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string streamurl = prop-&gt;<span class="built_in">to_str</span>();</span><br><span class="line"></span><br><span class="line">    string clientip;</span><br><span class="line">    <span class="keyword">if</span> ((prop = req-&gt;<span class="built_in">ensure_property_string</span>(<span class="string">&quot;clientip&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        clientip = prop-&gt;<span class="built_in">to_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientip.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        clientip = <span class="built_in">dynamic_cast</span>&lt;SrsHttpMessage*&gt;(r)-&gt;<span class="built_in">connection</span>()-&gt;<span class="built_in">remote_ip</span>();</span><br><span class="line">        <span class="comment">// Overwrite by ip from proxy.        </span></span><br><span class="line">        string oip = <span class="built_in">srs_get_original_ip</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (!oip.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            clientip = oip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string api;</span><br><span class="line">    <span class="keyword">if</span> ((prop = req-&gt;<span class="built_in">ensure_property_string</span>(<span class="string">&quot;api&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        api = prop-&gt;<span class="built_in">to_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string tid;</span><br><span class="line">    <span class="keyword">if</span> ((prop = req-&gt;<span class="built_in">ensure_property_string</span>(<span class="string">&quot;tid&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tid = prop-&gt;<span class="built_in">to_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The RTC user config object.</span></span><br><span class="line">    SrsRtcUserConfig ruc;</span><br><span class="line">    ruc.req_-&gt;ip = clientip;</span><br><span class="line">    ruc.api_ = api;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srs_parse_rtmp_url</span>(streamurl, ruc.req_-&gt;tcUrl, ruc.req_-&gt;stream);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srs_discovery_tc_url</span>(ruc.req_-&gt;tcUrl, ruc.req_-&gt;schema, ruc.req_-&gt;host, ruc.req_-&gt;vhost,</span><br><span class="line">                         ruc.req_-&gt;app, ruc.req_-&gt;stream, ruc.req_-&gt;port, ruc.req_-&gt;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discovery vhost, resolve the vhost from config</span></span><br><span class="line">    SrsConfDirective* parsed_vhost = _srs_config-&gt;<span class="built_in">get_vhost</span>(ruc.req_-&gt;vhost);</span><br><span class="line">    <span class="keyword">if</span> (parsed_vhost) &#123;</span><br><span class="line">        ruc.req_-&gt;vhost = parsed_vhost-&gt;<span class="built_in">arg0</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For client to specifies the candidate(EIP) of server.</span></span><br><span class="line">    string eip = r-&gt;<span class="built_in">query_get</span>(<span class="string">&quot;eip&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (eip.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        eip = r-&gt;<span class="built_in">query_get</span>(<span class="string">&quot;candidate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string codec = r-&gt;<span class="built_in">query_get</span>(<span class="string">&quot;codec&quot;</span>);</span><br><span class="line">    <span class="comment">// For client to specifies whether encrypt by SRTP.</span></span><br><span class="line">    string srtp = r-&gt;<span class="built_in">query_get</span>(<span class="string">&quot;encrypt&quot;</span>);</span><br><span class="line">    string dtls = r-&gt;<span class="built_in">query_get</span>(<span class="string">&quot;dtls&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srs_trace</span>(</span><br><span class="line">            <span class="string">&quot;RTC play %s, api=%s, tid=%s, clientip=%s, app=%s, stream=%s, offer=%dB, eip=%s, codec=%s, srtp=%s, dtls=%s&quot;</span>,</span><br><span class="line">            streamurl.<span class="built_in">c_str</span>(), api.<span class="built_in">c_str</span>(), tid.<span class="built_in">c_str</span>(), clientip.<span class="built_in">c_str</span>(), ruc.req_-&gt;app.<span class="built_in">c_str</span>(),</span><br><span class="line">            ruc.req_-&gt;stream.<span class="built_in">c_str</span>(), remote_sdp_str.<span class="built_in">length</span>(),</span><br><span class="line">            eip.<span class="built_in">c_str</span>(), codec.<span class="built_in">c_str</span>(), srtp.<span class="built_in">c_str</span>(), dtls.<span class="built_in">c_str</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ruc.eip_ = eip;</span><br><span class="line">    ruc.codec_ = codec;</span><br><span class="line">    ruc.publish_ = <span class="literal">false</span>;</span><br><span class="line">    ruc.dtls_ = (dtls != <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srtp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ruc.srtp_ = _srs_config-&gt;<span class="built_in">get_rtc_server_encrypt</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ruc.srtp_ = (srtp != <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> It seems remote_sdp doesn&#x27;t represents the full SDP information.</span></span><br><span class="line">    ruc.remote_sdp_str_ = remote_sdp_str;</span><br><span class="line">    <span class="keyword">if</span> ((err = ruc.remote_sdp_.<span class="built_in">parse</span>(remote_sdp_str)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;parse sdp failed: %s&quot;</span>, remote_sdp_str.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">serve_http</span>(w, r, &amp;ruc)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;serve&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res-&gt;<span class="built_in">set</span>(<span class="string">&quot;code&quot;</span>, SrsJsonAny::<span class="built_in">integer</span>(ERROR_SUCCESS));</span><br><span class="line">    res-&gt;<span class="built_in">set</span>(<span class="string">&quot;server&quot;</span>, SrsJsonAny::<span class="built_in">str</span>(SrsStatistic::<span class="built_in">instance</span>()-&gt;<span class="built_in">server_id</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">    res-&gt;<span class="built_in">set</span>(<span class="string">&quot;service&quot;</span>, SrsJsonAny::<span class="built_in">str</span>(SrsStatistic::<span class="built_in">instance</span>()-&gt;<span class="built_in">service_id</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">    res-&gt;<span class="built_in">set</span>(<span class="string">&quot;pid&quot;</span>, SrsJsonAny::<span class="built_in">str</span>(SrsStatistic::<span class="built_in">instance</span>()-&gt;<span class="built_in">service_pid</span>().<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add candidates in response json?</span></span><br><span class="line">    res-&gt;<span class="built_in">set</span>(<span class="string">&quot;sdp&quot;</span>, SrsJsonAny::<span class="built_in">str</span>(ruc.local_sdp_str_.<span class="built_in">c_str</span>()));</span><br><span class="line">    res-&gt;<span class="built_in">set</span>(<span class="string">&quot;sessionid&quot;</span>, SrsJsonAny::<span class="built_in">str</span>(ruc.session_id_.<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SrsRtcServer-create-session"><a href="#SrsRtcServer-create-session" class="headerlink" title="SrsRtcServer::create_session()"></a>SrsRtcServer::create_session()</h4><pre class="mermaid">graph TB
    F1[SrsRtcServer::create_session]-->F2[new SrsRtcConnection]
    F1-->F3[SrsRtcServer::do_create_session]
    F3-->F4[SrsRtcConnection::add_publisher]
    F3-->F5[SrsRtcConnection::add_player]
    F3-->F6[SrsResourceManager::add_with_name]
    F5-->F7[SrsRtcConnection::create_player]
    F7-->F8[new SrsRtcPlayStream]
    F7-->F9[SrsRtcPlayStream::initialize]
    F9-->F10[new SrsRtcAudioSendTrack]
    F9-->F11[new SrsRtcVideoSendTrack]</pre>

<h3 id="UDP连接"><a href="#UDP连接" class="headerlink" title="UDP连接"></a>UDP连接</h3><ul>
<li>断点<code>b SrsRtcServer::on_udp_packet(SrsUdpMuxSocket*)</code>。</li>
</ul>
<img src="/2023/11/10/SRS-RTMP%E8%BD%ACRTC/SrsRtcServer中on_udp_packet断点.png" alt="SrsRtcServer中on_udp_packet断点" style="zoom:50%;">

<h4 id="SrsRtcServer-on-udp-packet"><a href="#SrsRtcServer-on-udp-packet" class="headerlink" title="SrsRtcServer::on_udp_packet()"></a>SrsRtcServer::on_udp_packet()</h4><pre class="mermaid">graph TB
    F1[SrsRtcServer::on_udp_packet]-->F2[SrsRtcUdpNetwork::on_dtls]
    F2-->F3[SrsSecurityTransport::on_dtls]
    F3-->F4[SrsDtls::on_dtls]
    F4-->F5[SrsDtlsImpl::on_dtls]
    F5-->F6[SrsDtlsImpl::do_on_dtls]
    F6-->F7[SrsDtlsServerImpl::on_handshake_done]
    F7-->F8[SrsSecurityTransport::on_dtls_handshake_done]
    F8-->F9[SrsRtcUdpNetwork::on_dtls_handshake_done]
    F9-->F10[SrsRtcConnection::on_dtls_handshake_done]
    F10-->F11[SrsRtcPlayStream::start]
    F11-->F12[SrsRtcPlayStream::cycle]</pre>

<h2 id="推流端取转换数据"><a href="#推流端取转换数据" class="headerlink" title="推流端取转换数据"></a>推流端取转换数据</h2><ul>
<li>断点<code>b SrsRtcConsumer::dump_packet(SrsRtpPacket**)</code>，查看堆栈。</li>
</ul>
<img src="/2023/11/10/SRS-RTMP%E8%BD%ACRTC/SrsRtcConsumer中dump_packet断点.png" alt="SrsRtcConsumer中dump_packet断点" style="zoom:50%;">

<h3 id="SrsRtcPlayStream-cycle"><a href="#SrsRtcPlayStream-cycle" class="headerlink" title="SrsRtcPlayStream::cycle()"></a>SrsRtcPlayStream::cycle()</h3><ul>
<li><p><code>SrsRtcSource</code>在上述推流<code>bridge-&gt;initialize</code>中<code>SrsRtcPlayStream::initialize</code>中初始化。</p>
</li>
<li><p><code>consumer-&gt;dump_packet(&amp;pkt)</code>获取数据。</p>
</li>
<li><p><code>send_packet(pkt)</code>发送数据。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtcPlayStream::cycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    SrsRtcSource* source = source_;</span><br><span class="line"></span><br><span class="line">    SrsRtcConsumer* consumer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">SrsAutoFree</span>(SrsRtcConsumer, consumer);</span><br><span class="line">    <span class="keyword">if</span> ((err = source-&gt;<span class="built_in">create_consumer</span>(consumer)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;create consumer, source=%s&quot;</span>, req_-&gt;<span class="built_in">get_stream_url</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srs_assert</span>(consumer);</span><br><span class="line">    consumer-&gt;<span class="built_in">set_handler</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> Dumps the SPS/PPS from gop cache, without other frames.</span></span><br><span class="line">    <span class="keyword">if</span> ((err = source-&gt;<span class="built_in">consumer_dumps</span>(consumer)) != srs_success) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;dumps consumer, url=%s&quot;</span>, req_-&gt;<span class="built_in">get_stream_url</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    realtime = _srs_config-&gt;<span class="built_in">get_realtime_enabled</span>(req_-&gt;vhost, <span class="literal">true</span>);</span><br><span class="line">    mw_msgs = _srs_config-&gt;<span class="built_in">get_mw_msgs</span>(req_-&gt;vhost, realtime, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> Add cost in ms.</span></span><br><span class="line">    SrsContextId cid = source-&gt;<span class="built_in">source_id</span>();</span><br><span class="line">    <span class="built_in">srs_trace</span>(<span class="string">&quot;RTC: start play url=%s, source_id=%s/%s, realtime=%d, mw_msgs=%d&quot;</span>, </span><br><span class="line">              req_-&gt;<span class="built_in">get_stream_url</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">        cid.<span class="built_in">c_str</span>(), source-&gt;<span class="built_in">pre_source_id</span>().<span class="built_in">c_str</span>(), realtime, mw_msgs);</span><br><span class="line"></span><br><span class="line">    SrsErrorPithyPrint* epp = <span class="keyword">new</span> <span class="built_in">SrsErrorPithyPrint</span>();</span><br><span class="line">    <span class="built_in">SrsAutoFree</span>(SrsErrorPithyPrint, epp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err = trd_-&gt;<span class="built_in">pull</span>()) != srs_success) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">srs_error_wrap</span>(err, <span class="string">&quot;rtc sender thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for amount of packets.</span></span><br><span class="line">        SrsRtpPacket* pkt = <span class="literal">NULL</span>;</span><br><span class="line">        consumer-&gt;<span class="built_in">dump_packet</span>(&amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (!pkt) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> We should check the quit event.</span></span><br><span class="line">            consumer-&gt;<span class="built_in">wait</span>(mw_msgs);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send-out the RTP packet and do cleanup</span></span><br><span class="line">        <span class="comment">// @remark Note that the pkt might be set to NULL.</span></span><br><span class="line">        <span class="keyword">if</span> ((err = <span class="built_in">send_packet</span>(pkt)) != srs_success) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> nn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (epp-&gt;<span class="built_in">can_print</span>(err, &amp;nn)) &#123;</span><br><span class="line">                <span class="built_in">srs_warn</span>(<span class="string">&quot;play send packets=%u, nn=%u/%u, err: %s&quot;</span>, </span><br><span class="line">                         <span class="number">1</span>, epp-&gt;nn_count, nn, <span class="built_in">srs_error_desc</span>(err).<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">srs_freep</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Free the packet.</span></span><br><span class="line">        <span class="comment">// @remark Note that the pkt might be set to NULL.</span></span><br><span class="line">        <span class="built_in">srs_freep</span>(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/10/30/SRS%E9%85%8D%E7%BD%AE%E5%BD%B1%E5%93%8D%E5%BB%B6%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/30/SRS%E9%85%8D%E7%BD%AE%E5%BD%B1%E5%93%8D%E5%BB%B6%E6%97%B6/" class="post-title-link" itemprop="url">SRS配置影响延时</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-30 19:05:57" itemprop="dateCreated datePublished" datetime="2023-10-30T19:05:57+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:37:19" itemprop="dateModified" datetime="2023-12-30T22:37:19+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SRS/" itemprop="url" rel="index"><span itemprop="name">SRS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>音视频传输过程中不同端都会产生延迟，比如推流端可能由于编码会产生延迟，拉流端可能会缓存数据产生延迟，流媒体服务器转发过程中也会缓存数据产生延迟，本文只要考虑流媒体SRS服务器产生的延迟可能。</p>
<h1 id="低延时配置"><a href="#低延时配置" class="headerlink" title="低延时配置"></a>低延时配置</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the listen ports, split by space.</span></span><br><span class="line"><span class="attribute">listen</span>              <span class="number">1935</span>;</span><br><span class="line"><span class="attribute">vhost</span> __defaultVhost__ &#123;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>     <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">min_latency</span>     <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">play</span> &#123;</span><br><span class="line">        <span class="attribute">gop_cache</span>       <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">queue_length</span>    <span class="number">10</span>;</span><br><span class="line">        <span class="attribute">mw_latency</span>      <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">publish</span> &#123;</span><br><span class="line">        <span class="attribute">mr</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Min-Latency"><a href="#Min-Latency" class="headerlink" title="Min-Latency"></a>Min-Latency</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>当开启最低延迟配置后，SRS会禁用mr(merged-read)，并且在consumer队列中使用超时等待，大约每收到1-2个视频包就发送给客户端，达到最低延迟目标。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vhost</span> mrw.srs.com &#123;</span><br><span class="line">    <span class="comment"># whether enable min delay mode for vhost.</span></span><br><span class="line">    <span class="comment"># for min latence mode:</span></span><br><span class="line">    <span class="comment"># 1. disable the publish.mr for vhost.</span></span><br><span class="line">    <span class="comment"># 2. use timeout for cond wait for consumer queue.</span></span><br><span class="line">    <span class="comment"># @see https://github.com/ossrs/srs/issues/257</span></span><br><span class="line">    <span class="comment"># default: off</span></span><br><span class="line">    <span class="attribute">min_latency</span>     <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于RTC默认开启，否则关闭。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SrsConfig::get_realtime_enabled</span><span class="params">(string vhost, <span class="type">bool</span> is_rtc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_rtc) &#123;</span><br><span class="line">        <span class="built_in">SRS_OVERWRITE_BY_ENV_BOOL2</span>(<span class="string">&quot;srs.vhost.min_latency&quot;</span>); <span class="comment">// SRS_VHOST_MIN_LATENCY</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">SRS_OVERWRITE_BY_ENV_BOOL</span>(<span class="string">&quot;srs.vhost.min_latency&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> SYS_DEFAULT = SRS_PERF_MIN_LATENCY_ENABLED;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> RTC_DEFAULT = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> DEFAULT = is_rtc? RTC_DEFAULT : SYS_DEFAULT;</span><br><span class="line"></span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;min_latency&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_rtc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SRS_CONF_PERFER_TRUE</span>(conf-&gt;<span class="built_in">arg0</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SRS_CONF_PERFER_FALSE</span>(conf-&gt;<span class="built_in">arg0</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Merged-Read"><a href="#Merged-Read" class="headerlink" title="Merged-Read"></a>Merged-Read</h1><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>RTMP的Read效率非常低，需要先读一个字节，判断是哪个chunk，然后读取header，接着读取payload。因此上行支持的流的路数大约只有下行的1&#x2F;3，譬如SRS1.0支持下行2700上行只有1000，SRS2.0支持下行10000上行只有4500。</p>
<p>为了提高性能，SRS对于上行的read使用merged-read，即SRS在读写时一次读取N毫秒的数据，这个可以配置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># the MR(merged-read) setting for publisher.</span></span><br><span class="line">vhost mrw.srs.com &#123;</span><br><span class="line">    publish &#123;</span><br><span class="line">        mr          on;</span><br><span class="line">        mr_latency  <span class="number">350</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当开启merged-read之后，服务器的接收缓冲区至少会有latency毫秒的数据，延迟也就会有这么多毫秒。</p>
<p>若需要低延迟配置，关闭merged-read，服务器每次收到1个包就会解析。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>分别看下读取和使用配置字段的代码。</p>
<h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SrsPublishRecvThread::<span class="built_in">SrsPublishRecvThread</span>(SrsRtmpServer* rtmp_sdk, SrsRequest* _req,</span><br><span class="line">	<span class="type">int</span> mr_sock_fd, <span class="type">srs_utime_t</span> tm, SrsRtmpConn* conn, SrsLiveSource* source, SrsContextId parent_cid)</span><br><span class="line">    : <span class="built_in">trd</span>(<span class="keyword">this</span>, rtmp_sdk, tm, parent_cid)</span><br><span class="line">&#123;</span><br><span class="line">    rtmp = rtmp_sdk;</span><br><span class="line">    </span><br><span class="line">    _conn = conn;</span><br><span class="line">    _source = source;</span><br><span class="line"></span><br><span class="line">    nn_msgs_for_yield_ = <span class="number">0</span>;</span><br><span class="line">    recv_error = srs_success;</span><br><span class="line">    _nb_msgs = <span class="number">0</span>;</span><br><span class="line">    video_frames = <span class="number">0</span>;</span><br><span class="line">    error = <span class="built_in">srs_cond_new</span>();</span><br><span class="line"></span><br><span class="line">    req = _req;</span><br><span class="line">    mr_fd = mr_sock_fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the mr settings,</span></span><br><span class="line">    mr = _srs_config-&gt;<span class="built_in">get_mr_enabled</span>(req-&gt;vhost);</span><br><span class="line">    mr_sleep = _srs_config-&gt;<span class="built_in">get_mr_sleep</span>(req-&gt;vhost);</span><br><span class="line">    </span><br><span class="line">    realtime = _srs_config-&gt;<span class="built_in">get_realtime_enabled</span>(req-&gt;vhost);</span><br><span class="line">    </span><br><span class="line">    _srs_config-&gt;<span class="built_in">subscribe</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认下是关闭合并读。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SrsConfig::get_mr_enabled</span><span class="params">(string vhost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SRS_OVERWRITE_BY_ENV_BOOL</span>(<span class="string">&quot;srs.vhost.publish.mr&quot;</span>); <span class="comment">// SRS_VHOST_PUBLISH_MR</span></span><br><span class="line"></span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> SRS_PERF_MR_ENABLED; <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;publish&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> SRS_PERF_MR_ENABLED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;mr&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> SRS_PERF_MR_ENABLED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SRS_CONF_PERFER_FALSE</span>(conf-&gt;<span class="built_in">arg0</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认350ms。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_utime_t</span> <span class="title">SrsConfig::get_mr_sleep</span><span class="params">(string vhost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SRS_OVERWRITE_BY_ENV_MILLISECONDS</span>(<span class="string">&quot;srs.vhost.publish.mr_latency&quot;</span>); <span class="comment">// SRS_VHOST_PUBLISH_MR_LATENCY</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">srs_utime_t</span> DEFAULT = SRS_PERF_MR_SLEEP;</span><br><span class="line"></span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;publish&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;mr_latency&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">srs_utime_t</span>)(::<span class="built_in">atoi</span>(conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">c_str</span>()) * SRS_UTIME_MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SrsPublishRecvThread::on_start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// we donot set the auto response to false,</span></span><br><span class="line">    <span class="comment">// for the main thread never send message.</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_PERF_MERGED_READ</span></span><br><span class="line">    <span class="keyword">if</span> (mr) &#123;</span><br><span class="line">        <span class="comment">// set underlayer buffer size</span></span><br><span class="line">        <span class="built_in">set_socket_buffer</span>(mr_sleep);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// disable the merge read</span></span><br><span class="line">        rtmp-&gt;<span class="built_in">set_merge_read</span>(<span class="literal">true</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SrsPublishRecvThread::on_read</span><span class="params">(<span class="type">ssize_t</span> nread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mr || realtime) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span> || mr_sleep &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * to improve read performance, merge some packets then read,</span></span><br><span class="line"><span class="comment">     * when it on and read small bytes, we sleep to wait more data.,</span></span><br><span class="line"><span class="comment">     * that is, we merge some data to read together.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (nread &lt; SRS_MR_SMALL_BYTES) &#123;</span><br><span class="line">        <span class="built_in">srs_usleep</span>(mr_sleep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Merged-Write"><a href="#Merged-Write" class="headerlink" title="Merged-Write"></a>Merged-Write</h1><h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><p>SRS永远使用Merged-Write，即一次发送N毫秒的包给客户端。这个算法可以将RTMP下行的效率提升5倍左右，SRS1.0每次writev一个packet支持2700客户端，SRS2.0一次writev多个packet支持10000客户端。</p>
<p>用户可以配置merged-write一次写入的包的数目，建议不做修改：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the MW(merged-write) settings for player.</span></span><br><span class="line"><span class="attribute">vhost</span> mrw.srs.com &#123;</span><br><span class="line">    <span class="comment"># for play client, both RTMP and other stream clients,</span></span><br><span class="line">    <span class="comment"># for instance, the HTTP FLV stream clients.</span></span><br><span class="line">    <span class="section">play</span> &#123;</span><br><span class="line">        <span class="comment"># set the MW(merged-write) latency in ms. </span></span><br><span class="line">        <span class="comment"># SRS always set mw on, so we just set the latency value.</span></span><br><span class="line">        <span class="comment"># the latency of stream &gt;= mw_latency + mr_latency</span></span><br><span class="line">        <span class="comment"># the value recomment is [300, 1800]</span></span><br><span class="line">        <span class="comment"># default: 350</span></span><br><span class="line">        <span class="attribute">mw_latency</span>      <span class="number">350</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若需要极低延迟（损失较多性能），可以设置为100毫秒，SRS大约一次发送几个包。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>对于RTC合并写默认设置为0ms，否则默认设置为350ms。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_utime_t</span> <span class="title">SrsConfig::get_mw_sleep</span><span class="params">(string vhost, <span class="type">bool</span> is_rtc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">srs_getenv</span>(<span class="string">&quot;srs.vhost.play.mw_latency&quot;</span>).<span class="built_in">empty</span>()) &#123; <span class="comment">// SRS_VHOST_PLAY_MW_LATENCY</span></span><br><span class="line">        <span class="type">int</span> v = ::<span class="built_in">atoi</span>(<span class="built_in">srs_getenv</span>(<span class="string">&quot;srs.vhost.play.mw_latency&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (is_rtc &amp;&amp; v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">srs_warn</span>(<span class="string">&quot;For RTC, we ignore mw_latency&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">srs_utime_t</span>)(v * SRS_UTIME_MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">srs_utime_t</span> SYS_DEFAULT = SRS_PERF_MW_SLEEP;</span><br><span class="line">    <span class="type">static</span> <span class="type">srs_utime_t</span> RTC_DEFAULT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">srs_utime_t</span> DEFAULT = is_rtc? RTC_DEFAULT : SYS_DEFAULT;</span><br><span class="line"></span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;mw_latency&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = ::<span class="built_in">atoi</span>(conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (is_rtc &amp;&amp; v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">srs_warn</span>(<span class="string">&quot;For RTC, we ignore mw_latency&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">srs_utime_t</span>)(v * SRS_UTIME_MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于RTC默认是合并1个消息帧，如果开起<code>Min-Latency on</code>默认是0个消息帧，否则默认是8个消息帧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SrsConfig::get_mw_msgs</span><span class="params">(string vhost, <span class="type">bool</span> is_realtime, <span class="type">bool</span> is_rtc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">srs_getenv</span>(<span class="string">&quot;srs.vhost.play.mw_msgs&quot;</span>).<span class="built_in">empty</span>()) &#123; <span class="comment">// SRS_VHOST_PLAY_MW_MSGS</span></span><br><span class="line">        <span class="type">int</span> v = ::<span class="built_in">atoi</span>(<span class="built_in">srs_getenv</span>(<span class="string">&quot;srs.vhost.play.mw_msgs&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (v &gt; SRS_PERF_MW_MSGS) &#123;</span><br><span class="line">            <span class="built_in">srs_warn</span>(<span class="string">&quot;reset mw_msgs %d to max %d&quot;</span>, v, SRS_PERF_MW_MSGS);</span><br><span class="line">            v = SRS_PERF_MW_MSGS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> DEFAULT = SRS_PERF_MW_MIN_MSGS;</span><br><span class="line">    <span class="keyword">if</span> (is_rtc) &#123;</span><br><span class="line">        DEFAULT = SRS_PERF_MW_MIN_MSGS_FOR_RTC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_realtime) &#123;</span><br><span class="line">        DEFAULT = SRS_PERF_MW_MIN_MSGS_REALTIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;mw_msgs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = ::<span class="built_in">atoi</span>(conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (v &gt; SRS_PERF_MW_MSGS) &#123;</span><br><span class="line">        <span class="built_in">srs_warn</span>(<span class="string">&quot;reset mw_msgs %d to max %d&quot;</span>, v, SRS_PERF_MW_MSGS);</span><br><span class="line">        v = SRS_PERF_MW_MSGS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取配置-1"><a href="#读取配置-1" class="headerlink" title="读取配置"></a>读取配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtmpConn::do_playing</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SrsLiveSource* source, SrsLiveConsumer* consumer, SrsQueueRecvThread* rtrd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setup the mw config.</span></span><br><span class="line">    <span class="comment">// when mw_sleep changed, resize the socket send buffer.</span></span><br><span class="line">    mw_msgs = _srs_config-&gt;<span class="built_in">get_mw_msgs</span>(req-&gt;vhost, realtime);</span><br><span class="line">    mw_sleep = _srs_config-&gt;<span class="built_in">get_mw_sleep</span>(req-&gt;vhost);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用配置-1"><a href="#使用配置-1" class="headerlink" title="使用配置"></a>使用配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsRtmpConn::do_playing</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SrsLiveSource* source, SrsLiveConsumer* consumer, SrsQueueRecvThread* rtrd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setup the mw config.</span></span><br><span class="line">    <span class="comment">// when mw_sleep changed, resize the socket send buffer.</span></span><br><span class="line">    mw_msgs = _srs_config-&gt;<span class="built_in">get_mw_msgs</span>(req-&gt;vhost, realtime);</span><br><span class="line">    mw_sleep = _srs_config-&gt;<span class="built_in">get_mw_sleep</span>(req-&gt;vhost);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    consumer-&gt;<span class="built_in">wait</span>(mw_msgs, mw_sleep);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要同时满足合并写的最小消息数量和	最小时长，才通知写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SrsLiveConsumer::wait</span><span class="params">(<span class="type">int</span> nb_msgs, <span class="type">srs_utime_t</span> msgs_duration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (paused) &#123;</span><br><span class="line">        <span class="built_in">srs_usleep</span>(SRS_CONSTS_RTMP_PULSE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mw_min_msgs = nb_msgs;</span><br><span class="line">    mw_duration = msgs_duration;</span><br><span class="line">    </span><br><span class="line">    <span class="type">srs_utime_t</span> duration = queue-&gt;<span class="built_in">duration</span>();</span><br><span class="line">    <span class="type">bool</span> match_min_msgs = queue-&gt;<span class="built_in">size</span>() &gt; mw_min_msgs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// when duration ok, signal to flush.</span></span><br><span class="line">    <span class="keyword">if</span> (match_min_msgs &amp;&amp; duration &gt; mw_duration) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the enqueue will notify this cond.</span></span><br><span class="line">    mw_waiting = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use cond block wait for high performance mode.</span></span><br><span class="line">    <span class="built_in">srs_cond_wait</span>(mw_wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>mw_waiting</code>变量判断，通过<code>srs_cond_signal</code>通知拉流端获取数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsLiveConsumer::enqueue</span><span class="params">(SrsSharedPtrMessage* shared_msg, <span class="type">bool</span> atc, SrsRtmpJitterAlgorithm ag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_PERF_QUEUE_COND_WAIT</span></span><br><span class="line">    <span class="comment">// fire the mw when msgs is enough.</span></span><br><span class="line">    <span class="keyword">if</span> (mw_waiting) &#123;</span><br><span class="line">        <span class="comment">// For RTMP, we wait for messages and duration.</span></span><br><span class="line">        <span class="type">srs_utime_t</span> duration = queue-&gt;<span class="built_in">duration</span>();</span><br><span class="line">        <span class="type">bool</span> match_min_msgs = queue-&gt;<span class="built_in">size</span>() &gt; mw_min_msgs;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For ATC, maybe the SH timestamp bigger than A/V packet,</span></span><br><span class="line">        <span class="comment">// when encoder republish or overflow.</span></span><br><span class="line">        <span class="comment">// @see https://github.com/ossrs/srs/pull/749</span></span><br><span class="line">        <span class="keyword">if</span> (atc &amp;&amp; duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">srs_cond_signal</span>(mw_wait);</span><br><span class="line">            mw_waiting = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// when duration ok, signal to flush.</span></span><br><span class="line">        <span class="keyword">if</span> (match_min_msgs &amp;&amp; duration &gt; mw_duration) &#123;</span><br><span class="line">            <span class="built_in">srs_cond_signal</span>(mw_wait);</span><br><span class="line">            mw_waiting = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Queue-Length"><a href="#Queue-Length" class="headerlink" title="Queue Length"></a>Queue Length</h1><h2 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h2><p>SRS可以配置直播队列的长度，服务器会将数据放在直播队列中，如果超过这个长度就清空到最后一个I帧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># the max live queue length in seconds.</span><br><span class="line"># if the messages in the queue exceed the max length, </span><br><span class="line"># drop the old whole gop.</span><br><span class="line"># default: 30</span><br><span class="line">queue_length    10; #单位是秒</span><br></pre></td></tr></table></figure>

<p>当然这个不能配置太小，譬如GOP是1秒，queue_length是1秒，这样会导致有1秒数据就清空，会导致跳跃。</p>
<p>有更好的方法？有的。延迟基本上就等于客户端的缓冲区长度，因为延迟大多由于网络带宽低，服务器缓存后一起发给客户端，现象就是客户端的缓冲区变大了，譬如NetStream.BufferLength&#x3D;5秒，那么说明缓冲区中至少有5秒数据。</p>
<p>处理累积延迟的最好方法，是客户端检测到缓冲区有很多数据了，如果可以的话，就重连服务器。当然如果网络一直不好，那就没有办法了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><h3 id="读取配置-2"><a href="#读取配置-2" class="headerlink" title="读取配置"></a>读取配置</h3><p>默认是30秒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_utime_t</span> <span class="title">SrsConfig::get_queue_length</span><span class="params">(string vhost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SRS_OVERWRITE_BY_ENV_SECONDS</span>(<span class="string">&quot;srs.vhost.play.queue_length&quot;</span>); <span class="comment">// SRS_VHOST_PLAY_QUEUE_LENGTH</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">srs_utime_t</span> DEFAULT = SRS_PERF_PLAY_QUEUE;</span><br><span class="line">    </span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;queue_length&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">srs_utime_t</span>(::<span class="built_in">atoi</span>(conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">c_str</span>()) * SRS_UTIME_SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用配置-2"><a href="#使用配置-2" class="headerlink" title="使用配置"></a>使用配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsMessageQueue::enqueue</span><span class="params">(SrsSharedPtrMessage* msg, <span class="type">bool</span>* is_overflow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line"></span><br><span class="line">    msgs.<span class="built_in">push_back</span>(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If jitter is off, the timestamp of first sequence header is zero, which wll cause SRS to shrink and drop the</span></span><br><span class="line">    <span class="comment">// keyframes even if there is not overflow packets in queue, so we must ignore the zero timestamps, please</span></span><br><span class="line">    <span class="comment">// @see https://github.com/ossrs/srs/pull/2186#issuecomment-953383063</span></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;<span class="built_in">is_av</span>() &amp;&amp; msg-&gt;timestamp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (av_start_time == <span class="number">-1</span>) &#123;</span><br><span class="line">            av_start_time = <span class="built_in">srs_utime_t</span>(msg-&gt;timestamp * SRS_UTIME_MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        av_end_time = <span class="built_in">srs_utime_t</span>(msg-&gt;timestamp * SRS_UTIME_MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (av_end_time - av_start_time &gt; max_queue_size) &#123;</span><br><span class="line">        <span class="comment">// notice the caller queue already overflow and shrinked.</span></span><br><span class="line">        <span class="keyword">if</span> (is_overflow) &#123;</span><br><span class="line">            *is_overflow = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">shrink</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GOP-Cache"><a href="#GOP-Cache" class="headerlink" title="GOP-Cache"></a>GOP-Cache</h1><h2 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h2><p>GOP有什么影响？Flash（解码器）只有拿到GOP才能开始解码播放。也就是说，服务器一般先给一个I帧给Flash。可惜问题来了，假设GOP是10秒，也就是每隔10秒才有关键帧，如果用户在第5秒时开始播放，会怎么样？</p>
<p>第一种方案：等待下一个I帧，也就是说，再等5秒才开始给客户端数据。这样延迟就很低了，总是实时的流。问题是：等待的这5秒，会黑屏，现象就是播放器卡在那里，什么也没有，有些用户可能以为死掉了，就会刷新页面。总之，某些客户会认为等待关键帧是个不可饶恕的错误，延时有什么关系？我就希望能快速启动和播放视频，最好打开就能放！</p>
<p>第二种方案：马上开始放，放什么呢？你肯定知道了，放前一个I帧。也就是说，服务器需要总是cache一个gop，这样客户端上来就从前一个I帧开始播放，就可以快速启动了。问题是：延迟自然就大了。</p>
<p>有没有好的方案？有！至少有两种：</p>
<ul>
<li>编码器调低GOP，譬如0.5秒一个GOP，这样延迟也很低，也不用等待。坏处是编码器压缩率会降低，图像质量没有那么好。</li>
<li>服务器提供配置，可以选择前面两个方案之一：SRS就这么做，有个gop_cache配置项，on就会马上播放，off就低延迟。</li>
</ul>
<p>SRS的配置项：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the listen ports, split by space.</span></span><br><span class="line"><span class="attribute">listen</span>              <span class="number">1935</span>;</span><br><span class="line"><span class="attribute">vhost</span> __defaultVhost__ &#123;</span><br><span class="line">    <span class="comment"># for play client, both RTMP and other stream clients,</span></span><br><span class="line">    <span class="comment"># for instance, the HTTP FLV stream clients.</span></span><br><span class="line">    <span class="section">play</span> &#123;</span><br><span class="line">        <span class="comment"># whether cache the last gop.</span></span><br><span class="line">        <span class="comment"># if on, cache the last gop and dispatch to client,</span></span><br><span class="line">        <span class="comment">#   to enabled fast startup for client, client play immediately.</span></span><br><span class="line">        <span class="comment"># if off, send the latest media data to client,</span></span><br><span class="line">        <span class="comment">#   client need to wait for the next Iframe to decode and show the video.</span></span><br><span class="line">        <span class="comment"># set to off if requires min delay;</span></span><br><span class="line">        <span class="comment"># set to on if requires client fast startup.</span></span><br><span class="line">        <span class="comment"># default: on</span></span><br><span class="line">        <span class="attribute">gop_cache</span>       <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>默认开启gop-cache。</p>
<h3 id="读取配置-3"><a href="#读取配置-3" class="headerlink" title="读取配置"></a>读取配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SrsConfig::get_gop_cache</span><span class="params">(string vhost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SRS_OVERWRITE_BY_ENV_BOOL2</span>(<span class="string">&quot;srs.vhost.play.gop_cache&quot;</span>); <span class="comment">// SRS_VHOST_PLAY_GOP_CACHE</span></span><br><span class="line"></span><br><span class="line">    SrsConfDirective* conf = <span class="built_in">get_vhost</span>(vhost);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> SRS_PERF_GOP_CACHE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf) &#123;</span><br><span class="line">        <span class="keyword">return</span> SRS_PERF_GOP_CACHE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conf = conf-&gt;<span class="built_in">get</span>(<span class="string">&quot;gop_cache&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!conf || conf-&gt;<span class="built_in">arg0</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> SRS_PERF_GOP_CACHE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SRS_CONF_PERFER_TRUE</span>(conf-&gt;<span class="built_in">arg0</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用配置-3"><a href="#使用配置-3" class="headerlink" title="使用配置"></a>使用配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">srs_error_t</span> <span class="title">SrsGopCache::cache</span><span class="params">(SrsSharedPtrMessage* shared_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">srs_error_t</span> err = srs_success;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!enable_gop_cache) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the gop cache know when to gop it.</span></span><br><span class="line">    SrsSharedPtrMessage* msg = shared_msg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// got video, update the video count if acceptable</span></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;<span class="built_in">is_video</span>()) &#123;</span><br><span class="line">        <span class="comment">// Drop video when not h.264 or h.265.</span></span><br><span class="line">        <span class="type">bool</span> codec_ok = SrsFlvVideo::<span class="built_in">h264</span>(msg-&gt;payload, msg-&gt;size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SRS_H265</span></span><br><span class="line">        codec_ok = codec_ok ? <span class="literal">true</span> : SrsFlvVideo::<span class="built_in">hevc</span>(msg-&gt;payload, msg-&gt;size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (!codec_ok) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        cached_video_count++;</span><br><span class="line">        audio_after_last_video_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no acceptable video or pure audio, disable the cache.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pure_audio</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ok, gop cache enabled, and got an audio.</span></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;<span class="built_in">is_audio</span>()) &#123;</span><br><span class="line">        audio_after_last_video_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// clear gop cache when pure audio count overflow</span></span><br><span class="line">    <span class="keyword">if</span> (audio_after_last_video_count &gt; SRS_PURE_AUDIO_GUESS_COUNT) &#123;</span><br><span class="line">        <span class="built_in">srs_warn</span>(<span class="string">&quot;clear gop cache for guess pure audio overflow&quot;</span>);</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// clear gop cache when got key frame</span></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;<span class="built_in">is_video</span>() &amp;&amp; SrsFlvVideo::<span class="built_in">keyframe</span>(msg-&gt;payload, msg-&gt;size)) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// curent msg is video frame, so we set to 1.</span></span><br><span class="line">        cached_video_count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache the frame.</span></span><br><span class="line">    gop_cache.<span class="built_in">push_back</span>(msg-&gt;<span class="built_in">copy</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear gop cache if exceed the max frames.</span></span><br><span class="line">    <span class="keyword">if</span> (gop_cache_max_frames_ &gt; <span class="number">0</span> &amp;&amp; gop_cache.<span class="built_in">size</span>() &gt; (<span class="type">size_t</span>)gop_cache_max_frames_) &#123;</span><br><span class="line">        <span class="built_in">srs_warn</span>(<span class="string">&quot;Gop cache exceed max frames=%d, total=%d, videos=%d, aalvc=%d&quot;</span>,</span><br><span class="line">            gop_cache_max_frames_, (<span class="type">int</span>)gop_cache.<span class="built_in">size</span>(), cached_video_count, audio_after_last_video_count);</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://ossrs.net/lts/zh-cn/docs/v5/doc/low-latency#max-queue-length">https://ossrs.net/lts/zh-cn/docs/v5/doc/low-latency#max-queue-length</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fang</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
