<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fang0407.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="CGO入门本节通过一系列由浅入深的小例子来快速掌握 CGO 的基本用法。 使用标准库函数1234567891011121314package main&#x2F;*#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;*&#x2F;import &quot;C&quot;import &quot;unsafe&quot;func main() &amp;#123;    c_str">
<meta property="og:type" content="article">
<meta property="og:title" content="CGO">
<meta property="og:url" content="https://fang0407.github.io/2023/12/21/CGO/index.html">
<meta property="og:site_name" content="NOTE">
<meta property="og:description" content="CGO入门本节通过一系列由浅入深的小例子来快速掌握 CGO 的基本用法。 使用标准库函数1234567891011121314package main&#x2F;*#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;*&#x2F;import &quot;C&quot;import &quot;unsafe&quot;func main() &amp;#123;    c_str">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-12-21T11:27:03.000Z">
<meta property="article:modified_time" content="2023-12-30T14:41:14.918Z">
<meta property="article:author" content="Fang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fang0407.github.io/2023/12/21/CGO/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://fang0407.github.io/2023/12/21/CGO/","path":"2023/12/21/CGO/","title":"CGO"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CGO | NOTE</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NOTE</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CGO%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">CGO入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">使用标准库函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">使用自定义函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Go%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">使用Go重新实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91C%E6%8E%A5%E5%8F%A3%E7%9A%84Go%E7%BC%96%E7%A8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">面向C接口的Go编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CGO%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">CGO基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#import-%E2%80%9CC%E2%80%9D%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.</span> <span class="nav-text">import “C”语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgo%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.2.</span> <span class="nav-text">#cgo语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#build-tag%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-number">2.3.</span> <span class="nav-text">build tag条件编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">数值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87"><span class="nav-number">3.2.</span> <span class="nav-text">字符串和切片</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go%E8%B0%83%E7%94%A8C%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">Go调用C函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.2.</span> <span class="nav-text">C函数的返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.3.</span> <span class="nav-text">void函数的返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%B0%83%E7%94%A8Go%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">C调用Go导出函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">回调函数作为参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">5.</span> <span class="nav-text">静态库和动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">5.1.</span> <span class="nav-text">使用静态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">5.2.</span> <span class="nav-text">使用动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">5.3.</span> <span class="nav-text">导出静态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">5.4.</span> <span class="nav-text">导出动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E9%9D%9Emain%E5%8C%85%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">导出非main包的函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E5%8F%82%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">编译和链接参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%EF%BC%9ACFLAGS-CPPFLAGS-CXXFLAGS"><span class="nav-number">6.1.</span> <span class="nav-text">编译参数：CFLAGS&#x2F;CPPFLAGS&#x2F;CXXFLAGS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%8F%82%E6%95%B0%EF%BC%9ALDFLAGS"><span class="nav-number">6.2.</span> <span class="nav-text">链接参数：LDFLAGS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pkg-config"><span class="nav-number">6.3.</span> <span class="nav-text">pkg-config</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-get"><span class="nav-number">6.4.</span> <span class="nav-text">go get</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/12/21/CGO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CGO | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CGO
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-21 19:27:03" itemprop="dateCreated datePublished" datetime="2023-12-21T19:27:03+08:00">2023-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:41:14" itemprop="dateModified" datetime="2023-12-30T22:41:14+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="CGO入门"><a href="#CGO入门" class="headerlink" title="CGO入门"></a>CGO入门</h1><p>本节通过一系列由浅入深的小例子来快速掌握 CGO 的基本用法。</p>
<h2 id="使用标准库函数"><a href="#使用标准库函数" class="headerlink" title="使用标准库函数"></a>使用标准库函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c_str := C.CString(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> C.free(unsafe.Pointer(c_str))</span><br><span class="line">    C.puts(c_str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 CGO 包的 <code>C.CString</code> 函数将 Go 语言字符串转为 C 语言字符串，然后调用 CGO 包的 <code>C.puts</code> 函数向标准输出窗口打印转换后的 C 字符串。</p>
<h2 id="使用自定义函数"><a href="#使用自定义函数" class="headerlink" title="使用自定义函数"></a>使用自定义函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void Hello(const char* s) &#123;</span></span><br><span class="line"><span class="comment">	puts(s);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c_str := C.CString(<span class="string">&quot;Hello, World&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> C.free(unsafe.Pointer(c_str))</span><br><span class="line">    C.Hello(c_str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>当代码语句变多时，我们可以将相似的代码封装到一个个函数中。</p>
<p>在前面的例子中，我们可以抽象一个名为 hello 的模块，模块的全部接口函数都在 hello.h 头文件定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是 Hello 函数的 C 语言实现，对应 hello.c 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在 CGO 部分需要引入头文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;hello.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c_str := C.CString(<span class="string">&quot;Hello, World&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> C.free(unsafe.Pointer(c_str))</span><br><span class="line">    C.Hello(c_str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果之前运行的命令是 <code>go run hello.go</code> 或 <code>go build hello.go</code> 的话，此处须使用 <code>go run &quot;your/package&quot;</code> 或 <code>go build &quot;your/package&quot;</code> 才可以。若本就在包路径下的话，也可以直接运行 <code>go run .</code> 或 <code>go build</code>。</p>
<p>接口文件 hello.h 是 hello 模块的实现者和使用者共同的约定，但是该约定并没有要求必须使用 C 语言来实现 Hello 函数。我们也可以用 C++ 语言来重新实现这个 C 语言函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++ 版本的 Hello 函数实现中，我们通过 C++ 特有的 <code>std::cout</code> 输出流输出字符串。不过为了保证 C++ 语言实现的 Hello 函数满足 C 语言头文件 hello.h 定义的函数规范，我们需要通过 <code>extern &quot;C&quot;</code> 语句指示该函数的链接符号遵循 C 语言的规则。</p>
<h2 id="使用Go重新实现"><a href="#使用Go重新实现" class="headerlink" title="使用Go重新实现"></a>使用Go重新实现</h2><p>其实 CGO 不仅仅用于 Go 语言中调用 C 语言函数，还可以用于导出 Go 语言函数给 C 语言函数调用。在前面的例子中，我们已经抽象一个名为 hello 的模块，模块的全部接口函数都在 hello.h 头文件定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hello</span><span class="params">(<span class="comment">/*const*/</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>现在创建一个 hello.go 文件，用 Go 语言重新实现 C 语言接口的 Hello 函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export Hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">    fmt.Println(C.GoString(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 CGO 的 <code>//export SayHello</code> 指令将 Go 语言实现的函数 <code>SayHello</code> 导出为 C 语言函数。</p>
<p>同样在 Go 代码中调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;hello.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c_str := C.CString(<span class="string">&quot;Hello, World&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> C.free(unsafe.Pointer(c_str))</span><br><span class="line">    C.Hello(c_str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向C接口的Go编程"><a href="#面向C接口的Go编程" class="headerlink" title="面向C接口的Go编程"></a>面向C接口的Go编程</h2><p>在开始的例子中，我们的全部 CGO 代码都在一个 Go 文件中。然后，通过面向 C 接口编程的技术将 Hello 分别拆分到不同的 C 文件，而 main 依然是 Go 文件。再然后，是用 Go 函数重新实现了 C 语言接口的 Hello 函数。但是对于目前的例子来说只有一个函数，要拆分到三个不同的文件确实有些繁琐了。</p>
<p>现在尝试将例子中的几个文件重新合并到一个 Go 文件。<strong>为了适配 CGO 导出的 C 语言函数，我们禁止了在函数的声明语句中的 const 修饰符</strong>。下面是合并后的成果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Hello(char* s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.Hello(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export Hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">    fmt.Print(C.GoString(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的 CGO 代码中 C 语言代码的比例已经很少了，但是我们依然可以进一步以 Go 语言的思维来提炼我们的 CGO 代码。通过分析可以发现 <code>SayHello</code> 函数的参数如果可以直接使用 Go 字符串是最直接的。在 Go1.10 中 CGO 新增加了一个 <code>_GoString_</code> 预定义的 C 语言类型，用来表示 Go 语言字符串。下面是改进后的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Hello(_GoString_ s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.Hello(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export Hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看起来全部是 Go 语言代码，但是执行的时候是先从 Go 语言的 <code>main</code> 函数，到 CGO 自动生成的 C 语言版本 <code>SayHello</code> 桥接函数，最后又回到了 Go 语言环境的 <code>SayHello</code> 函数。</p>
<h1 id="CGO基础"><a href="#CGO基础" class="headerlink" title="CGO基础"></a>CGO基础</h1><p>要使用 CGO 特性，需要安装 C&#x2F;C++ 构建工具链，在 macOS 和 Linux 下是要安装 GCC，在 windows 下是需要安装 MinGW 工具。同时需要保证环境变量 <code>CGO_ENABLED</code> 被设置为 1，这表示 CGO 是被启用的状态。在本地构建时 <code>CGO_ENABLED</code> 默认是启用的，当交叉构建时 CGO 默认是禁止的。比如要交叉构建 ARM 环境运行的 Go 程序，需要手工设置好 C&#x2F;C++ 交叉构建的工具链，同时开启 <code>CGO_ENABLED</code> 环境变量。然后通过 <code>import &quot;C&quot;</code> 语句启用 CGO 特性。</p>
<h2 id="import-“C”语句"><a href="#import-“C”语句" class="headerlink" title="import “C”语句"></a>import “C”语句</h2><p>如果在 Go 代码中出现了 <code>import &quot;C&quot;</code> 语句则表示使用了 CGO 特性，紧跟在这行语句前面的注释是一种特殊语法，里面包含的是正常的 C 语言代码。当确保 CGO 启用的情况下，还可以在当前目录中包含 C&#x2F;C++ 对应的源文件。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void printint(int v) &#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;printint: %d\n&quot;, v);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="number">42</span></span><br><span class="line">    C.printint(C.<span class="type">int</span>(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>开头的注释中写了要调用的 C 函数和相关的头文件，头文件被 include 之后里面的所有的 C 语言元素都会被加入到”C” 这个虚拟的包中。</p>
</li>
<li><p>import “C” 导入语句推荐单独一行，不与其他包一同 import（在 Go 早期版本中必须单独 import）。</p>
</li>
<li><p>Go 是强类型语言，所以 cgo 中传递的参数类型必须与声明的类型完全一致，而且传递前必须用”C” 中的转化函数转换成对应的 C 类型，不能直接传入 Go 中类型的变量。</p>
</li>
<li><p>通过虚拟的 C 包导入的 C 语言符号并不需要是大写字母开头，它们不受 Go 语言的导出规则约束。</p>
</li>
</ul>
<p>注意：cgo 将当前包引用的 C 语言符号都放到了虚拟的 C 包中，同时当前包依赖的其它 Go 语言包内部可能也通过 cgo 引入了相似的虚拟 C 包，<strong>但是不同的 Go 语言包引入的虚拟的 C 包之间的类型是不能通用的</strong>。</p>
<h2 id="cgo语句"><a href="#cgo语句" class="headerlink" title="#cgo语句"></a>#cgo语句</h2><p>在 <code>import &quot;C&quot;</code> 语句前的注释中可以通过 <code>#cgo</code> 语句设置编译阶段和链接阶段的相关参数。编译阶段的参数主要用于定义相关宏和指定头文件检索路径。链接阶段的参数主要是指定库文件检索路径和要链接的库文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #cgo CFLAGS: -DPNG_DEBUG=1 -I./include</span></span><br><span class="line"><span class="comment">// #cgo LDFLAGS: -L/usr/local/lib -lpng</span></span><br><span class="line"><span class="comment">// #include &lt;png.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，CFLAGS 部分，<code>-D</code> 部分定义了宏 PNG_DEBUG，值为 1；<code>-I</code> 定义了头文件包含的检索目录。LDFLAGS 部分，<code>-L</code> 指定了链接时库文件检索目录，<code>-l</code> 指定了链接时需要链接 png 库。</p>
<p>因为 C&#x2F;C++ 遗留的问题，C 头文件检索目录可以是相对目录，但是库文件检索目录则需要绝对路径。在库文件的检索目录中可以通过 <code>$&#123;SRCDIR&#125;</code> 变量表示当前包目录的绝对路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// #cgo LDFLAGS: -L$&#123;SRCDIR&#125;/libs -lfoo</span><br></pre></td></tr></table></figure>

<p><code>#cgo</code> 语句主要影响 CFLAGS、CPPFLAGS、CXXFLAGS、FFLAGS 和 LDFLAGS 几个编译器环境变量。LDFLAGS 用于设置链接时的参数，除此之外的几个变量用于改变编译阶段的构建参数 (CFLAGS 用于针对 C 语言代码设置编译参数)。</p>
<p>对于在 cgo 环境混合使用 C 和 C++ 的用户来说，可能有三种不同的编译选项：其中 CFLAGS 对应 C 语言特有的编译选项、CXXFLAGS 对应是 C++ 特有的编译选项、CPPFLAGS 则对应 C 和 C++ 共有的编译选项。但是在链接阶段，C 和 C++ 的链接选项是通用的，因此这个时候已经不再有 C 和 C++ 语言的区别，它们的目标文件的类型是相同的。</p>
<p><code>#cgo</code> 指令还支持条件选择，当满足某个操作系统或某个 CPU 架构类型时后面的编译或链接选项生效。比如下面是分别针对 windows 和非 windows 下平台的编译和链接选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// #cgo windows CFLAGS: -DX86=1</span><br><span class="line">// #cgo !windows LDFLAGS: -lm</span><br></pre></td></tr></table></figure>

<p>其中在 windows 平台下，编译前会预定义 X86 宏为 1；在非 windows 平台下，在链接阶段会要求链接 math 数学库。这种用法对于在不同平台下只有少数编译选项差异的场景比较适用。</p>
<p>如果在不同的系统下 cgo 对应着不同的 c 代码，我们可以先使用 <code>#cgo</code> 指令定义不同的 C 语言的宏，然后通过宏来区分不同的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo windows CFLAGS: -DCGO_OS_WINDOWS=1</span></span><br><span class="line"><span class="comment">#cgo darwin CFLAGS: -DCGO_OS_DARWIN=1</span></span><br><span class="line"><span class="comment">#cgo linux CFLAGS: -DCGO_OS_LINUX=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#if defined(CGO_OS_WINDOWS)</span></span><br><span class="line"><span class="comment">    const char* os = &quot;windows&quot;;</span></span><br><span class="line"><span class="comment">#elif defined(CGO_OS_DARWIN)</span></span><br><span class="line"><span class="comment">    const char* os = &quot;darwin&quot;;</span></span><br><span class="line"><span class="comment">#elif defined(CGO_OS_LINUX)</span></span><br><span class="line"><span class="comment">    const char* os = &quot;linux&quot;;</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#   error(unknown os)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(C.GoString(C.os))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="build-tag条件编译"><a href="#build-tag条件编译" class="headerlink" title="build tag条件编译"></a>build tag条件编译</h2><p>build tag 是在 Go 或 cgo 环境下的 C&#x2F;C++ 文件开头的一种特殊的注释。条件编译类似于前面通过 <code>#cgo</code> 指令针对不同平台定义的宏，只有在对应平台的宏被定义之后才会构建对应的代码。但是通过 <code>#cgo</code> 指令定义宏有个限制，它只能是基于 Go 语言支持的 windows、darwin 和 linux 等已经支持的操作系统。如果我们希望定义一个 DEBUG 标志的宏，<code>#cgo</code> 指令就无能为力了。而 Go 语言提供的 build tag 条件编译特性则可以简单做到。</p>
<p>比如下面的源文件只有在设置 debug 构建标志时才会被构建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build debug</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">var</span> buildMode = <span class="string">&quot;debug&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以用以下命令构建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -tags=&quot;debug&quot;</span><br><span class="line">go build -tags=&quot;windows debug&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>-tags</code> 命令行参数同时指定多个 build 标志，它们之间用空格分隔。</p>
<p>当有多个 build tag 时，我们将多个标志通过逻辑操作的规则来组合使用。比如以下的构建标志表示只有在 linux&#x2F;386 或 darwin 平台下非 cgo 环境 “才进行构建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// +build linux,386 darwin,!cgo</span><br></pre></td></tr></table></figure>

<p>其中 <code>linux,386</code> 中 linux 和 386 用逗号链接表示 AND 的意思；而 <code>linux,386</code> 和 <code>darwin,!cgo</code> 之间通过空白分割来表示 OR 的意思。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>要想利用好 CGO 特性，自然需要了解此二语言类型之间的转换规则，这是本节要讨论的问题。</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><table>
<thead>
<tr>
<th>C 语言类型</th>
<th>CGO 类型</th>
<th>Go 语言类型</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>C.char</td>
<td>byte</td>
</tr>
<tr>
<td>singed char</td>
<td>C.schar</td>
<td>int8</td>
</tr>
<tr>
<td>unsigned char</td>
<td>C.uchar</td>
<td>uint8</td>
</tr>
<tr>
<td>short</td>
<td>C.short</td>
<td>int16</td>
</tr>
<tr>
<td>unsigned short</td>
<td>C.ushort</td>
<td>uint16</td>
</tr>
<tr>
<td>int</td>
<td>C.int</td>
<td>int32</td>
</tr>
<tr>
<td>unsigned int</td>
<td>C.uint</td>
<td>uint32</td>
</tr>
<tr>
<td>long</td>
<td>C.long</td>
<td>int32</td>
</tr>
<tr>
<td>unsigned long</td>
<td>C.ulong</td>
<td>uint32</td>
</tr>
<tr>
<td>long long int</td>
<td>C.longlong</td>
<td>int64</td>
</tr>
<tr>
<td>unsigned long long int</td>
<td>C.ulonglong</td>
<td>uint64</td>
</tr>
<tr>
<td>float</td>
<td>C.float</td>
<td>float32</td>
</tr>
<tr>
<td>double</td>
<td>C.double</td>
<td>float64</td>
</tr>
<tr>
<td>size_t</td>
<td>C.size_t</td>
<td>uint</td>
</tr>
</tbody></table>
<p>Go 语言类型 <code>&lt;stdint.h&gt;</code> 头文件类型对比：</p>
<table>
<thead>
<tr>
<th>C 语言类型</th>
<th>CGO 类型</th>
<th>Go 语言类型</th>
</tr>
</thead>
<tbody><tr>
<td>int8_t</td>
<td>C.int8_t</td>
<td>int8</td>
</tr>
<tr>
<td>uint8_t</td>
<td>C.uint8_t</td>
<td>uint8</td>
</tr>
<tr>
<td>int16_t</td>
<td>C.int16_t</td>
<td>int16</td>
</tr>
<tr>
<td>uint16_t</td>
<td>C.uint16_t</td>
<td>uint16</td>
</tr>
<tr>
<td>int32_t</td>
<td>C.int32_t</td>
<td>int32</td>
</tr>
<tr>
<td>uint32_t</td>
<td>C.uint32_t</td>
<td>uint32</td>
</tr>
<tr>
<td>int64_t</td>
<td>C.int64_t</td>
<td>int64</td>
</tr>
<tr>
<td>uint64_t</td>
<td>C.uint64_t</td>
<td>uint64</td>
</tr>
</tbody></table>
<p> 64 位环境下，<code>_cgo_export.h</code> 头文件生成的 Go 数值类型的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> GoInt8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> GoUint8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> GoInt16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> GoUint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> GoInt32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> GoUint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> GoInt64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> GoUint64;</span><br><span class="line"><span class="keyword">typedef</span> GoInt64 GoInt;</span><br><span class="line"><span class="keyword">typedef</span> GoUint64 GoUint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> GoFloat32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> GoFloat64;</span><br></pre></td></tr></table></figure>

<h2 id="字符串和切片"><a href="#字符串和切片" class="headerlink" title="字符串和切片"></a>字符串和切片</h2><p>在 CGO 生成的 <code>_cgo_export.h</code> 头文件中还会为 Go 语言的字符串、切片、字典、接口和管道等特有的数据类型生成对应的 C 语言类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">const</span> <span class="type">char</span> *p; GoInt n;&#125; GoString;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *GoMap;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *GoChan;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">void</span> *t; <span class="type">void</span> *v;&#125; GoInterface;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">void</span> *data; GoInt len; GoInt cap;&#125; GoSlice;</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，其中只有字符串和切片在 CGO 中有一定的使用价值，因为 CGO 为他们的某些 GO 语言版本的操作函数生成了 C 语言版本，因此二者可以在 Go 调用 C 语言函数时马上使用; 而 CGO 并未针对其他的类型提供相关的辅助函数，且 Go 语言特有的内存模型导致我们无法保持这些由 Go 语言管理的内存指针，所以它们 C 语言环境并无使用的价值。</p>
<p>在导出的 C 语言函数中我们可以直接使用 Go 字符串和切片。假设有以下两个导出函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export helloString</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloString</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export helloSlice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloSlice</span><span class="params">(s []<span class="type">byte</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>CGO 生成的 <code>_cgo_export.h</code> 头文件会包含以下的函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">helloString</span><span class="params">(GoString p0)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">helloSlice</span><span class="params">(GoSlice p0)</span>;</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，如果使用了 GoString 类型则会对 <code>_cgo_export.h</code> 头文件产生依赖，而这个头文件是动态输出的。</p>
<p>Go1.10 针对 Go 字符串增加了一个 <code>_GoString_</code> 预定义类型，可以降低在 cgo 代码中可能对 <code>_cgo_export.h</code> 头文件产生的循环依赖的风险。我们可以调整 helloString 函数的 C 语言声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">helloString</span><span class="params">(_GoString_ p0)</span>;</span><br></pre></td></tr></table></figure>

<p>因为 <code>_GoString_</code> 是预定义类型，我们无法通过此类型直接访问字符串的长度和指针等信息。Go1.10 同时也增加了以下两个函数用于获取字符串结构中的长度和指针信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _GoStringLen(_GoString_ s);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *_GoStringPtr(_GoString_ s);</span><br></pre></td></tr></table></figure>

<p>更严谨的做法是为 C 语言函数接口定义严格的头文件，然后基于稳定的头文件实现代码。</p>
<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>CGO 技术我们不仅仅可以在 Go 语言中调用 C 语言函数，也可以将 Go 语言函数导出为 C 语言函数。</p>
<h2 id="Go调用C函数"><a href="#Go调用C函数" class="headerlink" title="Go调用C函数"></a>Go调用C函数</h2><p>对于一个启用 CGO 特性的程序，CGO 会构造一个虚拟的 C 包。通过这个虚拟的 C 包可以调用 C 语言函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static int add(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">	return a+b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    C.add(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C函数的返回值"><a href="#C函数的返回值" class="headerlink" title="C函数的返回值"></a>C函数的返回值</h2><p>对于有返回值的 C 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static int div(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">	return a/b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := C.div(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void函数的返回值"><a href="#void函数的返回值" class="headerlink" title="void函数的返回值"></a>void函数的返回值</h2><p>C 语言函数还有一种没有返回值类型的函数，用 void 表示返回值类型。一般情况下，我们无法获取 void 类型函数的返回值，因为没有返回值可以获取。前面的例子中提到，cgo 对 errno 做了特殊处理，可以通过第二个返回值来获取 C 语言的错误状态。对于 void 类型函数，这个特性依然有效。</p>
<p>以下的代码是获取没有返回值函数的错误状态码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void noreturn() &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, err := C.noreturn()</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们忽略了第一个返回值，只获取第二个返回值对应的错误码。</p>
<p>我们也可以尝试获取第一个返回值，它对应的是 C 语言的 void 对应的 Go 语言类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void noreturn() &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v, _ := C.noreturn()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个代码将会产生以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main._Ctype_void&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看出 C 语言的 void 类型对应的是当前的 main 包中的 <code>_Ctype_void</code> 类型。其实也将 C 语言的 noreturn 函数看作是返回 <code>_Ctype_void</code> 类型的函数，这样就可以直接获取 void 类型函数的返回值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void noreturn() &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(C.noreturn())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个代码将会产生以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>其实在 CGO 生成的代码中，<code>_Ctype_void</code> 类型对应一个 0 长的数组类型 <code>[0]byte</code>，因此 <code>fmt.Println</code> 输出的是一个表示空数值的方括弧。</p>
<h2 id="C调用Go导出函数"><a href="#C调用Go导出函数" class="headerlink" title="C调用Go导出函数"></a>C调用Go导出函数</h2><p>将 Go 函数导出为 C 语言函数。这样的话我们可以定义好 C 语言接口，然后通过 Go 语言实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export add</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 函数名以小写字母开头，对于 Go 语言来说是包内的私有函数。但是从 C 语言角度来看，导出的 add 函数是一个可全局访问的 C 语言函数。如果在两个不同的 Go 语言包内，都存在一个同名的要导出为 C 语言函数的 add 函数，那么在最终的链接阶段将会出现符号重名的问题。</p>
<p>当导出 C 语言接口时，<strong>需要保证函数的参数和返回值类型都是 C 语言友好的类型</strong>，同时<strong>返回值不得直接或间接包含 Go 语言内存空间的指针</strong>。</p>
<h2 id="回调函数作为参数"><a href="#回调函数作为参数" class="headerlink" title="回调函数作为参数"></a>回调函数作为参数</h2><p>回调函数作为参数也是很常见的使用场景，通常用于异步处理数据。</p>
<p>创建 <code>process.h</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PROCESS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PROCESS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*CallbackFuncCpp)</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, CallbackFuncCpp callback)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>创建 <code>process.cpp</code> 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;process.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据处理过程</span></span><br><span class="line"><span class="function">std::string <span class="title">processData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Processed: &quot;</span> + std::<span class="built_in">string</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受回调函数作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, CallbackFuncCpp callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">    std::string result = <span class="built_in">processData</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="built_in">callback</span>(result.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>prcess</code> 函数带有回调函数，创建 <code>main.go</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;process.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export CallbackFuncGo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallbackFuncGo</span><span class="params">(result *C.char)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Callback called:&quot;</span>, C.GoString(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cb := C.CallbackFuncCpp(unsafe.Pointer(C.CallbackFuncGo))</span><br><span class="line">    C.process(C.CString(<span class="string">&quot;Input Data&quot;</span>), cb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码是编译不过去的，因为在 <code>main.go</code> 中并不认识 <code>CallbackFuncGo</code>。</p>
<p>要使其编译过需要创建 <code>go_export.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export CallbackFuncGo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallbackFuncGo</span><span class="params">(result *C.char)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Callback called:&quot;</span>, C.GoString(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>main.go</code> 修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;process.h&quot;</span></span><br><span class="line"><span class="comment">void CallbackFuncGo(const char* result);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cb := C.CallbackFuncCpp(unsafe.Pointer(C.CallbackFuncGo))</span><br><span class="line">    C.process(C.CString(<span class="string">&quot;Input Data&quot;</span>), cb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到修改后独立出了 Go 导出函数，以及增加了该函数的声明。</p>
<p>有时候我们希望 Go 导出函数和 <code>main.go</code> 放在一起，此时需要创建 <code>bridge.go</code> 文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void CallbackFuncGo(const char* result);</span></span><br><span class="line"><span class="comment">void Bridge(const char* result)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    CallbackFuncGo(result);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为在 <code>main.go</code> 中无法直接调用 <code>CallbackFuncGo</code> 所以需要创建桥接函数间接调用。</p>
<p>同时在 <code>main.go</code> 中导出 <code>CallbackFuncGo</code> ，并且调用时使用 <code>Bridge</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &quot;process.h&quot;</span></span><br><span class="line"><span class="comment">void Bridge(const char* result);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//export CallbackFuncGo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallbackFuncGo</span><span class="params">(result *C.char)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Callback called:&quot;</span>, C.GoString(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cb := C.CallbackFuncCpp(unsafe.Pointer(C.Bridge))</span><br><span class="line">    C.process(C.CString(<span class="string">&quot;Input Data&quot;</span>), cb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><p>CGO 在使用 C&#x2F;C++ 资源的时候一般有三种形式：直接使用源码；链接静态库；链接动态库。直接使用源码就是在 <code>import &quot;C&quot;</code> 之前的注释部分包含 C 代码，或者在当前包中包含 C&#x2F;C++ 源文件。链接静态库和动态库的方式比较类似，都是通过在 LDFLAGS 选项指定要链接的库方式链接。</p>
<h2 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h2><p>静态库因为是静态链接，最终的目标程序并不会产生额外的运行时依赖，也不会出现动态库特有的跨运行时资源管理的错误。不过静态库对链接阶段会有一定要求：静态库一般包含了全部的代码，里面会有大量的符号，如果不同静态库之间出现了符号冲突则会导致链接的失败。</p>
<p>使用静态库例子，先用纯 C 语言构造一个简单的静态库。我们要构造的静态库名叫 number，库中只有一个 number_add_mod 函数，用于表示数论中的模加法运算。number 库的文件都在 number 目录下。</p>
<p><code>number/number.h</code> 头文件只有一个纯 C 语言风格的函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">number_add_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span>;</span><br></pre></td></tr></table></figure>

<p><code>number/number.c</code> 对应函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;number.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">number_add_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 CGO 使用的是 GCC 命令来编译和链接 C 和 Go 桥接的代码。因此静态库也必须是 GCC 兼容的格式。</p>
<p>通过以下命令可以生成一个叫 libnumber.a 的静态库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ./number</span><br><span class="line">gcc -c -o number.o number.c</span><br><span class="line">ar rcs libnumber.a number.o</span><br></pre></td></tr></table></figure>

<p>生成 libnumber.a 静态库之后，我们就可以在 CGO 中使用该资源了。</p>
<p>创建 main.go 文件如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#cgo CFLAGS: -I./number</span></span><br><span class="line"><span class="comment">//#cgo LDFLAGS: -L$&#123;SRCDIR&#125;/number -lnumber</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//#include &quot;number.h&quot;</span></span><br><span class="line">import <span class="string">&quot;C&quot;</span></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fmt.Println(C.number_add_mod(<span class="number">10</span>, <span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h2><p>动态库出现的初衷是对于相同的库，多个进程可以共享同一个，以节省内存和磁盘资源。但是在磁盘和内存已经白菜价的今天，这两个作用已经显得微不足道了，那么除此之外动态库还有哪些存在的价值呢？从库开发角度来说，动态库可以隔离不同动态库之间的关系，减少链接时出现符号冲突的风险。而且对于 windows 等平台，动态库是跨越 VC 和 GCC 不同编译器平台的唯一的可行方式。</p>
<p>对于 CGO 来说，使用动态库和静态库是一样的，因为动态库也必须要有一个小的静态导出库用于链接动态库（Linux 下可以直接链接 so 文件，但是在 Windows 下必须为 dll 创建一个 <code>.a</code> 文件用于链接）。我们还是以前面的 number 库为例来说明如何以动态库方式使用。</p>
<p>对于在 macOS 和 Linux 系统下的 gcc 环境，我们可以用以下命令创建 number 库的的动态库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd number</span><br><span class="line">gcc -shared -o libnumber.so number.c</span><br></pre></td></tr></table></figure>

<p>因为动态库和静态库的基础名称都是 libnumber，只是后缀名不同而已。因此 Go 语言部分的代码和静态库版本完全一样。</p>
<p>编译时 GCC 会自动找到 libnumber.a 或 libnumber.so 进行链接。</p>
<h2 id="导出静态库"><a href="#导出静态库" class="headerlink" title="导出静态库"></a>导出静态库</h2><p>CGO 不仅可以使用 C 静态库，也可以将 Go 实现的函数导出为 C 静态库。我们现在用 Go 实现前面的 number 库的模加法函数。</p>
<p>创建 number.go，内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export number_add_mod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number_add_mod</span><span class="params">(a, b, mod C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) % mod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 CGO 文档的要求，我们需要<strong>在 main 包中导出 C 函数</strong>。对于 C 静态库构建方式来说，会忽略 main 包中的 main 函数，只是简单导出 C 函数。采用以下命令构建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=c-archive -o number.a</span><br></pre></td></tr></table></figure>

<p>在生成 number.a 静态库的同时，cgo 还会生成一个 number.h 文件。</p>
<p>number.h 文件的内容如下（为了便于显示，内容做了精简）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">number_add_mod</span><span class="params">(<span class="type">int</span> p0, <span class="type">int</span> p1, <span class="type">int</span> p2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="导出动态库"><a href="#导出动态库" class="headerlink" title="导出动态库"></a>导出动态库</h2><p>CGO 导出动态库的过程和静态库类似，只是将构建模式改为 <code>c-shared</code>，输出文件名改为 <code>number.so</code> 而已：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -buildmode=c-shared -o number.so</span><br></pre></td></tr></table></figure>

<h2 id="导出非main包的函数"><a href="#导出非main包的函数" class="headerlink" title="导出非main包的函数"></a>导出非main包的函数</h2><p>通过 <code>go help buildmode</code> 命令可以查看 C 静态库和 C 动态库的构建说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-buildmode=c-archive</span><br><span class="line">    Build the listed main package, plus all packages it imports,</span><br><span class="line">    into a C archive file. The only callable symbols will be those</span><br><span class="line">    functions exported using a cgo //export comment. Requires</span><br><span class="line">    exactly one main package to be listed.</span><br><span class="line"></span><br><span class="line">-buildmode=c-shared</span><br><span class="line">    Build the listed main package, plus all packages it imports,</span><br><span class="line">    into a C shared library. The only callable symbols will</span><br><span class="line">    be those functions exported using a cgo //export comment.</span><br><span class="line">    Requires exactly one main package to be listed.</span><br></pre></td></tr></table></figure>

<p>文档说明<strong>导出的 C 函数必须是在 main 包导出</strong>，然后才能在生成的头文件包含声明的语句。但是很多时候我们可能更希望将不同类型的导出函数组织到不同的 Go 包中，然后统一导出为一个静态库或动态库。</p>
<p>要实现从是从非 main 包导出 C 函数，或者是多个包导出 C 函数（因为只能有一个 main 包），<strong>我们需要自己提供导出 C 函数对应的头文件</strong>（因为 CGO 无法为非 main 包的导出函数生成头文件）。</p>
<p>假设我们先创建一个 number 子包，用于提供模加法函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> number</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export number_add_mod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number_add_mod</span><span class="params">(a, b, mod C.<span class="type">int</span>)</span></span> C.<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) % mod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是当前的 main 包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    _ <span class="string">&quot;./number&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export goPrintln</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goPrintln</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;goPrintln:&quot;</span>, C.GoString(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们导入了 number 子包，在 number 子包中有导出的 C 函数 number_add_mod，同时我们在 main 包也导出了 goPrintln 函数。</p>
<p>通过以下命令创建 C 静态库：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -buildmode=c-archive -o main.a</span><br></pre></td></tr></table></figure>

<p>这时候在生成 main.a 静态库的同时，也会生成一个 main.h 头文件。<strong>但是 main.h 头文件中只有 main 包中导出的 goPrintln 函数的声明</strong>，<strong>并没有 number 子包导出函数的声明</strong>。其实 number_add_mod 函数在生成的 C 静态库中是存在的，我们可以直接使用。<strong>但是对于头文件要自己添加number 子包导出函数的声明</strong>。</p>
<h1 id="编译和链接参数"><a href="#编译和链接参数" class="headerlink" title="编译和链接参数"></a>编译和链接参数</h1><p>构建每一个 C&#x2F;C++ 应用均需要经过编译和链接两个步骤，CGO 也是如此。</p>
<h2 id="编译参数：CFLAGS-CPPFLAGS-CXXFLAGS"><a href="#编译参数：CFLAGS-CPPFLAGS-CXXFLAGS" class="headerlink" title="编译参数：CFLAGS&#x2F;CPPFLAGS&#x2F;CXXFLAGS"></a>编译参数：CFLAGS&#x2F;CPPFLAGS&#x2F;CXXFLAGS</h2><p>编译参数主要是头文件的检索路径，预定义的宏等参数。</p>
<p>CFLAGS 对应 C 语言编译参数（以 <code>.c</code> 后缀名）。</p>
<p>CPPFLAGS 对应 C&#x2F;C++ 代码编译参数（<code>.c,.cc,.cpp,.cxx</code>）。</p>
<p>CXXFLAGS 对应纯 C++ 编译参数（<code>.cc,.cpp,.cxx</code>）。</p>
<h2 id="链接参数：LDFLAGS"><a href="#链接参数：LDFLAGS" class="headerlink" title="链接参数：LDFLAGS"></a>链接参数：LDFLAGS</h2><p>链接参数主要包含要链接库的检索目录和要链接库的名字。</p>
<p>因为历史遗留问题，链接库不支持相对路径，我们必须为链接库指定绝对路径。</p>
<p>cgo 中的 ${SRCDIR} 为当前目录的绝对路径。</p>
<p>经过编译后的 C 和 C++ 目标文件格式是一样的，因此 LDFLAGS 对应 C&#x2F;C++ 共同的链接参数。</p>
<h2 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h2><p>为不同 C&#x2F;C++ 库提供编译和链接参数是一项非常繁琐的工作，因此 cgo 提供了对应 <code>pkg-config</code> 工具的支持。 我们可以通过 <code>#cgo pkg-config xxx</code> 命令来生成 xxx 库需要的编译和链接参数，其底层通过调用 <code>pkg-config xxx --cflags</code> 生成编译参数，通过 <code>pkg-config xxx --libs</code> 命令生成链接参数。 需要注意的是 <code>pkg-config</code> 工具生成的编译和链接参数是 C&#x2F;C++ 公用的，无法做更细的区分。</p>
<p><code>pkg-config</code> 工具虽然方便，但是有很多非标准的 C&#x2F;C++ 库并没有实现对其支持。 这时候我们可以手工为 <code>pkg-config</code> 工具创建对应库的编译和链接参数实现支持。</p>
<h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><p>在使用 <code>go get</code> 获取 Go 语言包的同时会获取包依赖的包。比如 A 包依赖 B 包，B 包依赖 C 包，C 包依赖 D 包： <code>pkgA -&gt; pkgB -&gt; pkgC -&gt; pkgD -&gt; ...</code>。再 go get 获取 A 包之后会依次线获取 BCD 包。 如果在获取 B 包之后构建失败，那么将导致链条的断裂，从而导致 A 包的构建失败。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://github.com/chai2010/advanced-go-programming-book/tree/master/ch2-cgo">https://github.com/chai2010/advanced-go-programming-book/tree/master/ch2-cgo</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/10/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="prev" title="MySQL基础篇">
                  <i class="fa fa-angle-left"></i> MySQL基础篇
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/24/Go-HTTP%E7%9A%84Swagger%E5%AE%9E%E7%8E%B0/" rel="next" title="Go HTTP的Swagger实现">
                  Go HTTP的Swagger实现 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fang</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
