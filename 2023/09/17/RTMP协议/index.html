<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fang0407.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_39399492&#x2F;article&#x2F;details&#x2F;128069969 协议概述 RTMP官方文档：https:&#x2F;&#x2F;rtmp.veriskope.com&#x2F;pdf&#x2F;rtmp_specification_1.0.pdf  RTMP协议是Real Time Message Protocol（实时信息传输协议）的缩写。它是由Adobe公司提">
<meta property="og:type" content="article">
<meta property="og:title" content="RTMP协议">
<meta property="og:url" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="NOTE">
<meta property="og:description" content="原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_39399492&#x2F;article&#x2F;details&#x2F;128069969 协议概述 RTMP官方文档：https:&#x2F;&#x2F;rtmp.veriskope.com&#x2F;pdf&#x2F;rtmp_specification_1.0.pdf  RTMP协议是Real Time Message Protocol（实时信息传输协议）的缩写。它是由Adobe公司提">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=0.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=1.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=2.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=3.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk%E5%92%8Cmessage%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP%E8%AE%BE%E7%BD%AE%E5%9D%97%E5%A4%A7%E5%B0%8F.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP%E5%BA%94%E7%AD%94%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP%E8%AE%BE%E7%BD%AE%E6%B5%81%E5%B8%A6%E5%AE%BD.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-connect%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-connect%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-createStream%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-createStream%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-play%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-publish%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-%E9%9F%B3%E9%A2%91%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-%E8%A7%86%E9%A2%91%E6%B6%88%E6%81%AF.png">
<meta property="og:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-%E8%81%9A%E5%90%88%E6%B6%88%E6%81%AF.png">
<meta property="article:published_time" content="2023-09-17T06:59:55.000Z">
<meta property="article:modified_time" content="2023-12-30T14:38:19.732Z">
<meta property="article:author" content="Fang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP%E6%8F%A1%E6%89%8B.png">


<link rel="canonical" href="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/","path":"2023/09/17/RTMP协议/","title":"RTMP协议"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RTMP协议 | NOTE</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NOTE</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">协议概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%A1%E6%89%8B"><span class="nav-number">2.</span> <span class="nav-text">握手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%8F%A1%E6%89%8B"><span class="nav-number">2.1.</span> <span class="nav-text">简单握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E6%8F%A1%E6%89%8B"><span class="nav-number">2.2.</span> <span class="nav-text">复杂握手</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RTMP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">RTMP消息格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Message"><span class="nav-number">3.1.</span> <span class="nav-text">Message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chunk"><span class="nav-number">3.2.</span> <span class="nav-text">Chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Header"><span class="nav-number">3.2.1.</span> <span class="nav-text">Basic Header</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Message-Header"><span class="nav-number">3.2.2.</span> <span class="nav-text">Message Header</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message%E5%92%8CChunk%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="nav-number">3.3.</span> <span class="nav-text">Message和Chunk之间关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RTMP%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">RTMP消息类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF"><span class="nav-number">4.1.</span> <span class="nav-text">协议控制消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%9D%97%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">设置块大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%AD%94%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">应答窗口大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%AD%94%E6%B6%88%E6%81%AF"><span class="nav-number">4.1.3.</span> <span class="nav-text">应答消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%B5%81%E5%B8%A6%E5%AE%BD"><span class="nav-number">4.1.4.</span> <span class="nav-text">设置流带宽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%B6%88%E6%81%AF"><span class="nav-number">4.1.5.</span> <span class="nav-text">中断消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%B6%88%E6%81%AF"><span class="nav-number">4.2.</span> <span class="nav-text">命令消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.1.</span> <span class="nav-text">网络连接命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%81"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">创建流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%91%BD%E4%BB%A4"><span class="nav-number">4.2.2.</span> <span class="nav-text">网络流命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%AD%E6%94%BE"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">播放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%AD%E6%94%BE2"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">播放2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%B5%81"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">删除流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E9%9F%B3%E9%A2%91"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">接收音频</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E8%A7%86%E9%A2%91"><span class="nav-number">4.2.2.5.</span> <span class="nav-text">接收视频</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%B8%83"><span class="nav-number">4.2.2.6.</span> <span class="nav-text">发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D"><span class="nav-number">4.2.2.7.</span> <span class="nav-text">定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E5%81%9C"><span class="nav-number">4.2.2.8.</span> <span class="nav-text">暂停</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF"><span class="nav-number">4.2.3.</span> <span class="nav-text">数据消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%B6%88%E6%81%AF"><span class="nav-number">4.2.4.</span> <span class="nav-text">共享消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF"><span class="nav-number">4.2.5.</span> <span class="nav-text">音视频信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%B6%88%E6%81%AF"><span class="nav-number">4.2.6.</span> <span class="nav-text">聚合消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF"><span class="nav-number">4.2.7.</span> <span class="nav-text">用户控制消息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#QA"><span class="nav-number">5.</span> <span class="nav-text">QA</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RTMP协议 | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RTMP协议
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-17 14:59:55" itemprop="dateCreated datePublished" datetime="2023-09-17T14:59:55+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:38:19" itemprop="dateModified" datetime="2023-12-30T22:38:19+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Protocol/" itemprop="url" rel="index"><span itemprop="name">Protocol</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39399492/article/details/128069969">https://blog.csdn.net/weixin_39399492/article/details/128069969</a></p>
<h1 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h1><ul>
<li><p>RTMP官方文档：<a target="_blank" rel="noopener" href="https://rtmp.veriskope.com/pdf/rtmp_specification_1.0.pdf">https://rtmp.veriskope.com/pdf/rtmp_specification_1.0.pdf</a></p>
</li>
<li><p>RTMP协议是Real Time Message Protocol（实时信息传输协议）的缩写。它是由Adobe公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题。</p>
</li>
<li><p>RTMP的三个分支：</p>
<ul>
<li>第一种是工作在<strong>TCP协议上</strong>的明文传输，它使用的<strong>端口是1935</strong>。</li>
<li>第二种是RTMPT，RTMPT被封装在HTTP请求之中，可以穿越防火墙进行传输。</li>
<li>第三种是RTMPS，它也是封装在HTTP之中，不过与RTMPT不同的是，它使用HTTPS安全连接，可以保证传输的安全。</li>
</ul>
</li>
<li><p>RTMP协议是要靠底层可靠的传输层协议（通常是TCP）来保证信息传输的可靠性的，默认使用端口1935。</p>
<ul>
<li>在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接。</li>
<li>RTMP Connection成功后会传输一些控制信息，如CreateStream命令会创建一个Stream链接，用于传输具体的音视频数据和控制这些信息传输的命令信息。</li>
</ul>
</li>
<li><p>RTMP协议中<strong>基本的数据单元称为消息</strong>（Message），即封装、解封装都是以Message为单位进行操作。</p>
</li>
<li><p>当RTMP协议在互联网中传输数据的时候，为了更好地实现多路复用、分包和信息的公平性，<strong>发送端会把Message划分为带有Message ID的Chunk</strong>，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据chunk中包含的data的长度，message id和message的长度把chunk<strong>还原成完整的Message</strong>，从而实现信息的收发。</p>
</li>
<li><p>多路复用，RTMP可以将来自不同视频流的切片（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=chunk&spm=1001.2101.3001.7020">chunk</a>）在单个连接上传输，这种方法被称为“多路复用”。</p>
</li>
</ul>
<h1 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h1><ul>
<li>一个 RTMP 连接以握手（Handshake）开始。先进行TCP握手后再进行RTMP握手。RTMP 握手由三个固定长度的块组成，有<strong>简单握手</strong>和<strong>复杂握手</strong>两种方式，<strong>两种握手方式信息流转的过程是相同的</strong>，<strong>只是消息中携带的信息不同</strong>。</li>
<li><strong>握手实质上起到的是验证的作用</strong>，其中一项是会校验服务器，客户端的rtmp版本，如果版本兼容则可以收发数据，如果版本不兼容则说明不能收发数据，则握手会失败。</li>
<li>rtmp握手成功之后才会有rtmp header、rtmp body出现。握手的过程中不会有这些标识出现，因为此时rtmp还没有建立链接。</li>
<li>无论推流（直播）还是拉流（观看），都是客户端向服务端发起握手请求。第一条握手消息是客户端发送的。</li>
<li>客户端向服务端按序发送C0，C1，C2（按序）3个chunk，服务端向客户端按序发送S0，S1，S2（按序）3个chunk，然后才能进行有效信息的传输。RTMP协议并没有规定这6个Message的具体传输顺序，但需要保证以下几点：（简单握手和复杂握手均是如此）：<ul>
<li>客户端要等收到S1之后才能发送C2</li>
<li>客户端要等收到S2之后才能发送其他信息（控制信息和真实音视频等数据）</li>
<li>服务端要等到收到C0之后发送S1</li>
<li>服务端必须等到收到C1之后才能发送S2</li>
<li>服务端必须等到收到C2之后才能发送其他信息（控制信息和真实音视频等数据）</li>
</ul>
</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP握手.png" alt="RTMP握手" style="zoom:50%;">

<p>理论上来讲只要满足以上条件，如何安排6个Message的顺序都是可以的，但实际实现中为了在保证握手的身份验证功能的基础上尽量减少通信的次数，一般的发送顺序是这样的，这一点可以通过wireshark抓ffmpeg推流包进行验证：（简单握手和复杂握手均是如此）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">｜client｜Server ｜</span><br><span class="line">｜－－－C0 + C1－－－&gt;  |</span><br><span class="line">｜&lt;－－S0 + S1 + S2－－｜</span><br><span class="line">｜－－－－ C2 －－－－&gt;｜</span><br></pre></td></tr></table></figure>

<ul>
<li>简单握手中<strong>S2是C1的复制</strong>，<strong>C2是S1的复制</strong>。</li>
</ul>
<h2 id="简单握手"><a href="#简单握手" class="headerlink" title="简单握手"></a>简单握手</h2><p><strong>C0和S0</strong></p>
<p>C0和S0包都是一个单一的8位字节，以一个单独的8位整型域进行处理：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>version</td>
<td>8 bytes</td>
<td>在 C0中，这一字段指示出客户端要求的 RTMP 版本号。在 S0 中，这一字段指示出服务端选择的 RTMP 版本号。</td>
</tr>
</tbody></table>
<ul>
<li><p>版本号基本都是3。0、1、2 这三个值是由早期其他产品使用的，是废弃值。</p>
</li>
<li><p>4 - 31 被保留为RTMP 协议的未来实现版本使用。</p>
</li>
<li><p>32 - 255 不允许使用（以区分开 RTMP 和其他常以一个可打印字符开始的文本协议）。</p>
</li>
<li><p>无法识别客户端所请求版本号的服务器应该以版本 3 响应，（收到响应的）客户端可以选择降低到版本 3，或者放弃握手。</p>
</li>
</ul>
<p><strong>C1和S1</strong></p>
<p>C1 和 S1 数据包的长度都是 1536 字节。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>这个字段包含一个 timestamp，用于本终端发送的所有后续块的时间起点。这个值可以是 0。</td>
</tr>
<tr>
<td>zero</td>
<td>4 bytes</td>
<td>这个字段必须都是 0。如果不是0，代表要使用复杂握手。</td>
</tr>
<tr>
<td>random</td>
<td>1528 bytes</td>
<td>这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手，这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护，也不需要动态值。</td>
</tr>
</tbody></table>
<p><strong>C2和S2</strong></p>
<p>C2 和 S2 数据包长度都是 1536 个节，基本就是 S1 和 C1 的副本。S2是C1的复制。 C2是S1的复制。分布如下：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的timestamp。</td>
</tr>
<tr>
<td>time2</td>
<td>4 bytes</td>
<td>这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</td>
</tr>
<tr>
<td>random</td>
<td>1528 bytes</td>
<td>这个字段必须包含终端发的 S1 (给 C2) 或者 S2 (给 C1)的随机数。</td>
</tr>
</tbody></table>
<h2 id="复杂握手"><a href="#复杂握手" class="headerlink" title="复杂握手"></a>复杂握手</h2><ul>
<li>相对于简单握手，复杂握手主要是增加了更严格的验证。 主要是<strong>将简单握手中1528Bytes随机数的部分平均分成两部分</strong>， 一部分764Bytes存储public key（公共密钥，32字节），另一部分 764Bytes存储digest（密文，32字节）。</li>
<li>复杂握手还有一个明显的特征就是: C1、S1的version部分（<strong>简单握手的zero字段</strong>）不为0， 服务端可根据这个来判断是否简单握手或复杂握手。</li>
</ul>
<p><strong>C0和S0</strong></p>
<p>C0和S0包都是一个单一的8位字节，以一个单独的8位整型域进行处理：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>version</td>
<td>8 bytes</td>
<td>说明是明文还是密文。如果使用的是明文（0X03），同时代表当前使用的rtmp协议的版本号。如果是密文，该位为0x06</td>
</tr>
</tbody></table>
<p><strong>C1和S1</strong></p>
<p>和简单握手相比，主要是将简单握手中random（1528Bytes）的部分平均分成两部分， 一部分764Bytes存储public key（公共密钥，32字节），另一部分 764Bytes存储digest（密文，32字节）。以此来增加更加严格的验证。在不同的包里，<strong>key和diest顺序可能会颠倒</strong>，比如nginx-rtmp。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>说明是明文还是密文。如果使用的是明文（0X03），同时代表当前使用的rtmp协议的版本号。如果是密文，该位为0x06</td>
</tr>
<tr>
<td>version</td>
<td>4 bytes</td>
<td>非0值，如果是0则表示简单握手。</td>
</tr>
<tr>
<td>key</td>
<td>764 bytes</td>
<td>random-data：长度由这个字段的最后4个byte决定，即761 - 764<br>key-data：128个字节。Key字段对应C1和S1有不同的算法。发送端（C1）中的Key应该是随机的，接收端（S1）的key需要按照发送端的key去计算然后返回给发送端。<br>random-data：（764 - offset - 128 - 4）个字节<br>   key_offset：4字节, 最后4字节定义了key的offset（相对于KeyBlock开头而言，相当于第一个random_data的长度）</td>
</tr>
<tr>
<td>digest</td>
<td>764 bytes</td>
<td>offset：4字节, 开头4字节定义了digest的offset<br>random-data：长度由这个字段起始的4个byte决定<br>digest-data：<strong>32个字节</strong><br>random-data：（764 - 4 - offset - 32）个字节</td>
</tr>
</tbody></table>
<p><strong>C2和S2</strong></p>
<p>C2、S2就是把digest放到最后那32字节上，主要是用来对C1、S1的验证。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>4 bytes</td>
<td>这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的timestamp。</td>
</tr>
<tr>
<td>time2</td>
<td>4 bytes</td>
<td>这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</td>
</tr>
<tr>
<td>random</td>
<td>1504 bytes</td>
<td>random-data：1504字节。</td>
</tr>
<tr>
<td>digest</td>
<td>32 bytes</td>
<td>digest-data：32个字节。</td>
</tr>
</tbody></table>
<h1 id="RTMP消息格式"><a href="#RTMP消息格式" class="headerlink" title="RTMP消息格式"></a>RTMP消息格式</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><ul>
<li>消息（Message）是RTMP协议中<strong>基本的数据单元</strong>。由<strong>Message Header和Message Payload</strong>（可以理解成message body）组成。</li>
<li>对于<strong>音视频数据而言每一个message就是一帧数据</strong>。对于flv的tag而言，就是对应rtmp每个message，<strong>一个tag就是一个message</strong>，是一一对应的关系；相当于每一个tag都封装成一个message。message payload的数据格式和tag data的数据格式是相同的，message header和tag header的格式不同。</li>
<li>多路复用，RTMP可以将来自不同视频流的切片（chunk）在单个连接上传输，这种方法被称为“多路复用”，不同的流就用不同的Message Stream Id区分。</li>
<li>Message Header格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Length</td>
<td>3 bytes</td>
<td>Message Payload（消息负载）的长度，不包含Message Header。</td>
</tr>
<tr>
<td>Timestamp</td>
<td>4 bytes</td>
<td>时间戳（既是pts也是dts，因为直播场景中没有B帧，所以pts&#x3D;dts）。</td>
</tr>
<tr>
<td>Message Type Id</td>
<td>1 bytes</td>
<td>消息类型，主要包括协议控制消息、音视频消息、命令消息等。</td>
</tr>
<tr>
<td>Message Stream Id</td>
<td>3 bytes</td>
<td>消息流ID可以是任意值。不同的message可以有相同的值。复用到同一块流上的不同消息流基于它们的消息流ID解复用。</td>
</tr>
</tbody></table>
<ul>
<li>Message Payload格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>—</td>
<td>n bytes</td>
<td>是消息中包含的实际数据，消息类型不同payload大小也不同。例如，它可以是一些音频样本或压缩视频数据或Metadata等。</td>
</tr>
</tbody></table>
<ul>
<li><strong>这里注意RTMP消息的头（RTMP Message Header，不是chunk头中的 Message Header，两个不是同一个东西）有自己的统一格式，当然这部分也是会被切割到 Chunk 里传输的，不过，因为实际意义和 Chunk Header 内容重复，当前主流流媒体服务器在发送RTMP消息时，chunk data中不包含RTMP Message Header，只要双方约定好即可。</strong></li>
</ul>
<h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><ul>
<li><p>RTMP以Message为基本单位，通过把Message拆分成Chunk来进行网络发送。<strong>chunk data默认是128字节</strong>。<strong>chunk是RTMP最小的传输单元</strong>。目的是：防止一个大的数据包传输时间过长，阻塞其它数据包的传输。chunk合成message：接收端将接收到chunk的chunk data的大小加和，如果等于message payload（通过chunk-&gt;message header-&gt;message length获取）的则认为是同一个message。</p>
</li>
<li><p>Chunk在传输时：<strong>同一个Message产生的多个Chunk只会串行发送</strong>。先发送的Chunk一定先到达。<strong>不同Message产生的Chunk可以并行发送</strong>。<strong>并行发送的Chunk复用了一条TCP链接</strong>。</p>
</li>
<li><p>Chunk Header格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Basic Header</td>
<td>1-3 bytes</td>
<td>包含fmt（chunk type）和chunk stream id（csid），其中fmt决定了chunk的类型及message header的长度，占2 bit，而Basic header的长度取决于csid的数值大小，最少占1 byte。</td>
</tr>
<tr>
<td>Message Header</td>
<td>0，3，7 or 11 bytes</td>
<td>要发送的实际信息（可能是完整的，也可能是一部分）的描述信息。<br>长度取决于Basic Header中的chunk type，有Type 0，1，2，3类型的header</td>
</tr>
<tr>
<td>Extended Timestamp</td>
<td>0 or 4 bytes</td>
<td>扩展时间戳（0 bytes时表示此字段不存在）。</td>
</tr>
</tbody></table>
<ul>
<li>Chunk Data格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>—</td>
<td>n bytes</td>
<td>是消息中包含的实际数据，消息类型不同data大小也不同。</td>
</tr>
</tbody></table>
<h3 id="Basic-Header"><a href="#Basic-Header" class="headerlink" title="Basic Header"></a>Basic Header</h3><ul>
<li>Basic Header格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>fmt</td>
<td>2 bits</td>
<td>表示chunk type，取值[0, 3]，即chunk共有4种类型</td>
</tr>
<tr>
<td>csid(chunk stream id)</td>
<td>6，14 or 22 bits</td>
<td>csid范围是3 ~ 65599，0 ~ 2为协议保留用作特殊信息；<br>通常控制流csid为2，命令流为3，开发中发现音视频流csid可自定义，如音频流4，视频流6。<br>上文提到Basic Header大小为1-3 bytes，由于fmt域占2bits，所以CSID长度分别是6 bits、14 bits或22 bits</td>
</tr>
</tbody></table>
<ul>
<li><p>Basic Header为1bytes时：csid为6bits，取值在[3~63]。</p>
</li>
<li><p>Basic Header为2bytes时：第一个字节除了fmt外，其余6位表示数字0，csid范围是[64~319]，即最大为(2^8 - 1) + 64 &#x3D; 319。</p>
</li>
<li><p>Basic Header为3bytes时：第一个字节除了fmt外，其余6位表示数字1，csid范围是[64~65599]，最大值为 (2^16 - 1) + 64 &#x3D; 65599。</p>
</li>
</ul>
<h3 id="Message-Header"><a href="#Message-Header" class="headerlink" title="Message Header"></a>Message Header</h3><ul>
<li><p><strong>Message Header的格式和长度取决于Basic Header的chunk type</strong>，即fmt，fmt取值[0-3]，所以共有4种不同的chunk格式，目的是减少重复数据发送，提高 chunk data的占比。同时也有4种不同的Message Header。</p>
</li>
<li><p><strong>chunk type &#x3D; 0</strong>（fmt &#x3D; 0）：Message Header共11字节，<strong>此类型必须在块流开始时使用</strong>，当<strong>流时间戳</strong>向后（例如，回退播放）时也要使用此格式。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp</td>
<td>3 bytes</td>
<td>时间戳，如果值大于等于16777215（0xFFFFFF），该字段必须等于16777215，然后转存到4字节的Extended Timstamp字段中。接收端判断是0xFFFFFF后会去Extended Timstamp解析时间戳。</td>
</tr>
<tr>
<td>message length</td>
<td>3 bytes</td>
<td>指的是message拆分之前message payload的长度（不包含header），而且如果被拆分成chunk，此字段填充拆分前message的body长度，而不是chunk的长度。</td>
</tr>
<tr>
<td>message type id</td>
<td>1 byte</td>
<td>消息类型，如8代表audio数据，9代表video，其它值可参考后文的消息类型。</td>
</tr>
<tr>
<td>message stream id</td>
<td>4 bytes</td>
<td>表示该chunk所在的流的ID。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=0.png" alt="chunk-type=0" style="zoom:50%;">

<ul>
<li><strong>chunk type &#x3D; 1</strong>（fmt &#x3D; 1）：Message Header共7字节，<strong>和前一个chunk共用message stream id</strong>（msid），因此省去了message stream id的4字节，表示此Chunk和上一次发的Chunk所在的流相同（不是相同的message），如果在发送端和对端有一个流连接的时候尽量采用这种格式。</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp delta</td>
<td>3 bytes</td>
<td>和上一个chunk的时间差。如果值大于等于16777215（0xFFFFFF），该字段必须等于16777215，然后转存到4字节的Extended Timstamp字段中。接收端判断是0xFFFFFF后会去Extended Timstamp解析时间戳。</td>
</tr>
<tr>
<td>message length</td>
<td>3 bytes</td>
<td>指的是message拆分之前message payload的长度（不包含header），而且如果被拆分成chunk，此字段填充拆分前message的body长度，而不是chunk的长度。</td>
</tr>
<tr>
<td>message type id</td>
<td>1 byte</td>
<td>消息类型，如8代表audio数据，9代表video，其它值可参考后文的消息类型。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=1.png" alt="chunk-type=1" style="zoom:50%;">

<ul>
<li><strong>chunk type &#x3D; 2</strong>（fmt &#x3D; 2）：Message Header共3字节，相对于 chunk type &#x3D; 1 格式又省去了message length的3个字节和message type id的1个字节，表示此 chunk和上一次发送的 chunk 的message length、message type id都相同。余下的这三个字节表示 timestamp delta，使用同type&#x3D;1。</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>timestamp delta</td>
<td>3 bytes</td>
<td>和上一个chunk的时间差。如果值大于等于16777215（0xFFFFFF），该字段必须等于16777215，然后转存到4字节的Extended Timstamp字段中。接收端判断是0xFFFFFF后会去Extended Timstamp解析时间戳。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=2.png" alt="chunk-type=2" style="zoom:50%;">

<ul>
<li><strong>chunk type &#x3D; 3</strong>（fmt &#x3D; 3）：Message Header共0字节，即此时chunk没有Message header。</li>
</ul>
<p>当它在type &#x3D; 0的chunk后面时，表示和前一个chunk的时间戳是相同的，也就是一个Message拆分成多个chunk时，后一个chunk和前一个chunk同属一个Message自然也就可以不用传Message header。</p>
<p>当它跟在type &#x3D; 1或type &#x3D; 2的chunk后面时，表示和前一个时间戳的差相同。如第一个chunk是type &#x3D; 0，timestamp &#x3D; 0，第二个chunk是type &#x3D; 2，timestamp delta &#x3D; 20，表示时间戳为0+20&#x3D;20，第三个chunk是type &#x3D; 3，则timestamp delta &#x3D; 20，表示时间戳为20+20&#x3D;40。</p>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk-type=3.png" alt="chunk-type=3" style="zoom:50%;">

<h2 id="Message和Chunk之间关系"><a href="#Message和Chunk之间关系" class="headerlink" title="Message和Chunk之间关系"></a>Message和Chunk之间关系</h2><p>前文已经介绍了RTMP传输的单位不是massage，而是把massage拆分成一个或多个chunk来进行传输，可根据msg stream id判断是否属于同一个Massage，其拆分过程如下：</p>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/chunk和message关系.png" alt="chunk和message关系" style="zoom:50%;">

<p><strong>这里采用通用的做法，RTMP Message Header不拆分到chunk data中，虽然规范上RTMP massage应该作为一个整体被拆分成chunk，但是由于RTMP massage header与chunk massage header信息重复，本着最小传输数据原则，一般做法是在chunk data中去掉此信息。</strong></p>
<h1 id="RTMP消息类型"><a href="#RTMP消息类型" class="headerlink" title="RTMP消息类型"></a>RTMP消息类型</h1><p>RTMP协议中有多种消息，用于数据传输和命令控制等操作，所有的消息都是封装成message，然后通过chunk来传输。</p>
<h2 id="协议控制消息"><a href="#协议控制消息" class="headerlink" title="协议控制消息"></a>协议控制消息</h2><p>在RTMP的chunk流会用一些特殊的值来代表协议的控制消息，属于RTMP chunk流协议层的消息，它们的<strong>Message Stream ID必须为0</strong>（代表控制流信息），<strong>CSID必须为2</strong>，Message Type ID可以为1，2，3，5，6，具体代表的消息会在下面依次说明。控制消息的接受端会忽略掉chunk中的时间戳，收到后立即生效。</p>
<h3 id="设置块大小"><a href="#设置块大小" class="headerlink" title="设置块大小"></a>设置块大小</h3><ul>
<li><p>Type ID: Set Chunk Size ，Message Type ID &#x3D; 1。Message Type ID 就是chunk中Type ID，也就是0x01。</p>
</li>
<li><p>RTMP消息需要以chunk size为单位封装成chunk包发送，因此接收端需要根据chunk size才能正确解包，所以<strong>双端都要记录对端的封包单位chunk size</strong>，默认128 bytes。</p>
</li>
<li><p>通信过程中可发送此消息通知对端更新其记录的本端的chunk size。比如client想发送131 bytes的音频数据（此时chunk size为128 bytes，不更新chunk size的话需要拆成两个chunk），此时client可通知对端，这边client的chunk size更新为131 bytes，之后发送一个data为131 bytes的chunk即可，<strong>server端收到Set Chunk Size之后更新chunk size即可正确解析之后到来的chunk</strong>。</p>
</li>
<li><p><strong>双端的chunk size各自独立维护，可以不同。</strong>例如client可以发送131 bytes的chunk，server也按照131 bytes解析，server发送128 bytes的chunk，client也按照128 bytes解析。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>第一个bit</td>
<td>1 bit</td>
<td>恒为0</td>
</tr>
<tr>
<td>chunk size</td>
<td>31 bit</td>
<td>可表示[1, 0x7FFFFFFF]区间，但是由于chunk size要小于Message的length，<br>而Message length字段用3个字节存储，最大值为0xFFFFFF，所以实际可取值区间为[1, 0xFFFFFF]</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP设置块大小.png" alt="RTMP设置块大小" style="zoom:50%;">

<h3 id="应答窗口大小"><a href="#应答窗口大小" class="headerlink" title="应答窗口大小"></a>应答窗口大小</h3><ul>
<li><p>Type ID: Window Acknowledgement Size，Message Type ID &#x3D; 5。</p>
</li>
<li><p>规定接收端接收多少数据后需要发送一个应答消息。发送端可以发送此消息通知对端更新窗口大小，一般在音视频数据之前发送。并且<strong>双端的window size共同维护，保持相同</strong>。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>acknowledgement window size</td>
<td>32 bits</td>
<td>接收端接收多少数据后需要发送一个应答消息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP应答窗口大小.png" alt="RTMP应答窗口大小" style="zoom:50%;">

<h3 id="应答消息"><a href="#应答消息" class="headerlink" title="应答消息"></a>应答消息</h3><ul>
<li><p>Type ID: Acknowledgement，Message Type ID &#x3D; 3。</p>
</li>
<li><p>当收到对端消息字节数等于接收窗口大小时，接收端要回复一个应答消息（相当于ack）告知对端可以继续发送数据，<strong>发送方在收到应答消息之前不会再继续发送消息</strong>。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>chunk stream id</td>
<td>32 bits</td>
<td>截止目前接收到的数据总和，以字节为单位。</td>
</tr>
</tbody></table>
<h3 id="设置流带宽"><a href="#设置流带宽" class="headerlink" title="设置流带宽"></a>设置流带宽</h3><ul>
<li>Type ID: Set Peer Bandwidth，Message Type ID &#x3D; 6。</li>
<li>客户端或服务器发送此消息以限制其对等端的输出带宽。</li>
<li>message payload格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>acknowledgement window size</td>
<td>32 bits</td>
<td>设置对端出口带宽</td>
</tr>
<tr>
<td>limit type</td>
<td>8 bits</td>
<td>limit type &#x3D; 0：硬限制，立即更新出口带宽大小<br>limit type &#x3D; 1：软限制，可以更新出口带宽大小，也可以保留原值，但是原值一定要小于期望更新的大小<br>limit type &#x3D; 2：动态限制，如果上一次为硬限制，此消息被视为硬限制，否则忽略此消息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP设置流带宽.png" alt="RTMP设置流带宽" style="zoom:50%;">

<h3 id="中断消息"><a href="#中断消息" class="headerlink" title="中断消息"></a>中断消息</h3><ul>
<li><p>Type ID: Abort Message，Message Type ID &#x3D; 2。</p>
</li>
<li><p>发送数据过程中，发送端可发送Abort消息通知接收端丢弃当前未接收完的Message及忽略之后的消息。先前已收到的chunk将被全部被抛弃，接收端根据Abort消息中的chunk stream id（csid）可丢弃对应chunk流中之后的所有数据。比如在发送端需要关闭时，发送此消息通知对端之后的数据可以不用处理了。</p>
</li>
<li><p>message payload格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>chunk stream id</td>
<td>32 bits</td>
<td>此字段保存要丢弃其当前消息的块流ID。</td>
</tr>
</tbody></table>
<h2 id="命令消息"><a href="#命令消息" class="headerlink" title="命令消息"></a>命令消息</h2><ul>
<li><p>命令消息（Command Messages）是用于 C-S 进行直接交互应答的一类消息。一般情况下，命令消息的发送对端，<strong>是需要对端进行应答信号反馈的</strong>。需要AMF编码，AMF0编码时Message Type ID &#x3D; 20，使用AMF3编码时Message Type ID &#x3D; 17，CSID通常为3。</p>
</li>
<li><p>命令类型的消息包含<strong>命令名称</strong>、<strong>事务ID</strong>和<strong>相关参数</strong>。如client端发送connect命令时需要包含要连接的应用名称作为参数，然后server端回复消息时带上收到的transaction ID表示对此条消息的回应。回复命令有<code>_result</code>，<code>_error</code>，或者其他如verifyClient，contactExternalServer的方法名。</p>
</li>
<li><p>发送命令消息的对象有两种分别是NetConnection和NetStream。</p>
<ul>
<li>NetConnection：表示双端的上层连接，服务器和客户端之间进行网络连接的一种高级表示形式。</li>
<li>NetStream：表示流信息的传输通道如音频流、视频流，以及控制流信息的状态，如Play播放流，Pause暂停。</li>
</ul>
</li>
</ul>
<h3 id="网络连接命令"><a href="#网络连接命令" class="headerlink" title="网络连接命令"></a>网络连接命令</h3><ul>
<li>表示双端的上层连接，服务器和客户端之间进行网络连接的一种高级表示形式。</li>
<li>网络连接允许使用：连接（connect）、调用（call）、创建流（createStream），每一种消息都有应答消息。</li>
<li>应答消息中的“Transaction ID”表明对哪个请求的应答。</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul>
<li><p>客户端向服务器发送connect命令，以请求连接到服务器<strong>应用程序实例</strong>（Application Instance）。不同的的Application Instance可根据功能进行区分，比如直播可以用live表示，点播可以用vod表示，测试环境可以用test表示，用户可自定义。例如：rtmp:&#x2F;&#x2F;192.127.0.1&#x2F;test&#x2F;16，可以表示test环境，16是对流的描述，用户可自定义。ip后面的内容可以用来标识流的内容。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>”connect”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为1</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数（具体内容可参考官方文档）</td>
</tr>
<tr>
<td>Optional User Arguments（额外的用户参数)</td>
<td>Object</td>
<td>用户自定义的额外信息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-connect请求消息.png" alt="RTMP-connect请求消息" style="zoom:50%;">

<ul>
<li>响应消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>”<code>_result</code>”或”<code>_err</code>“，表示响应是否为结果或者错误</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为1</td>
</tr>
<tr>
<td>Properties(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数（具体内容可参考官方文档）</td>
</tr>
<tr>
<td>Information（应答信息)</td>
<td>Object</td>
<td>描述应答的名称-值对，如“code”，“level”，“description”之类的内容</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-connect响应消息.png" alt="RTMP-connect响应消息" style="zoom:50%;">

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul>
<li>NetConnection对象的调用方法在接收端运行远程过程调用（RPC）。被调用的RPC名称作为参数传递给调用命令。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Procedure Name(程序名称)</td>
<td>String</td>
<td>指定调用对端的远程功能名称</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>事物ID，用来标记请求，如不需要也可以传0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数（具体内容可参考官方文档）</td>
</tr>
<tr>
<td>Optional User Arguments（额外的用户参数)</td>
<td>Object</td>
<td>用户自定义的额外信息</td>
</tr>
</tbody></table>
<ul>
<li>响应消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>RPC请求方定义的回应方法的名称</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>需要响应的RPC请求的事务ID，标识它属于哪个应答的</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>RPC需求的配置参数</td>
</tr>
<tr>
<td>Response（应答信息)</td>
<td>Object</td>
<td>被调用的RPC的返回结果</td>
</tr>
</tbody></table>
<h4 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h4><ul>
<li>客户端将此命令发送到服务器，以创建消息通信的逻辑通道。音频、视频和元数据的发布通过使用createStream命令创建的流通道执行。NetConnection是默认的通信信道，其流ID为0。协议和一些命令消息（包括createStream）使用默认的通信通道。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(程序名称)</td>
<td>String</td>
<td>“createstream”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>命令会话ID</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>如果存在任何命令信息，则设置此对象，否则设置为空类型。</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-createStream请求消息.png" alt="RTMP-createStream请求消息" style="zoom:50%;">

<ul>
<li>响应消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>”<code>_result</code>”或”<code>_err</code>“，表示响应是否为结果或者错误</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>标识它属于哪个应答的</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>如果存在任何命令信息，则设置此对象，否则设置为空类型。</td>
</tr>
<tr>
<td>Stream ID（应答信息)</td>
<td>Number</td>
<td>stream id（用于唯一标识该Stream）或错误信息</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-createStream响应消息.png" alt="RTMP-createStream响应消息" style="zoom:50%;">

<h3 id="网络流命令"><a href="#网络流命令" class="headerlink" title="网络流命令"></a>网络流命令</h3><ul>
<li>网络流命令是在数据信道建立完毕后（<strong>先有NetConnection，才有NetStream命令</strong>），用来对音视频数据流进行直接控制的命令类型。这些命令作用于当前信道对应数据的操控行为，都是客户端向服务端发送的命令，一个NetConnection对象可以有多个NetStream，进而支持多种数据。常见的命令如下：</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>play</td>
<td>播放</td>
</tr>
<tr>
<td>play2</td>
<td>播放2</td>
</tr>
<tr>
<td>deleteStream</td>
<td>删除流</td>
</tr>
<tr>
<td>closeStream</td>
<td>关闭流</td>
</tr>
<tr>
<td>receiveAudio</td>
<td>接收音频</td>
</tr>
<tr>
<td>receiveVideo</td>
<td>接收视频</td>
</tr>
<tr>
<td>publish</td>
<td>推流</td>
</tr>
<tr>
<td>seek</td>
<td>定位</td>
</tr>
<tr>
<td>pause</td>
<td>暂停</td>
</tr>
</tbody></table>
<ul>
<li>网络流命令的请求命令所对应的应答命令，被统一命名为 “<strong>onStatus</strong>” 以描述数据所处的状态发生变更，因此<strong>具有统一的格式</strong>（注意：<strong>不是所有的消息都有应答，而是有应答消息的都是如下格式</strong>）</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>onStatus</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>NULL</td>
</tr>
<tr>
<td>Info Object（应答信息)</td>
<td>Object</td>
<td>stream id或错误信息</td>
</tr>
</tbody></table>
<h4 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h4><ul>
<li><p>客户端发送此命令让服务器播放流。也可以多次使用此命令创建一个播放列表。如果你想创建一个在不同直播或录制流之间切换的动态播放列表，多次调用play并将reset字段设置为false。相反，如果你想立即播放指定的流，将reset字段设置为true。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“play”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Stream Name(流名称)</td>
<td>String</td>
<td>待播放流的名称和格式。<br> 如果要播放视频（FLV）文件，指定不带文件扩展名（比如，“sample”）的流名称。<br>如果要播放H.264&#x2F;AAC文件，你必须在流名称前加上mp4:的前缀，并且指定文件名后缀。比如，要播放文件sample.m4v，指定“mp4:sample.m4v”<br> 如果要回放MP3或者ID3标签，你必须要在流名称前加上mp3:的前缀。比如，“mp3:sample”</td>
</tr>
<tr>
<td>Start(开始时间)</td>
<td>String</td>
<td>一个可选的参数，指定开始播放的起开时间，单位是秒，默认值是-2。<br>Start &#x3D; -2，代表选取对应该流名称的直播流，即当前正在推送的流开始播放，如果对应该名称的直播流不存在，就选取该名称的流的录播版本，如果这也没有，<strong>当前播流端要等待直到对端开始该名称的流的直播</strong>。<br>Start &#x3D; -1，那么只会选取直播流进行播放，即使有录播流也不会播放；如果传值或者正数，就代表从该流的该时间点开始播放，<strong>如果流不存在的话就会自动播放播放列表中的下一个流</strong><br> Duration &gt;&#x3D; 0，一个在流名称字段指定的录播流会被播放，起始时间是Start字段指定的时间。如果找不到该记录流，<strong>播放列表的下一个条目会被播放</strong>。</td>
</tr>
<tr>
<td>Duration(时长)</td>
<td>String</td>
<td>一个可选的参数，指定回放时长，单位是秒，默认值是-1。<br>Duration &#x3D; -1，直播流被播放直到它不可用，或者录播流被播放直到结束。（如果你传递一个不同于-1的负数，它会把该值解析为-1）<br>Duration &#x3D; 0，它会播放录播流中Start字段指定开始时间的一帧。<br>Duration &gt; 0，如果你指定一个正数，它会播放Duration字段指定该段时间的直播流。之后，它能够播放Duration字段指定该段时间的录播流。（如果流在Duration字段指定的时间前结束，回放随着流的结束而结束）</td>
</tr>
<tr>
<td>Reset(重置)</td>
<td>Boolean</td>
<td>一个可选的布尔值，它指定是否清除之前的所有播放列表</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-play请求消息.png" alt="RTMP-play请求消息" style="zoom:50%;">

<h4 id="播放2"><a href="#播放2" class="headerlink" title="播放2"></a>播放2</h4><ul>
<li><p>play命令不同的是，play2命令可以将<strong>当前正在播放的流切换到同样数据但不同码率的流上</strong>，服务端会维护多种比特率的文件来供客户端使用play2命令来切换。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“play2”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Parameters(参数)</td>
<td>Object</td>
<td>AMF编码的Flash对象，包括了一些用于描述flash.net.NetstreamPlayOptions ActionScript obejct的参数</td>
</tr>
</tbody></table>
<h4 id="删除流"><a href="#删除流" class="headerlink" title="删除流"></a>删除流</h4><ul>
<li><p>NetStream在<strong>NetStream对象被销毁时发送deleteStream命令</strong>，用于客户端告知服务端本地的某个流对象已被删除，不需要再传输此路流。</p>
</li>
<li><p>删除流命令无应答消息。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“deleteStream”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Stream ID（流ID)</td>
<td>Number</td>
<td>本地已删除，不再需要服务器传输的流的ID</td>
</tr>
</tbody></table>
<h4 id="接收音频"><a href="#接收音频" class="headerlink" title="接收音频"></a>接收音频</h4><ul>
<li>客户端通知服务端是否要发送音频。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“receiveAudio”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Bool Flag(标识)</td>
<td>Boolean</td>
<td>Bool Flag &#x3D; true，表示发送音频，服务端就会准备接受音频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态<br> Bool Flag &#x3D; false，服务端不做响应</td>
</tr>
</tbody></table>
<h4 id="接收视频"><a href="#接收视频" class="headerlink" title="接收视频"></a>接收视频</h4><ul>
<li>客户端通知服务端是否要发送视频。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“receiveVideo”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Bool Flag(标识)</td>
<td>Boolean</td>
<td>Bool Flag &#x3D; true，表示发送音频，服务端就会准备接受音频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态<br> Bool Flag &#x3D; false，服务端不做响应</td>
</tr>
</tbody></table>
<h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ul>
<li><p>客户端发送此消息，<strong>将命名流推送到服务器</strong>。其他客户端可以使用此流名来播放流，接收发布的音频，视频，以及其它数据消息。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“publish“</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>PublishingName(发布的流名称)</td>
<td>String</td>
<td>发布流的名称</td>
</tr>
<tr>
<td>PublishingType(发布类型)</td>
<td>String</td>
<td>有三种发布的类型：live, record 或 append<br>PublishingType &#x3D; record : 该流已被发布并且数据被记录到一个新的文件。该文件存储在服务器的一个包含服务器应用程序目录的子目录。如果文件已经存在，则它被覆盖<br>PublishingType &#x3D; append：流已经被发布，并且该数据被追加到一个文件。如果找不到文件，则创建它<br> PublishingType &#x3D; live：直播数据被发布，而没有记录到文件</td>
</tr>
</tbody></table>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-publish请求消息.png" alt="RTMP-publish请求消息" style="zoom:50%;">

<ul>
<li>publish 的返回状态 NetStream.Publish.Start，这个消息不止由 onStatus 统一应答携带，也会由 onFCPublish 返回。</li>
</ul>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ul>
<li><p>定位（seek）到视频或音频的某个位置，以毫秒为单位。</p>
</li>
<li><p>请求消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“seek“</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>milliSeconds(毫秒)</td>
<td>Number</td>
<td>定位到该文件的xx毫秒处</td>
</tr>
</tbody></table>
<ul>
<li>当定位成功，服务器发送NetStream.Seek.Notify的状态消息。失败的时候，它返回一个_error的消息。</li>
</ul>
<h4 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h4><ul>
<li>客户端发送pause命令以告诉服务器暂停或者开始播放。</li>
<li>请求消息格式：</li>
</ul>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>“pause“</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>Transaction ID设置为0</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Null</td>
<td>不存在命令信息，设置为null类型</td>
</tr>
<tr>
<td>Pause&#x2F;Unpause Flag(暂停&#x2F;恢复播放)</td>
<td>Boolean</td>
<td>true，暂停<br>false，恢复播放</td>
</tr>
<tr>
<td>milliSeconds(毫秒)</td>
<td>Number</td>
<td>定位到该文件的xx毫秒处</td>
</tr>
</tbody></table>
<ul>
<li>pause 成功后，会有 ’code’ 为 NetStream.Pause.Notify 消息返回；unpause 成功后，会有 ’code’ 为 NetStream.Unpause.Notify 消息返回。</li>
</ul>
<h3 id="数据消息"><a href="#数据消息" class="headerlink" title="数据消息"></a>数据消息</h3><ul>
<li>传递一些元数据（MetaData，比如视频名，分辨率等等）或者用户自定义的一些消息。当信息使用AMF0编码时，Message Type ID＝18，AMF3编码时Message Type ID＝15。</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-数据消息.png" alt="RTMP-数据消息" style="zoom:50%;">

<h3 id="共享消息"><a href="#共享消息" class="headerlink" title="共享消息"></a>共享消息</h3><ul>
<li><p>共享对象是在多个客户端、实例等之间同步的Flash对象，Flash对象是由键值对组成的集合。每条消息可以包含多个事件。当信息使用AMF0编码时，Message Type ID＝19，AMF3编码时Message Type ID＝16。</p>
</li>
<li><p>消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>Use(&#x3D;1)</td>
<td>客户端发送此事件通知服务器一个共享对象的创建</td>
</tr>
<tr>
<td>Release(&#x3D;2)</td>
<td>当在客户端删除共享对象时，客户端将此事件发送到服务器上</td>
</tr>
<tr>
<td>Request Change(&#x3D;3)</td>
<td>客户端发送此事件以请求更改与共享对象命名参数关联的值</td>
</tr>
<tr>
<td>Change(&#x3D;4)</td>
<td>服务器发送此事件通知除了正在发起请求之外的所有客户端命名参数值的变化</td>
</tr>
<tr>
<td>Success(&#x3D;5)</td>
<td>如果请求被受理，服务器发送此事件给正在请求的客户端，以响应RequestChange事件</td>
</tr>
<tr>
<td>SendMessage(&#x3D;6)</td>
<td>客户端将此事件发送到服务器以广播一个消息。在接收此事件时，服务器向所有客户端广播消息，包括该发送者</td>
</tr>
<tr>
<td>Status(&#x3D;7)</td>
<td>服务器发送此事件以通知客户端相关的错误状况</td>
</tr>
<tr>
<td>Clear(&#x3D;8)</td>
<td>服务器将此事件发送给客户端，以清除共享对象。服务器还发送此事件以响应客户端在连接时发送Use event</td>
</tr>
<tr>
<td>Remove(&#x3D;9)</td>
<td>服务器发送此事件让客户端删除一个slot</td>
</tr>
<tr>
<td>Request Remove(&#x3D;10)</td>
<td>客户端发送此事件让服务器删除一个slot</td>
</tr>
<tr>
<td>Use Success(&#x3D;11)</td>
<td>成功连接时，服务器将此事件发送给客户端8. 音频信息（Audio Message）</td>
</tr>
</tbody></table>
<h3 id="音视频信息"><a href="#音视频信息" class="headerlink" title="音视频信息"></a>音视频信息</h3><ul>
<li>每一个message就是一帧数据。对于flv的tag而言，就是对应rtmp每个message，一个tag就是一个message，是一一对应的关系；相当于每一个tag都封装成一个message。</li>
<li>RTMP 块流使用<strong>Message Type ID&#x3D;8 作为音频数据</strong>，flv的tag header-&gt;tag type也用8来表示音频。通常音频流的csid是4（也可以自定义），音频流的每一个chunk的csid都是相同的。</li>
<li>RTMP 块流使用<strong>Message Type ID&#x3D;9 作为视频数据</strong>，flv的tag header-&gt;tag type也用9来表示音频。通常视频流的csid是6（也可以自定义），视频流的每一个chunk的csid都是相同的。</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-音频消息.png" alt="RTMP-音频消息" style="zoom:50%;">



<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-视频消息.png" alt="RTMP-视频消息" style="zoom:50%;">

<h3 id="聚合消息"><a href="#聚合消息" class="headerlink" title="聚合消息"></a>聚合消息</h3><ul>
<li>聚合消息是包含一系列RTMP子消息的单个消息，Message Type ID＝22。</li>
<li>聚合消息的消息流ID覆盖聚合内部的子消息的消息流程ID；聚合消息和第一个子消息的时间戳之间的差异是用于将子消息的时间戳记重新规范化为流时间尺度的偏移量。偏移量被添加到每个子消息的时间戳，以达到标准化的流时间。第一个子消息的时间戳应与聚合消息的时间戳记相同，因此偏移量应为零；返回指针包含前一条消息的大小，包括其标头，它被包括以匹配FLV文件的格式，并用于反向搜索，类似于flv的previous tag header。</li>
<li>使用聚合消息有几个性能优势：<ul>
<li>区块流最多可以在一个区块内发送一条完整的消息。因此，增加块大小并使用聚合消息可以减少发送的块数。</li>
<li>子消息可以连续存储在内存中。当进行系统调用以在网络上发送数据时，效率更高。</li>
</ul>
</li>
<li>消息格式：</li>
</ul>
<img src="/2023/09/17/RTMP%E5%8D%8F%E8%AE%AE/RTMP-聚合消息.png" alt="RTMP-聚合消息" style="zoom:50%;">

<h3 id="用户控制消息"><a href="#用户控制消息" class="headerlink" title="用户控制消息"></a>用户控制消息</h3><ul>
<li><p>客户端或服务器发送此消息以通知对等方用户控制事件。</p>
</li>
<li><p>消息格式：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>StreamBegin(&#x3D;0)</td>
<td>服务器发送此事件通知客户端流成功创建，并可用于通信。默认情况下，在从客户端成功收到应用程序连接命令后，此事件以ID 0来发送<br>Event Data大小是4字节，表示开始运行的流的stream ID</td>
</tr>
<tr>
<td>StreamEOF(&#x3D;1)</td>
<td>服务器发送此事件通知客户端该流请求的数据回放结束。若不发出额外的命令，就没有更多的数据被发送了。客户端丢弃该流收到的消息<br>Event Data大小是4字节，代表播放已结束流的stream ID</td>
</tr>
<tr>
<td>StreamDry(&#x3D;2)</td>
<td>服务器发送此事件通知客户端，在流上没有更多的数据。如果服务器在一段时间内没有检测到任何的消息，它可以通知订阅的客户端流是结束的<br>Event Data大小是4字节，代表已结束流的stream ID</td>
</tr>
<tr>
<td>SetBufferLength(&#x3D;3)</td>
<td>客户端发送此事件通知服务器用于缓冲从流过来的任何数据的缓冲区大小（以毫秒为单位）。此事件在服务器开始处理流之前被发送<br>Event Data大小是8字节，前4字节是stream ID，后4字节是每毫秒缓冲区的长度</td>
</tr>
<tr>
<td>StreamIsRecorded (&#x3D;4)</td>
<td>服务器发送此事件来通知客户端，需要记录（录像）<br>Event Data大小是4字节，代表需要记录的流的stream ID</td>
</tr>
<tr>
<td>PingRequest(&#x3D;6)</td>
<td>服务器发送此事件来测试客户端是否是可到达的<br>Event Data大小是4字节，内容是时间戳，表示当服务器发出命令时，本地服务器的时间。客户收到PingRequest时响应PingResponse</td>
</tr>
<tr>
<td>PingResponse(&#x3D;7)</td>
<td>客户端向服务器发送此事件响应ping请求<br>Event Data大小是4字节，内容是收到PingRequest时时间戳</td>
</tr>
</tbody></table>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ul>
<li>为什么会有AMF0和AMF3？有什么区别？<ul>
<li>AMF从Flash MX时代的AMF0发展到现在的AMF3。AMF3用作Flash Playe 9的ActionScript 3.0的默认序列化格式，而AMF0则用作旧版的ActionScript 1.0和2.0的序列化格式。 在网络传输数据方面，AMF3比AMF0更有效率。AMF3能将int和uint对象作为整数（integer）传输，并且能序列化ActionScript 3.0才支持的数据类型, 比如ByteArray，XML和Iexternalizable。</li>
</ul>
</li>
<li>接收端如何知道哪些chunk属于同一个message？<ul>
<li>通过srs代码（SrsProtocol::read_message_payload）得知：接收端将接收到chunk的chunk data的大小加和，如果等于message payload（通过chunk-&gt;message header-&gt;message length获取）的则认为是同一个message。</li>
</ul>
</li>
<li>每个chunk的csid是否相同？<ul>
<li>csid是chunk的一个标识，csid和chunk的类型有关，所以同一类型的不同chunk的csid是相同的。csid和chunk是否属于同一个message没关系。</li>
</ul>
</li>
</ul>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuweifeng/p/17444833.html">https://www.cnblogs.com/yuweifeng/p/17444833.html</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/12/FFplay%E6%92%AD%E6%94%BE%E6%8E%A7%E5%88%B6/" rel="prev" title="FFplay播放控制">
                  <i class="fa fa-angle-left"></i> FFplay播放控制
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/19/RTP%E5%8D%8F%E8%AE%AE/" rel="next" title="RTP协议">
                  RTP协议 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fang</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
