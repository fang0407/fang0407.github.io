<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fang0407.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="流程分析初始化设置相关创建解复⽤器上下⽂12ic &#x3D; avformat_alloc_context();is-&gt;ic &#x3D; ic;  设置中断回调函数 如果出错或者退出，就根据⽬前程序设置的状态选择继续check或者直接退出。 当执⾏耗时操作时（⼀般是在执⾏while或者for循环的数据读取时：avformat_open_input，avformat_find_stream_info，av_r">
<meta property="og:type" content="article">
<meta property="og:title" content="FFplay解复用线程">
<meta property="og:url" content="https://fang0407.github.io/2023/09/08/FFplay%E8%A7%A3%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="NOTE">
<meta property="og:description" content="流程分析初始化设置相关创建解复⽤器上下⽂12ic &#x3D; avformat_alloc_context();is-&gt;ic &#x3D; ic;  设置中断回调函数 如果出错或者退出，就根据⽬前程序设置的状态选择继续check或者直接退出。 当执⾏耗时操作时（⼀般是在执⾏while或者for循环的数据读取时：avformat_open_input，avformat_find_stream_info，av_r">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-08T14:07:07.000Z">
<meta property="article:modified_time" content="2023-12-30T14:40:30.941Z">
<meta property="article:author" content="Fang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fang0407.github.io/2023/09/08/FFplay%E8%A7%A3%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://fang0407.github.io/2023/09/08/FFplay%E8%A7%A3%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B/","path":"2023/09/08/FFplay解复用线程/","title":"FFplay解复用线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>FFplay解复用线程 | NOTE</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NOTE</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="nav-number">1.1.</span> <span class="nav-text">初始化设置相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A3%E5%A4%8D%E2%BD%A4%E5%99%A8%E4%B8%8A%E4%B8%8B%E2%BD%82"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建解复⽤器上下⽂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">设置中断回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%AA%92%E4%BD%93%E2%BD%82%E4%BB%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">打开媒体⽂件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.4.</span> <span class="nav-text">读取流信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E6%8C%87%E5%AE%9A%E6%92%AD%E6%94%BE%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4"><span class="nav-number">1.1.5.</span> <span class="nav-text">是否指定播放起始时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%B5%81"><span class="nav-number">1.1.6.</span> <span class="nav-text">查找流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%98%BE%E7%A4%BA%E7%AA%97%E2%BC%9D%E7%9A%84%E5%AE%BD%E5%92%8C%E2%BE%BC"><span class="nav-number">1.1.7.</span> <span class="nav-text">计算显示窗⼝的宽和⾼</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%B5%81%E7%BB%84%E4%BB%B6"><span class="nav-number">1.1.8.</span> <span class="nav-text">打开流组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">打开解码器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">解码器初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%A7%A3%E7%A0%81%E5%99%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">启动解码器线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.</span> <span class="nav-text">循环读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E9%80%80%E5%87%BA"><span class="nav-number">1.2.1.</span> <span class="nav-text">检测是否退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%9A%82%E5%81%9C%E6%88%96%E7%BB%A7%E7%BB%AD%E6%92%AD%E6%94%BE"><span class="nav-number">1.2.2.</span> <span class="nav-text">检测是否暂停或继续播放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81seek"><span class="nav-number">1.2.3.</span> <span class="nav-text">检测是否需要seek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8Bvideo%E6%98%AF%E5%90%A6%E4%B8%BAattached-pic"><span class="nav-number">1.2.4.</span> <span class="nav-text">检测video是否为attached_pic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E6%9C%89%E2%BE%9C%E5%A4%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.5.</span> <span class="nav-text">检测队列是否已经有⾜够数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E7%A0%81%E6%B5%81%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E6%92%AD%E6%94%BE%E7%BB%93%E6%9D%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">检测码流是否已经播放结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">1.2.7.</span> <span class="nav-text">读取数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%AF%95"><span class="nav-number">1.2.8.</span> <span class="nav-text">检测数据是否读取完毕</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%9C%A8%E6%92%AD%E6%94%BE%E8%8C%83%E5%9B%B4%E5%86%85"><span class="nav-number">1.2.9.</span> <span class="nav-text">检测是否在播放范围内</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%BE%B3%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E5%88%86%E5%88%AB%E9%80%81%E2%BC%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E9%98%9F%E5%88%97%E4%B8%AD"><span class="nav-number">1.2.10.</span> <span class="nav-text">⾳视频数据分别送⼊相应的队列中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86"><span class="nav-number">1.2.11.</span> <span class="nav-text">退出线程处理</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fang0407.github.io/2023/09/08/FFplay%E8%A7%A3%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="FFplay解复用线程 | NOTE">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FFplay解复用线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-08 22:07:07" itemprop="dateCreated datePublished" datetime="2023-09-08T22:07:07+08:00">2023-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:40:30" itemprop="dateModified" datetime="2023-12-30T22:40:30+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/FFplay/" itemprop="url" rel="index"><span itemprop="name">FFplay</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><h2 id="初始化设置相关"><a href="#初始化设置相关" class="headerlink" title="初始化设置相关"></a>初始化设置相关</h2><h3 id="创建解复⽤器上下⽂"><a href="#创建解复⽤器上下⽂" class="headerlink" title="创建解复⽤器上下⽂"></a>创建解复⽤器上下⽂</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic = avformat_alloc_context();</span><br><span class="line">is-&gt;ic = ic;</span><br></pre></td></tr></table></figure>

<h3 id="设置中断回调函数"><a href="#设置中断回调函数" class="headerlink" title="设置中断回调函数"></a>设置中断回调函数</h3><ul>
<li>如果出错或者退出，就根据⽬前程序设置的状态选择继续check或者直接退出。</li>
<li>当执⾏耗时操作时（⼀般是在执⾏while或者for循环的数据读取时：avformat_open_input，avformat_find_stream_info，av_read_frame），会调⽤回调。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_interrupt_cb</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = ctx;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;abort_request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ic-&gt;interrupt_callback.callback = decode_interrupt_cb;</span><br><span class="line">ic-&gt;interrupt_callback.opaque = is;</span><br></pre></td></tr></table></figure>

<h3 id="打开媒体⽂件"><a href="#打开媒体⽂件" class="headerlink" title="打开媒体⽂件"></a>打开媒体⽂件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scan_all_pmts是mpegts的⼀个选项，表示扫描全部的ts流的&quot;Program Map Table&quot;表。</span></span><br><span class="line"><span class="keyword">if</span> (!av_dict_get(format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE)) &#123;</span><br><span class="line">    av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="string">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);</span><br><span class="line">    scan_all_pmts_set = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);</span><br></pre></td></tr></table></figure>

<h3 id="读取流信息"><a href="#读取流信息" class="headerlink" title="读取流信息"></a>读取流信息</h3><p>avformat_find_stream_info函数是通过读取媒体⽂件的部分数据来分析流信息。在⼀些缺少头信息的封装下特别有⽤，⽐如说MPEG（⾥应该说ts更准确）（FLV⽂件也是需要读取packet 分析流信息）。⽽被读取⽤以分析流信息的数据可能被缓存，供av_read_frame时使⽤，在播放时并不会跳过这部分packet的读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avformat_find_stream_info(ic, opts);</span><br></pre></td></tr></table></figure>

<h3 id="是否指定播放起始时间"><a href="#是否指定播放起始时间" class="headerlink" title="是否指定播放起始时间"></a>是否指定播放起始时间</h3><p>如果指定时间则seek到指定位置avformat_seek_file。 可以通过 ffplay -ss 设置起始时间，时间格式hh:mm:ss，⽐如<code>ffplay -ss 00:00:30 test.flv</code> 则是从30秒的起始位置开始播放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if seeking requested, we execute it */</span></span><br><span class="line"><span class="keyword">if</span> (start_time != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    <span class="type">int64_t</span> timestamp;</span><br><span class="line">    timestamp = start_time;</span><br><span class="line">    <span class="comment">/* add the stream start time */</span></span><br><span class="line">    <span class="keyword">if</span> (ic-&gt;start_time != AV_NOPTS_VALUE)</span><br><span class="line">        timestamp += ic-&gt;start_time;</span><br><span class="line">    ret = avformat_seek_file(ic, <span class="number">-1</span>, INT64_MIN, timestamp, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;%s: could not seek to position %0.3f\n&quot;</span>,</span><br><span class="line">               is-&gt;filename, (<span class="type">double</span>)timestamp / AV_TIME_BASE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找流"><a href="#查找流" class="headerlink" title="查找流"></a>查找流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; &quot;ast&quot;, OPT_STRING | HAS_ARG | OPT_EXPERT, &#123; &amp;wanted_stream_spec[AVMEDIA_TYPE_AUDIO] &#125;, &quot;select desired audio stream&quot;, &quot;stream_specifier&quot; &#125;,</span></span><br><span class="line"><span class="comment">&#123; &quot;vst&quot;, OPT_STRING | HAS_ARG | OPT_EXPERT, &#123; &amp;wanted_stream_spec[AVMEDIA_TYPE_VIDEO] &#125;, &quot;select desired video stream&quot;, &quot;stream_specifier&quot; &#125;,</span></span><br><span class="line"><span class="comment">&#123; &quot;sst&quot;, OPT_STRING | HAS_ARG | OPT_EXPERT, &#123; &amp;wanted_stream_spec[AVMEDIA_TYPE_SUBTITLE] &#125;, &quot;select desired subtitle stream&quot;, &quot;stream_specifier&quot; &#125;,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-ast n 指定⾳频流</span></span><br><span class="line"><span class="comment">-vst n 指定视频流 </span></span><br><span class="line"><span class="comment">-vst n 指定字幕流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//命令指定流ID</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">    AVStream *st = ic-&gt;streams[i];</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">    st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">    <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">            st_index[type] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, </span><br><span class="line">               wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">        st_index[i] = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//av_find_best_stream选择流</span></span><br><span class="line"><span class="keyword">if</span> (!video_disable)</span><br><span class="line">    st_index[AVMEDIA_TYPE_VIDEO] =</span><br><span class="line">    av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,</span><br><span class="line">                        st_index[AVMEDIA_TYPE_VIDEO], <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!audio_disable)</span><br><span class="line">    st_index[AVMEDIA_TYPE_AUDIO] =</span><br><span class="line">    av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,</span><br><span class="line">                        st_index[AVMEDIA_TYPE_AUDIO],</span><br><span class="line">                        st_index[AVMEDIA_TYPE_VIDEO],</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!video_disable &amp;&amp; !subtitle_disable)</span><br><span class="line">    st_index[AVMEDIA_TYPE_SUBTITLE] =</span><br><span class="line">    av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">                        st_index[AVMEDIA_TYPE_SUBTITLE],</span><br><span class="line">                        (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span> ?</span><br><span class="line">                         st_index[AVMEDIA_TYPE_AUDIO] :</span><br><span class="line">                         st_index[AVMEDIA_TYPE_VIDEO]),</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="计算显示窗⼝的宽和⾼"><a href="#计算显示窗⼝的宽和⾼" class="headerlink" title="计算显示窗⼝的宽和⾼"></a>计算显示窗⼝的宽和⾼</h3><p>这⾥实质只是设置了default_width、default_height变量的⼤⼩，没有真正改变窗⼝的⼤⼩。真正调整窗⼝⼤⼩是在视频显示调⽤video_open()函数进⾏设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从待处理流中获取相关参数，设置显示窗⼝的宽度、⾼度及宽⾼⽐</span></span><br><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">    AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">    <span class="comment">//根据流和帧宽⾼⽐猜测帧的样本宽⾼⽐</span></span><br><span class="line">    AVRational sar = av_guess_sample_aspect_ratio(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (codecpar-&gt;width)</span><br><span class="line">        <span class="comment">//设置显示窗⼝的⼤⼩和宽⾼⽐</span></span><br><span class="line">        set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打开流组件"><a href="#打开流组件" class="headerlink" title="打开流组件"></a>打开流组件</h3><p>⾳频、视频、字幕等流都要调⽤stream_component_open。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* open the streams */</span></span><br><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (is-&gt;show_mode == SHOW_MODE_NONE)</span><br><span class="line">    is-&gt;show_mode = ret &gt;= <span class="number">0</span> ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打开解码器"><a href="#打开解码器" class="headerlink" title="打开解码器"></a>打开解码器</h4><p>分配解码器上下⽂，然后通过avcodec_parameters_to_context 把所选流的解码参数赋给avctx ，并设置time_base，最后查找所需解码器，打开解码器。</p>
<p>avcodec_parameters_to_context 解码时⽤，avcodec_parameters_from_context则⽤于编码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!avctx)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">avctx-&gt;pkt_timebase = ic-&gt;streams[stream_index]-&gt;time_base;</span><br><span class="line"></span><br><span class="line">codec = avcodec_find_decoder(avctx-&gt;codec_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解码器初始化"><a href="#解码器初始化" class="headerlink" title="解码器初始化"></a>解码器初始化</h4><p>即根据具体的流类型，作特定的初始化。但不论哪种流，基本步骤都包括了ffplay封装的解码器的初始化和启动解码器线程： </p>
<p>对应⾳频⽽⾔，还初始化了输出参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decoder_init</span><span class="params">(Decoder *d, AVCodecContext *avctx, PacketQueue *<span class="built_in">queue</span>, SDL_cond *empty_queue_cond)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(Decoder));</span><br><span class="line">    d-&gt;avctx = avctx;    <span class="comment">//绑定对应的解码器上下⽂</span></span><br><span class="line">    d-&gt;<span class="built_in">queue</span> = <span class="built_in">queue</span>;    <span class="comment">//绑定对应的packet队列</span></span><br><span class="line">    d-&gt;empty_queue_cond = empty_queue_cond;</span><br><span class="line">    d-&gt;start_pts = AV_NOPTS_VALUE;</span><br><span class="line">    d-&gt;pkt_serial = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动解码器线程"><a href="#启动解码器线程" class="headerlink" title="启动解码器线程"></a>启动解码器线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_start</span><span class="params">(Decoder *d, <span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">const</span> <span class="type">char</span> *thread_name, <span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    packet_queue_start(d-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    d-&gt;decoder_tid = SDL_CreateThread(fn, thread_name, arg);</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;decoder_tid) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;SDL_CreateThread(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环读取数据"><a href="#循环读取数据" class="headerlink" title="循环读取数据"></a>循环读取数据</h2><h3 id="检测是否退出"><a href="#检测是否退出" class="headerlink" title="检测是否退出"></a>检测是否退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;abort_request)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="检测是否暂停或继续播放"><a href="#检测是否暂停或继续播放" class="headerlink" title="检测是否暂停或继续播放"></a>检测是否暂停或继续播放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网络流</span></span><br><span class="line"><span class="keyword">if</span> (is-&gt;paused != is-&gt;last_paused) &#123;</span><br><span class="line">    is-&gt;last_paused = is-&gt;paused;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        is-&gt;read_pause_return = av_read_pause(ic);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        av_read_play(ic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测是否需要seek"><a href="#检测是否需要seek" class="headerlink" title="检测是否需要seek"></a>检测是否需要seek</h3><ul>
<li>主要通过avformat_seek_file完成，如果seek成功：<ul>
<li>清除PacketQueue的缓存，并放⼊⼀个flush_pkt。放⼊的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据（PacketQueue函数的分析0），该flush_pkt也会触发解码器重新刷新解码器缓存avcodec_flush_buffers()，以避免解码时使⽤了原来的buffer作为参考⽽出现⻢赛克。 </li>
<li>同步外部时钟。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;seek_req) &#123;</span><br><span class="line">    <span class="type">int64_t</span> seek_target = is-&gt;seek_pos;</span><br><span class="line">    <span class="type">int64_t</span> seek_min    = is-&gt;seek_rel &gt; <span class="number">0</span> ? seek_target - is-&gt;seek_rel + <span class="number">2</span>: INT64_MIN;</span><br><span class="line">    <span class="type">int64_t</span> seek_max    = is-&gt;seek_rel &lt; <span class="number">0</span> ? seek_target - is-&gt;seek_rel - <span class="number">2</span>: INT64_MAX;</span><br><span class="line">    <span class="comment">// FIXME the +-2 is due to rounding being not done in the correct direction in generation</span></span><br><span class="line">    <span class="comment">//      of the seek_pos/seek_rel variables</span></span><br><span class="line"></span><br><span class="line">    ret = avformat_seek_file(is-&gt;ic, <span class="number">-1</span>, seek_min, seek_target, seek_max, is-&gt;seek_flags);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;%s: error while seeking\n&quot;</span>, is-&gt;ic-&gt;url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            packet_queue_flush(&amp;is-&gt;audioq);</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            packet_queue_flush(&amp;is-&gt;subtitleq);</span><br><span class="line">            packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            packet_queue_flush(&amp;is-&gt;videoq);</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;seek_flags &amp; AVSEEK_FLAG_BYTE) &#123;</span><br><span class="line">            set_clock(&amp;is-&gt;extclk, NAN, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set_clock(&amp;is-&gt;extclk, seek_target / (<span class="type">double</span>)AV_TIME_BASE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;seek_req = <span class="number">0</span>;</span><br><span class="line">    is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">    is-&gt;eof = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果本身是pause状态的则显示⼀帧继续暂停</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        step_to_next_frame(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测video是否为attached-pic"><a href="#检测video是否为attached-pic" class="headerlink" title="检测video是否为attached_pic"></a>检测video是否为attached_pic</h3><p>AV_DISPOSITION_ATTACHED_PIC是⼀个标志。如果⼀个流中含有这个标志的话，那么就是说这个流是 *.mp3等⽂件中的⼀个 Video Stream 。并且该流只有⼀个 AVPacket ，也就是attached_pic 。这个 AVPacket 中所存储的内容就是这个 *.mp3等⽂件的封⾯图⽚。st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC 这个操作可以决定是否可以继续向缓冲区中添加 AVPacket 。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;queue_attachments_req) &#123;</span><br><span class="line">    <span class="comment">// attached_pic 附带的图⽚</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_st &amp;&amp; is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) &#123;</span><br><span class="line">        AVPacket copy = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> ((ret = av_packet_ref(&amp;copy, &amp;is-&gt;video_st-&gt;attached_pic)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        packet_queue_put(&amp;is-&gt;videoq, &amp;copy);</span><br><span class="line">        packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);</span><br><span class="line">    &#125;</span><br><span class="line">    is-&gt;queue_attachments_req = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测队列是否已经有⾜够数据"><a href="#检测队列是否已经有⾜够数据" class="headerlink" title="检测队列是否已经有⾜够数据"></a>检测队列是否已经有⾜够数据</h3><p>⾳频、视频、字幕队列都不是⽆限⼤的，如果不加以限制⼀直往队列放⼊packet，那将导致队列占⽤⼤量的内存空间，影响系统的性能，所以必须对队列的缓存⼤⼩进⾏控制。PacketQueue默认情况下会有⼤⼩限制，达到这个⼤⼩后，就需要等待10ms，以让消费者——解码线程能有时间消耗。 </p>
<p>缓冲区满有两种可能： </p>
<ul>
<li>audioq，videoq，subtitleq三个PacketQueue的总字节数达到了MAX_QUEUE_SIZE（15M，这⾥只是⼀个经验计算值，⽐如4K视频的码率以50Mbps计算，则15MB可以缓存2.4秒，从这么计算实际上如果我们真的是播放4K⽚源，15MB是偏⼩的数值，有些⽚源⽐较坑 同⼀个⽂件位置附近的pts差值超过5秒，此时如果视频要缓存5秒才能做同步，那15MB的缓存⼤⼩就不够了） 。</li>
<li>⾳频、视频、字幕流都已有够⽤的包（stream_has_enough_packets）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if the queue are full, no need to read more */</span></span><br><span class="line"><span class="keyword">if</span> (infinite_buffer&lt;<span class="number">1</span> &amp;&amp;</span><br><span class="line">    (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; MAX_QUEUE_SIZE</span><br><span class="line">     || (stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream, &amp;is-&gt;audioq) &amp;&amp;</span><br><span class="line">         stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream, &amp;is-&gt;videoq) &amp;&amp;</span><br><span class="line">         stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream, &amp;is-&gt;subtitleq)))) &#123;</span><br><span class="line">    <span class="comment">/* wait 10 ms */</span></span><br><span class="line">    SDL_LockMutex(wait_mutex);</span><br><span class="line">    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class="number">10</span>);</span><br><span class="line">    SDL_UnlockMutex(wait_mutex);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!is-&gt;paused &amp;&amp;</span><br><span class="line">    (!is-&gt;audio_st || (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;sampq) == <span class="number">0</span>))&amp;&amp;</span><br><span class="line">    (!is-&gt;video_st || (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (loop != <span class="number">1</span> &amp;&amp; (!loop || --loop)) &#123;</span><br><span class="line">        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (autoexit) &#123;</span><br><span class="line">        ret = AVERROR_EOF;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断⾳频、视频、字幕流都是否有够⽤的包。</p>
<ul>
<li><p>流没有打开（stream_id &lt; 0），没有相应的流返回逻辑true。</p>
</li>
<li><p>有退出请求（queue-&gt;abort_request） 。</p>
</li>
<li><p>配置了AV_DISPOSITION_ATTACHED_PIC。</p>
</li>
<li><p>packet队列内包个数⼤于MIN_FRAMES（25），并满⾜PacketQueue总时⻓为0或总时⻓超过1s</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stream_has_enough_packets</span><span class="params">(AVStream *st, <span class="type">int</span> stream_id, PacketQueue *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stream_id &lt; <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">queue</span>-&gt;abort_request ||</span><br><span class="line">           (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) ||</span><br><span class="line">           <span class="built_in">queue</span>-&gt;nb_packets &gt; MIN_FRAMES &amp;&amp; (!<span class="built_in">queue</span>-&gt;duration || av_q2d(st-&gt;time_base) * <span class="built_in">queue</span>-&gt;duration &gt; <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测码流是否已经播放结束"><a href="#检测码流是否已经播放结束" class="headerlink" title="检测码流是否已经播放结束"></a>检测码流是否已经播放结束</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!is-&gt;paused &amp;&amp;	<span class="comment">//不在暂停状态</span></span><br><span class="line">    (!is-&gt;audio_st || </span><br><span class="line">     (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp;	<span class="comment">//⾳频播放完毕 </span></span><br><span class="line">      frame_queue_nb_remaining(&amp;is-&gt;sampq) == <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">    (!is-&gt;video_st || </span><br><span class="line">     (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp; 	<span class="comment">//视频播放完毕</span></span><br><span class="line">      frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (loop != <span class="number">1</span> &amp;&amp; (!loop || --loop)) &#123;</span><br><span class="line">        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (autoexit) &#123;</span><br><span class="line">        ret = AVERROR_EOF;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取数据包"><a href="#读取数据包" class="headerlink" title="读取数据包"></a>读取数据包</h3><p>传⼊的packet，av_read_frame不会释放其数据，⽽是每次用户手动释放数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = av_read_frame(ic, pkt);</span><br></pre></td></tr></table></figure>

<h3 id="检测数据是否读取完毕"><a href="#检测数据是否读取完毕" class="headerlink" title="检测数据是否读取完毕"></a>检测数据是否读取完毕</h3><p>数据读取完毕后，放对应⾳频、视频、字幕队列插⼊“空包”，以通知解码器冲刷buffer，将缓存的所有数据都解出来frame并去出来。然后继续在for{}循环，直到收到退出命令，或者loop播放，或者seek等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ret == AVERROR_EOF || avio_feof(ic-&gt;pb)) &amp;&amp; !is-&gt;eof) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//插⼊空包说明码流数据读取完毕了，刷空包是为了从解码器把所有帧都读出来</span></span><br><span class="line">            packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>)</span><br><span class="line">            packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>)</span><br><span class="line">            packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);</span><br><span class="line">        is-&gt;eof = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ic-&gt;pb &amp;&amp; ic-&gt;pb-&gt;error)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    SDL_LockMutex(wait_mutex);</span><br><span class="line">    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class="number">10</span>);</span><br><span class="line">    SDL_UnlockMutex(wait_mutex);</span><br><span class="line">    <span class="keyword">continue</span>;	<span class="comment">//继续循环 保证线程的运⾏，⽐如要seek到某个位置播放可以继续响应</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    is-&gt;eof = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测是否在播放范围内"><a href="#检测是否在播放范围内" class="headerlink" title="检测是否在播放范围内"></a>检测是否在播放范围内</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check if packet is in play range specified by user, then queue, otherwise discard */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stream_start_time：是从当前流AVStream-&gt;start_time获取到的时间，如果没有定义具体的值则默认为AV_NOPTS_VALUE，即该值是⽆效的；那stream_start_time有意义的就是0值；</span></span><br><span class="line">stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;</span><br><span class="line"><span class="comment">//当前packet的时间戳，pts有效就⽤pts的，pts⽆效就⽤dts的</span></span><br><span class="line">pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pkt_ts - stream_start_time - start_time &lt; duration</span></span><br><span class="line">pkt_in_play_range = duration == AV_NOPTS_VALUE ||</span><br><span class="line">                    (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class="number">0</span>)) *</span><br><span class="line">                                av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -</span><br><span class="line">                            (<span class="type">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>) / <span class="number">1000000</span></span><br><span class="line">                        &lt;= ((<span class="type">double</span>)duration / <span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="⾳视频数据分别送⼊相应的队列中"><a href="#⾳视频数据分别送⼊相应的队列中" class="headerlink" title="⾳视频数据分别送⼊相应的队列中"></a>⾳视频数据分别送⼊相应的队列中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将⾳视频数据分别送⼊相应的queue中</span></span><br><span class="line"><span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">    packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range</span><br><span class="line">           &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;</span><br><span class="line">    packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">    packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不⼊队列则直接释放数据</span></span><br><span class="line">    av_packet_unref(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="退出线程处理"><a href="#退出线程处理" class="headerlink" title="退出线程处理"></a>退出线程处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ic &amp;&amp; !is-&gt;ic)</span><br><span class="line">    avformat_close_input(&amp;ic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line"></span><br><span class="line">    event.type = FF_QUIT_EVENT;</span><br><span class="line">    event.user.data1 = is;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">&#125;</span><br><span class="line">SDL_DestroyMutex(wait_mutex);</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/08/FFplay%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="FFplay数据结构">
                  <i class="fa fa-angle-left"></i> FFplay数据结构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/09/FFplay%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/" rel="next" title="FFplay音视频解码线程">
                  FFplay音视频解码线程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Fang</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
